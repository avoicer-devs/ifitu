// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `finance.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:finance.Transfer)
pub struct Transfer {
    // special fields
    // @@protoc_insertion_point(special_field:finance.Transfer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Transfer {
    fn default() -> &'a Transfer {
        <Transfer as ::protobuf::Message>::default_instance()
    }
}

impl Transfer {
    pub fn new() -> Transfer {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Transfer>(
            "Transfer",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Transfer {
    const NAME: &'static str = "Transfer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Transfer {
        Transfer::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Transfer {
        static instance: Transfer = Transfer {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Transfer {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Transfer").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Transfer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Transfer {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:finance.Invoice)
pub struct Invoice {
    // message fields
    // @@protoc_insertion_point(field:finance.Invoice.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:finance.Invoice.total)
    pub total: i32,
    // @@protoc_insertion_point(field:finance.Invoice.line_items)
    pub line_items: ::std::vec::Vec<LineItem>,
    // special fields
    // @@protoc_insertion_point(special_field:finance.Invoice.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Invoice {
    fn default() -> &'a Invoice {
        <Invoice as ::protobuf::Message>::default_instance()
    }
}

impl Invoice {
    pub fn new() -> Invoice {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Invoice| { &m.id },
            |m: &mut Invoice| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "total",
            |m: &Invoice| { &m.total },
            |m: &mut Invoice| { &mut m.total },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "line_items",
            |m: &Invoice| { &m.line_items },
            |m: &mut Invoice| { &mut m.line_items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Invoice>(
            "Invoice",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Invoice {
    const NAME: &'static str = "Invoice";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                16 => {
                    self.total = is.read_int32()?;
                },
                26 => {
                    self.line_items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if self.total != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.total);
        }
        for value in &self.line_items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if self.total != 0 {
            os.write_int32(2, self.total)?;
        }
        for v in &self.line_items {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Invoice {
        Invoice::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.total = 0;
        self.line_items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Invoice {
        static instance: Invoice = Invoice {
            id: ::std::string::String::new(),
            total: 0,
            line_items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Invoice {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Invoice").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Invoice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Invoice {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:finance.Statement)
pub struct Statement {
    // message fields
    // @@protoc_insertion_point(field:finance.Statement.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:finance.Statement.total)
    pub total: i32,
    // @@protoc_insertion_point(field:finance.Statement.line_items)
    pub line_items: ::std::vec::Vec<LineItem>,
    // special fields
    // @@protoc_insertion_point(special_field:finance.Statement.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Statement {
    fn default() -> &'a Statement {
        <Statement as ::protobuf::Message>::default_instance()
    }
}

impl Statement {
    pub fn new() -> Statement {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Statement| { &m.id },
            |m: &mut Statement| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "total",
            |m: &Statement| { &m.total },
            |m: &mut Statement| { &mut m.total },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "line_items",
            |m: &Statement| { &m.line_items },
            |m: &mut Statement| { &mut m.line_items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Statement>(
            "Statement",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Statement {
    const NAME: &'static str = "Statement";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                16 => {
                    self.total = is.read_int32()?;
                },
                26 => {
                    self.line_items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if self.total != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.total);
        }
        for value in &self.line_items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if self.total != 0 {
            os.write_int32(2, self.total)?;
        }
        for v in &self.line_items {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Statement {
        Statement::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.total = 0;
        self.line_items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Statement {
        static instance: Statement = Statement {
            id: ::std::string::String::new(),
            total: 0,
            line_items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Statement {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Statement").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Statement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Statement {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:finance.Bill)
pub struct Bill {
    // message fields
    // @@protoc_insertion_point(field:finance.Bill.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:finance.Bill.total)
    pub total: i32,
    // @@protoc_insertion_point(field:finance.Bill.line_items)
    pub line_items: ::std::vec::Vec<LineItem>,
    // special fields
    // @@protoc_insertion_point(special_field:finance.Bill.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Bill {
    fn default() -> &'a Bill {
        <Bill as ::protobuf::Message>::default_instance()
    }
}

impl Bill {
    pub fn new() -> Bill {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Bill| { &m.id },
            |m: &mut Bill| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "total",
            |m: &Bill| { &m.total },
            |m: &mut Bill| { &mut m.total },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "line_items",
            |m: &Bill| { &m.line_items },
            |m: &mut Bill| { &mut m.line_items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Bill>(
            "Bill",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Bill {
    const NAME: &'static str = "Bill";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                16 => {
                    self.total = is.read_int32()?;
                },
                26 => {
                    self.line_items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if self.total != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.total);
        }
        for value in &self.line_items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if self.total != 0 {
            os.write_int32(2, self.total)?;
        }
        for v in &self.line_items {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Bill {
        Bill::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.total = 0;
        self.line_items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Bill {
        static instance: Bill = Bill {
            id: ::std::string::String::new(),
            total: 0,
            line_items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Bill {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Bill").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Bill {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Bill {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:finance.Transaction)
pub struct Transaction {
    // message fields
    // @@protoc_insertion_point(field:finance.Transaction.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:finance.Transaction.total)
    pub total: i32,
    // @@protoc_insertion_point(field:finance.Transaction.line_items)
    pub line_items: ::std::vec::Vec<LineItem>,
    // special fields
    // @@protoc_insertion_point(special_field:finance.Transaction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Transaction {
    fn default() -> &'a Transaction {
        <Transaction as ::protobuf::Message>::default_instance()
    }
}

impl Transaction {
    pub fn new() -> Transaction {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Transaction| { &m.id },
            |m: &mut Transaction| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "total",
            |m: &Transaction| { &m.total },
            |m: &mut Transaction| { &mut m.total },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "line_items",
            |m: &Transaction| { &m.line_items },
            |m: &mut Transaction| { &mut m.line_items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Transaction>(
            "Transaction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Transaction {
    const NAME: &'static str = "Transaction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                16 => {
                    self.total = is.read_int32()?;
                },
                26 => {
                    self.line_items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if self.total != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.total);
        }
        for value in &self.line_items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if self.total != 0 {
            os.write_int32(2, self.total)?;
        }
        for v in &self.line_items {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Transaction {
        Transaction::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.total = 0;
        self.line_items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Transaction {
        static instance: Transaction = Transaction {
            id: ::std::string::String::new(),
            total: 0,
            line_items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Transaction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Transaction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Transaction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Transaction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:finance.LineItem)
pub struct LineItem {
    // message fields
    // @@protoc_insertion_point(field:finance.LineItem.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:finance.LineItem.account)
    pub account: ::std::string::String,
    // @@protoc_insertion_point(field:finance.LineItem.code)
    pub code: ::std::string::String,
    // @@protoc_insertion_point(field:finance.LineItem.quantity)
    pub quantity: i32,
    // @@protoc_insertion_point(field:finance.LineItem.unit_price)
    pub unit_price: i32,
    // @@protoc_insertion_point(field:finance.LineItem.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:finance.LineItem.description)
    pub description: ::std::string::String,
    // @@protoc_insertion_point(field:finance.LineItem.amount)
    pub amount: i32,
    // @@protoc_insertion_point(field:finance.LineItem.currency)
    pub currency: ::protobuf::EnumOrUnknown<super::global::Currency>,
    ///  TODO: maybe this should just be an item as it already has a type of tax 
    ///  or should/could it be a list of rates? 
    // @@protoc_insertion_point(field:finance.LineItem.item_rate)
    pub item_rate: ::protobuf::MessageField<super::global::Rate>,
    // @@protoc_insertion_point(field:finance.LineItem.tax_rate)
    pub tax_rate: ::protobuf::MessageField<super::global::Rate>,
    // @@protoc_insertion_point(field:finance.LineItem.reference)
    pub reference: ::std::string::String,
    // @@protoc_insertion_point(field:finance.LineItem.attributes)
    pub attributes: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:finance.LineItem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LineItem {
    fn default() -> &'a LineItem {
        <LineItem as ::protobuf::Message>::default_instance()
    }
}

impl LineItem {
    pub fn new() -> LineItem {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(13);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &LineItem| { &m.id },
            |m: &mut LineItem| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "account",
            |m: &LineItem| { &m.account },
            |m: &mut LineItem| { &mut m.account },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "code",
            |m: &LineItem| { &m.code },
            |m: &mut LineItem| { &mut m.code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "quantity",
            |m: &LineItem| { &m.quantity },
            |m: &mut LineItem| { &mut m.quantity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unit_price",
            |m: &LineItem| { &m.unit_price },
            |m: &mut LineItem| { &mut m.unit_price },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &LineItem| { &m.name },
            |m: &mut LineItem| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "description",
            |m: &LineItem| { &m.description },
            |m: &mut LineItem| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "amount",
            |m: &LineItem| { &m.amount },
            |m: &mut LineItem| { &mut m.amount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "currency",
            |m: &LineItem| { &m.currency },
            |m: &mut LineItem| { &mut m.currency },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::global::Rate>(
            "item_rate",
            |m: &LineItem| { &m.item_rate },
            |m: &mut LineItem| { &mut m.item_rate },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::global::Rate>(
            "tax_rate",
            |m: &LineItem| { &m.tax_rate },
            |m: &mut LineItem| { &mut m.tax_rate },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "reference",
            |m: &LineItem| { &m.reference },
            |m: &mut LineItem| { &mut m.reference },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "attributes",
            |m: &LineItem| { &m.attributes },
            |m: &mut LineItem| { &mut m.attributes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LineItem>(
            "LineItem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LineItem {
    const NAME: &'static str = "LineItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.account = is.read_string()?;
                },
                26 => {
                    self.code = is.read_string()?;
                },
                32 => {
                    self.quantity = is.read_int32()?;
                },
                40 => {
                    self.unit_price = is.read_int32()?;
                },
                50 => {
                    self.name = is.read_string()?;
                },
                58 => {
                    self.description = is.read_string()?;
                },
                64 => {
                    self.amount = is.read_int32()?;
                },
                72 => {
                    self.currency = is.read_enum_or_unknown()?;
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.item_rate)?;
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.tax_rate)?;
                },
                98 => {
                    self.reference = is.read_string()?;
                },
                106 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.attributes.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.account.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.account);
        }
        if !self.code.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.code);
        }
        if self.quantity != 0 {
            my_size += ::protobuf::rt::int32_size(4, self.quantity);
        }
        if self.unit_price != 0 {
            my_size += ::protobuf::rt::int32_size(5, self.unit_price);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.name);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.description);
        }
        if self.amount != 0 {
            my_size += ::protobuf::rt::int32_size(8, self.amount);
        }
        if self.currency != ::protobuf::EnumOrUnknown::new(super::global::Currency::CURRENCY_UNSPECIFIED) {
            my_size += ::protobuf::rt::int32_size(9, self.currency.value());
        }
        if let Some(v) = self.item_rate.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.tax_rate.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.reference.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.reference);
        }
        for (k, v) in &self.attributes {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.account.is_empty() {
            os.write_string(2, &self.account)?;
        }
        if !self.code.is_empty() {
            os.write_string(3, &self.code)?;
        }
        if self.quantity != 0 {
            os.write_int32(4, self.quantity)?;
        }
        if self.unit_price != 0 {
            os.write_int32(5, self.unit_price)?;
        }
        if !self.name.is_empty() {
            os.write_string(6, &self.name)?;
        }
        if !self.description.is_empty() {
            os.write_string(7, &self.description)?;
        }
        if self.amount != 0 {
            os.write_int32(8, self.amount)?;
        }
        if self.currency != ::protobuf::EnumOrUnknown::new(super::global::Currency::CURRENCY_UNSPECIFIED) {
            os.write_enum(9, ::protobuf::EnumOrUnknown::value(&self.currency))?;
        }
        if let Some(v) = self.item_rate.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.tax_rate.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if !self.reference.is_empty() {
            os.write_string(12, &self.reference)?;
        }
        for (k, v) in &self.attributes {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(106)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LineItem {
        LineItem::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.account.clear();
        self.code.clear();
        self.quantity = 0;
        self.unit_price = 0;
        self.name.clear();
        self.description.clear();
        self.amount = 0;
        self.currency = ::protobuf::EnumOrUnknown::new(super::global::Currency::CURRENCY_UNSPECIFIED);
        self.item_rate.clear();
        self.tax_rate.clear();
        self.reference.clear();
        self.attributes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LineItem {
        static instance: ::protobuf::rt::Lazy<LineItem> = ::protobuf::rt::Lazy::new();
        instance.get(LineItem::new)
    }
}

impl ::protobuf::MessageFull for LineItem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LineItem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LineItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LineItem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:finance.ExperienceTuple)
pub struct ExperienceTuple {
    // message fields
    // @@protoc_insertion_point(field:finance.ExperienceTuple.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:finance.ExperienceTuple.description)
    pub description: ::std::string::String,
    // @@protoc_insertion_point(field:finance.ExperienceTuple.quantity)
    pub quantity: i32,
    // @@protoc_insertion_point(field:finance.ExperienceTuple.unit_price)
    pub unit_price: i32,
    // @@protoc_insertion_point(field:finance.ExperienceTuple.amount)
    pub amount: i32,
    // special fields
    // @@protoc_insertion_point(special_field:finance.ExperienceTuple.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ExperienceTuple {
    fn default() -> &'a ExperienceTuple {
        <ExperienceTuple as ::protobuf::Message>::default_instance()
    }
}

impl ExperienceTuple {
    pub fn new() -> ExperienceTuple {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ExperienceTuple| { &m.name },
            |m: &mut ExperienceTuple| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "description",
            |m: &ExperienceTuple| { &m.description },
            |m: &mut ExperienceTuple| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "quantity",
            |m: &ExperienceTuple| { &m.quantity },
            |m: &mut ExperienceTuple| { &mut m.quantity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unit_price",
            |m: &ExperienceTuple| { &m.unit_price },
            |m: &mut ExperienceTuple| { &mut m.unit_price },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "amount",
            |m: &ExperienceTuple| { &m.amount },
            |m: &mut ExperienceTuple| { &mut m.amount },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ExperienceTuple>(
            "ExperienceTuple",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ExperienceTuple {
    const NAME: &'static str = "ExperienceTuple";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    self.name = is.read_string()?;
                },
                26 => {
                    self.description = is.read_string()?;
                },
                32 => {
                    self.quantity = is.read_int32()?;
                },
                40 => {
                    self.unit_price = is.read_int32()?;
                },
                48 => {
                    self.amount = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.description);
        }
        if self.quantity != 0 {
            my_size += ::protobuf::rt::int32_size(4, self.quantity);
        }
        if self.unit_price != 0 {
            my_size += ::protobuf::rt::int32_size(5, self.unit_price);
        }
        if self.amount != 0 {
            my_size += ::protobuf::rt::int32_size(6, self.amount);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.description.is_empty() {
            os.write_string(3, &self.description)?;
        }
        if self.quantity != 0 {
            os.write_int32(4, self.quantity)?;
        }
        if self.unit_price != 0 {
            os.write_int32(5, self.unit_price)?;
        }
        if self.amount != 0 {
            os.write_int32(6, self.amount)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ExperienceTuple {
        ExperienceTuple::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.description.clear();
        self.quantity = 0;
        self.unit_price = 0;
        self.amount = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ExperienceTuple {
        static instance: ExperienceTuple = ExperienceTuple {
            name: ::std::string::String::new(),
            description: ::std::string::String::new(),
            quantity: 0,
            unit_price: 0,
            amount: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ExperienceTuple {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ExperienceTuple").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ExperienceTuple {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExperienceTuple {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:finance.Finance)
pub struct Finance {
    // message fields
    // @@protoc_insertion_point(field:finance.Finance.id)
    pub id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:finance.Finance.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Finance {
    fn default() -> &'a Finance {
        <Finance as ::protobuf::Message>::default_instance()
    }
}

impl Finance {
    pub fn new() -> Finance {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Finance| { &m.id },
            |m: &mut Finance| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Finance>(
            "Finance",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Finance {
    const NAME: &'static str = "Finance";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Finance {
        Finance::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Finance {
        static instance: Finance = Finance {
            id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Finance {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Finance").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Finance {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Finance {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:finance.Payroll)
pub struct Payroll {
    // message fields
    // @@protoc_insertion_point(field:finance.Payroll.crew_id)
    pub crew_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:finance.Payroll.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Payroll {
    fn default() -> &'a Payroll {
        <Payroll as ::protobuf::Message>::default_instance()
    }
}

impl Payroll {
    pub fn new() -> Payroll {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "crew_id",
            |m: &Payroll| { &m.crew_id },
            |m: &mut Payroll| { &mut m.crew_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Payroll>(
            "Payroll",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Payroll {
    const NAME: &'static str = "Payroll";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.crew_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.crew_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.crew_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.crew_id.is_empty() {
            os.write_string(1, &self.crew_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Payroll {
        Payroll::new()
    }

    fn clear(&mut self) {
        self.crew_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Payroll {
        static instance: Payroll = Payroll {
            crew_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Payroll {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Payroll").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Payroll {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Payroll {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:finance.Payment)
pub struct Payment {
    // message fields
    // @@protoc_insertion_point(field:finance.Payment.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:finance.Payment.guest_id)
    pub guest_id: ::std::string::String,
    // @@protoc_insertion_point(field:finance.Payment.journey_id)
    pub journey_id: ::std::string::String,
    // @@protoc_insertion_point(field:finance.Payment.customer_id)
    pub customer_id: ::std::string::String,
    // @@protoc_insertion_point(field:finance.Payment.payment_id)
    pub payment_id: ::std::string::String,
    // @@protoc_insertion_point(field:finance.Payment.amount)
    pub amount: i64,
    // @@protoc_insertion_point(field:finance.Payment.amount_refunded)
    pub amount_refunded: i64,
    // @@protoc_insertion_point(field:finance.Payment.amount_captured)
    pub amount_captured: i64,
    // @@protoc_insertion_point(field:finance.Payment.auth_date)
    pub auth_date: i64,
    // @@protoc_insertion_point(field:finance.Payment.capture_date)
    pub capture_date: i64,
    // @@protoc_insertion_point(field:finance.Payment.refund_date)
    pub refund_date: i64,
    // @@protoc_insertion_point(field:finance.Payment.status)
    pub status: ::protobuf::EnumOrUnknown<PaymentStatus>,
    // @@protoc_insertion_point(field:finance.Payment.failure_code)
    pub failure_code: ::protobuf::EnumOrUnknown<PaymentFailureCode>,
    // @@protoc_insertion_point(field:finance.Payment.failure_message)
    pub failure_message: ::std::string::String,
    // @@protoc_insertion_point(field:finance.Payment.payment_intent)
    pub payment_intent: ::protobuf::MessageField<PaymentIntent>,
    // special fields
    // @@protoc_insertion_point(special_field:finance.Payment.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Payment {
    fn default() -> &'a Payment {
        <Payment as ::protobuf::Message>::default_instance()
    }
}

impl Payment {
    pub fn new() -> Payment {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(15);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Payment| { &m.id },
            |m: &mut Payment| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "guest_id",
            |m: &Payment| { &m.guest_id },
            |m: &mut Payment| { &mut m.guest_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "journey_id",
            |m: &Payment| { &m.journey_id },
            |m: &mut Payment| { &mut m.journey_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "customer_id",
            |m: &Payment| { &m.customer_id },
            |m: &mut Payment| { &mut m.customer_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "payment_id",
            |m: &Payment| { &m.payment_id },
            |m: &mut Payment| { &mut m.payment_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "amount",
            |m: &Payment| { &m.amount },
            |m: &mut Payment| { &mut m.amount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "amount_refunded",
            |m: &Payment| { &m.amount_refunded },
            |m: &mut Payment| { &mut m.amount_refunded },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "amount_captured",
            |m: &Payment| { &m.amount_captured },
            |m: &mut Payment| { &mut m.amount_captured },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "auth_date",
            |m: &Payment| { &m.auth_date },
            |m: &mut Payment| { &mut m.auth_date },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "capture_date",
            |m: &Payment| { &m.capture_date },
            |m: &mut Payment| { &mut m.capture_date },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "refund_date",
            |m: &Payment| { &m.refund_date },
            |m: &mut Payment| { &mut m.refund_date },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "status",
            |m: &Payment| { &m.status },
            |m: &mut Payment| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "failure_code",
            |m: &Payment| { &m.failure_code },
            |m: &mut Payment| { &mut m.failure_code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "failure_message",
            |m: &Payment| { &m.failure_message },
            |m: &mut Payment| { &mut m.failure_message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PaymentIntent>(
            "payment_intent",
            |m: &Payment| { &m.payment_intent },
            |m: &mut Payment| { &mut m.payment_intent },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Payment>(
            "Payment",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Payment {
    const NAME: &'static str = "Payment";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.guest_id = is.read_string()?;
                },
                26 => {
                    self.journey_id = is.read_string()?;
                },
                34 => {
                    self.customer_id = is.read_string()?;
                },
                42 => {
                    self.payment_id = is.read_string()?;
                },
                48 => {
                    self.amount = is.read_int64()?;
                },
                56 => {
                    self.amount_refunded = is.read_int64()?;
                },
                64 => {
                    self.amount_captured = is.read_int64()?;
                },
                72 => {
                    self.auth_date = is.read_int64()?;
                },
                80 => {
                    self.capture_date = is.read_int64()?;
                },
                88 => {
                    self.refund_date = is.read_int64()?;
                },
                96 => {
                    self.status = is.read_enum_or_unknown()?;
                },
                104 => {
                    self.failure_code = is.read_enum_or_unknown()?;
                },
                114 => {
                    self.failure_message = is.read_string()?;
                },
                122 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.payment_intent)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.guest_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.guest_id);
        }
        if !self.journey_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.journey_id);
        }
        if !self.customer_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.customer_id);
        }
        if !self.payment_id.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.payment_id);
        }
        if self.amount != 0 {
            my_size += ::protobuf::rt::int64_size(6, self.amount);
        }
        if self.amount_refunded != 0 {
            my_size += ::protobuf::rt::int64_size(7, self.amount_refunded);
        }
        if self.amount_captured != 0 {
            my_size += ::protobuf::rt::int64_size(8, self.amount_captured);
        }
        if self.auth_date != 0 {
            my_size += ::protobuf::rt::int64_size(9, self.auth_date);
        }
        if self.capture_date != 0 {
            my_size += ::protobuf::rt::int64_size(10, self.capture_date);
        }
        if self.refund_date != 0 {
            my_size += ::protobuf::rt::int64_size(11, self.refund_date);
        }
        if self.status != ::protobuf::EnumOrUnknown::new(PaymentStatus::PAYMENT_STATUS_UNSPECIFIED) {
            my_size += ::protobuf::rt::int32_size(12, self.status.value());
        }
        if self.failure_code != ::protobuf::EnumOrUnknown::new(PaymentFailureCode::PAYMENT_FAILURE_CODE_UNSPECIFIED) {
            my_size += ::protobuf::rt::int32_size(13, self.failure_code.value());
        }
        if !self.failure_message.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.failure_message);
        }
        if let Some(v) = self.payment_intent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.guest_id.is_empty() {
            os.write_string(2, &self.guest_id)?;
        }
        if !self.journey_id.is_empty() {
            os.write_string(3, &self.journey_id)?;
        }
        if !self.customer_id.is_empty() {
            os.write_string(4, &self.customer_id)?;
        }
        if !self.payment_id.is_empty() {
            os.write_string(5, &self.payment_id)?;
        }
        if self.amount != 0 {
            os.write_int64(6, self.amount)?;
        }
        if self.amount_refunded != 0 {
            os.write_int64(7, self.amount_refunded)?;
        }
        if self.amount_captured != 0 {
            os.write_int64(8, self.amount_captured)?;
        }
        if self.auth_date != 0 {
            os.write_int64(9, self.auth_date)?;
        }
        if self.capture_date != 0 {
            os.write_int64(10, self.capture_date)?;
        }
        if self.refund_date != 0 {
            os.write_int64(11, self.refund_date)?;
        }
        if self.status != ::protobuf::EnumOrUnknown::new(PaymentStatus::PAYMENT_STATUS_UNSPECIFIED) {
            os.write_enum(12, ::protobuf::EnumOrUnknown::value(&self.status))?;
        }
        if self.failure_code != ::protobuf::EnumOrUnknown::new(PaymentFailureCode::PAYMENT_FAILURE_CODE_UNSPECIFIED) {
            os.write_enum(13, ::protobuf::EnumOrUnknown::value(&self.failure_code))?;
        }
        if !self.failure_message.is_empty() {
            os.write_string(14, &self.failure_message)?;
        }
        if let Some(v) = self.payment_intent.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Payment {
        Payment::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.guest_id.clear();
        self.journey_id.clear();
        self.customer_id.clear();
        self.payment_id.clear();
        self.amount = 0;
        self.amount_refunded = 0;
        self.amount_captured = 0;
        self.auth_date = 0;
        self.capture_date = 0;
        self.refund_date = 0;
        self.status = ::protobuf::EnumOrUnknown::new(PaymentStatus::PAYMENT_STATUS_UNSPECIFIED);
        self.failure_code = ::protobuf::EnumOrUnknown::new(PaymentFailureCode::PAYMENT_FAILURE_CODE_UNSPECIFIED);
        self.failure_message.clear();
        self.payment_intent.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Payment {
        static instance: Payment = Payment {
            id: ::std::string::String::new(),
            guest_id: ::std::string::String::new(),
            journey_id: ::std::string::String::new(),
            customer_id: ::std::string::String::new(),
            payment_id: ::std::string::String::new(),
            amount: 0,
            amount_refunded: 0,
            amount_captured: 0,
            auth_date: 0,
            capture_date: 0,
            refund_date: 0,
            status: ::protobuf::EnumOrUnknown::from_i32(0),
            failure_code: ::protobuf::EnumOrUnknown::from_i32(0),
            failure_message: ::std::string::String::new(),
            payment_intent: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Payment {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Payment").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Payment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Payment {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:finance.PaymentIntent)
pub struct PaymentIntent {
    // message fields
    // @@protoc_insertion_point(field:finance.PaymentIntent.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:finance.PaymentIntent.amount)
    pub amount: i64,
    // @@protoc_insertion_point(field:finance.PaymentIntent.amount_capturable)
    pub amount_capturable: i64,
    // @@protoc_insertion_point(field:finance.PaymentIntent.status)
    pub status: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:finance.PaymentIntent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PaymentIntent {
    fn default() -> &'a PaymentIntent {
        <PaymentIntent as ::protobuf::Message>::default_instance()
    }
}

impl PaymentIntent {
    pub fn new() -> PaymentIntent {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &PaymentIntent| { &m.id },
            |m: &mut PaymentIntent| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "amount",
            |m: &PaymentIntent| { &m.amount },
            |m: &mut PaymentIntent| { &mut m.amount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "amount_capturable",
            |m: &PaymentIntent| { &m.amount_capturable },
            |m: &mut PaymentIntent| { &mut m.amount_capturable },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "status",
            |m: &PaymentIntent| { &m.status },
            |m: &mut PaymentIntent| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PaymentIntent>(
            "PaymentIntent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PaymentIntent {
    const NAME: &'static str = "PaymentIntent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                16 => {
                    self.amount = is.read_int64()?;
                },
                24 => {
                    self.amount_capturable = is.read_int64()?;
                },
                34 => {
                    self.status = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if self.amount != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.amount);
        }
        if self.amount_capturable != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.amount_capturable);
        }
        if !self.status.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.status);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if self.amount != 0 {
            os.write_int64(2, self.amount)?;
        }
        if self.amount_capturable != 0 {
            os.write_int64(3, self.amount_capturable)?;
        }
        if !self.status.is_empty() {
            os.write_string(4, &self.status)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PaymentIntent {
        PaymentIntent::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.amount = 0;
        self.amount_capturable = 0;
        self.status.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PaymentIntent {
        static instance: PaymentIntent = PaymentIntent {
            id: ::std::string::String::new(),
            amount: 0,
            amount_capturable: 0,
            status: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PaymentIntent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PaymentIntent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PaymentIntent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaymentIntent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:finance.PaymentMethod)
pub struct PaymentMethod {
    // message fields
    // @@protoc_insertion_point(field:finance.PaymentMethod.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:finance.PaymentMethod.guest_id)
    pub guest_id: ::std::string::String,
    // @@protoc_insertion_point(field:finance.PaymentMethod.customer_id)
    pub customer_id: ::std::string::String,
    // @@protoc_insertion_point(field:finance.PaymentMethod.vendor_id)
    pub vendor_id: ::std::string::String,
    // @@protoc_insertion_point(field:finance.PaymentMethod.last_four)
    pub last_four: ::std::string::String,
    // @@protoc_insertion_point(field:finance.PaymentMethod.brand)
    pub brand: ::std::string::String,
    // @@protoc_insertion_point(field:finance.PaymentMethod.country)
    pub country: ::std::string::String,
    // @@protoc_insertion_point(field:finance.PaymentMethod.exp_month)
    pub exp_month: i32,
    // @@protoc_insertion_point(field:finance.PaymentMethod.exp_year)
    pub exp_year: i32,
    // @@protoc_insertion_point(field:finance.PaymentMethod.type)
    pub type_: ::protobuf::EnumOrUnknown<PaymentMethodType>,
    // special fields
    // @@protoc_insertion_point(special_field:finance.PaymentMethod.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PaymentMethod {
    fn default() -> &'a PaymentMethod {
        <PaymentMethod as ::protobuf::Message>::default_instance()
    }
}

impl PaymentMethod {
    pub fn new() -> PaymentMethod {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &PaymentMethod| { &m.id },
            |m: &mut PaymentMethod| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "guest_id",
            |m: &PaymentMethod| { &m.guest_id },
            |m: &mut PaymentMethod| { &mut m.guest_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "customer_id",
            |m: &PaymentMethod| { &m.customer_id },
            |m: &mut PaymentMethod| { &mut m.customer_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "vendor_id",
            |m: &PaymentMethod| { &m.vendor_id },
            |m: &mut PaymentMethod| { &mut m.vendor_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "last_four",
            |m: &PaymentMethod| { &m.last_four },
            |m: &mut PaymentMethod| { &mut m.last_four },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "brand",
            |m: &PaymentMethod| { &m.brand },
            |m: &mut PaymentMethod| { &mut m.brand },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "country",
            |m: &PaymentMethod| { &m.country },
            |m: &mut PaymentMethod| { &mut m.country },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "exp_month",
            |m: &PaymentMethod| { &m.exp_month },
            |m: &mut PaymentMethod| { &mut m.exp_month },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "exp_year",
            |m: &PaymentMethod| { &m.exp_year },
            |m: &mut PaymentMethod| { &mut m.exp_year },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &PaymentMethod| { &m.type_ },
            |m: &mut PaymentMethod| { &mut m.type_ },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PaymentMethod>(
            "PaymentMethod",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PaymentMethod {
    const NAME: &'static str = "PaymentMethod";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.guest_id = is.read_string()?;
                },
                26 => {
                    self.customer_id = is.read_string()?;
                },
                34 => {
                    self.vendor_id = is.read_string()?;
                },
                42 => {
                    self.last_four = is.read_string()?;
                },
                50 => {
                    self.brand = is.read_string()?;
                },
                58 => {
                    self.country = is.read_string()?;
                },
                64 => {
                    self.exp_month = is.read_int32()?;
                },
                72 => {
                    self.exp_year = is.read_int32()?;
                },
                80 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.guest_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.guest_id);
        }
        if !self.customer_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.customer_id);
        }
        if !self.vendor_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.vendor_id);
        }
        if !self.last_four.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.last_four);
        }
        if !self.brand.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.brand);
        }
        if !self.country.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.country);
        }
        if self.exp_month != 0 {
            my_size += ::protobuf::rt::int32_size(8, self.exp_month);
        }
        if self.exp_year != 0 {
            my_size += ::protobuf::rt::int32_size(9, self.exp_year);
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(PaymentMethodType::PAYMENT_METHOD_TYPE_UNSPECIFIED) {
            my_size += ::protobuf::rt::int32_size(10, self.type_.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.guest_id.is_empty() {
            os.write_string(2, &self.guest_id)?;
        }
        if !self.customer_id.is_empty() {
            os.write_string(3, &self.customer_id)?;
        }
        if !self.vendor_id.is_empty() {
            os.write_string(4, &self.vendor_id)?;
        }
        if !self.last_four.is_empty() {
            os.write_string(5, &self.last_four)?;
        }
        if !self.brand.is_empty() {
            os.write_string(6, &self.brand)?;
        }
        if !self.country.is_empty() {
            os.write_string(7, &self.country)?;
        }
        if self.exp_month != 0 {
            os.write_int32(8, self.exp_month)?;
        }
        if self.exp_year != 0 {
            os.write_int32(9, self.exp_year)?;
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(PaymentMethodType::PAYMENT_METHOD_TYPE_UNSPECIFIED) {
            os.write_enum(10, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PaymentMethod {
        PaymentMethod::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.guest_id.clear();
        self.customer_id.clear();
        self.vendor_id.clear();
        self.last_four.clear();
        self.brand.clear();
        self.country.clear();
        self.exp_month = 0;
        self.exp_year = 0;
        self.type_ = ::protobuf::EnumOrUnknown::new(PaymentMethodType::PAYMENT_METHOD_TYPE_UNSPECIFIED);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PaymentMethod {
        static instance: PaymentMethod = PaymentMethod {
            id: ::std::string::String::new(),
            guest_id: ::std::string::String::new(),
            customer_id: ::std::string::String::new(),
            vendor_id: ::std::string::String::new(),
            last_four: ::std::string::String::new(),
            brand: ::std::string::String::new(),
            country: ::std::string::String::new(),
            exp_month: 0,
            exp_year: 0,
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PaymentMethod {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PaymentMethod").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PaymentMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaymentMethod {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  event source events
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:finance.PaymentAuthorized)
pub struct PaymentAuthorized {
    // message fields
    // @@protoc_insertion_point(field:finance.PaymentAuthorized.payment)
    pub payment: ::protobuf::MessageField<Payment>,
    // special fields
    // @@protoc_insertion_point(special_field:finance.PaymentAuthorized.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PaymentAuthorized {
    fn default() -> &'a PaymentAuthorized {
        <PaymentAuthorized as ::protobuf::Message>::default_instance()
    }
}

impl PaymentAuthorized {
    pub fn new() -> PaymentAuthorized {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Payment>(
            "payment",
            |m: &PaymentAuthorized| { &m.payment },
            |m: &mut PaymentAuthorized| { &mut m.payment },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PaymentAuthorized>(
            "PaymentAuthorized",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PaymentAuthorized {
    const NAME: &'static str = "PaymentAuthorized";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.payment)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payment.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payment.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PaymentAuthorized {
        PaymentAuthorized::new()
    }

    fn clear(&mut self) {
        self.payment.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PaymentAuthorized {
        static instance: PaymentAuthorized = PaymentAuthorized {
            payment: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PaymentAuthorized {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PaymentAuthorized").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PaymentAuthorized {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaymentAuthorized {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:finance.PaymentCaptured)
pub struct PaymentCaptured {
    // message fields
    // @@protoc_insertion_point(field:finance.PaymentCaptured.payment)
    pub payment: ::protobuf::MessageField<Payment>,
    // special fields
    // @@protoc_insertion_point(special_field:finance.PaymentCaptured.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PaymentCaptured {
    fn default() -> &'a PaymentCaptured {
        <PaymentCaptured as ::protobuf::Message>::default_instance()
    }
}

impl PaymentCaptured {
    pub fn new() -> PaymentCaptured {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Payment>(
            "payment",
            |m: &PaymentCaptured| { &m.payment },
            |m: &mut PaymentCaptured| { &mut m.payment },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PaymentCaptured>(
            "PaymentCaptured",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PaymentCaptured {
    const NAME: &'static str = "PaymentCaptured";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.payment)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payment.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payment.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PaymentCaptured {
        PaymentCaptured::new()
    }

    fn clear(&mut self) {
        self.payment.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PaymentCaptured {
        static instance: PaymentCaptured = PaymentCaptured {
            payment: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PaymentCaptured {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PaymentCaptured").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PaymentCaptured {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaymentCaptured {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:finance.PaymentRefunded)
pub struct PaymentRefunded {
    // message fields
    // @@protoc_insertion_point(field:finance.PaymentRefunded.payment)
    pub payment: ::protobuf::MessageField<Payment>,
    // special fields
    // @@protoc_insertion_point(special_field:finance.PaymentRefunded.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PaymentRefunded {
    fn default() -> &'a PaymentRefunded {
        <PaymentRefunded as ::protobuf::Message>::default_instance()
    }
}

impl PaymentRefunded {
    pub fn new() -> PaymentRefunded {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Payment>(
            "payment",
            |m: &PaymentRefunded| { &m.payment },
            |m: &mut PaymentRefunded| { &mut m.payment },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PaymentRefunded>(
            "PaymentRefunded",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PaymentRefunded {
    const NAME: &'static str = "PaymentRefunded";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.payment)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payment.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payment.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PaymentRefunded {
        PaymentRefunded::new()
    }

    fn clear(&mut self) {
        self.payment.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PaymentRefunded {
        static instance: PaymentRefunded = PaymentRefunded {
            payment: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PaymentRefunded {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PaymentRefunded").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PaymentRefunded {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaymentRefunded {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:finance.PaymentUpdated)
pub struct PaymentUpdated {
    // message fields
    // @@protoc_insertion_point(field:finance.PaymentUpdated.payment)
    pub payment: ::protobuf::MessageField<Payment>,
    // special fields
    // @@protoc_insertion_point(special_field:finance.PaymentUpdated.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PaymentUpdated {
    fn default() -> &'a PaymentUpdated {
        <PaymentUpdated as ::protobuf::Message>::default_instance()
    }
}

impl PaymentUpdated {
    pub fn new() -> PaymentUpdated {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Payment>(
            "payment",
            |m: &PaymentUpdated| { &m.payment },
            |m: &mut PaymentUpdated| { &mut m.payment },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PaymentUpdated>(
            "PaymentUpdated",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PaymentUpdated {
    const NAME: &'static str = "PaymentUpdated";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.payment)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payment.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payment.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PaymentUpdated {
        PaymentUpdated::new()
    }

    fn clear(&mut self) {
        self.payment.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PaymentUpdated {
        static instance: PaymentUpdated = PaymentUpdated {
            payment: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PaymentUpdated {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PaymentUpdated").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PaymentUpdated {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaymentUpdated {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:finance.PaymentMethodCreated)
pub struct PaymentMethodCreated {
    // message fields
    // @@protoc_insertion_point(field:finance.PaymentMethodCreated.payment_method)
    pub payment_method: ::protobuf::MessageField<PaymentMethod>,
    // special fields
    // @@protoc_insertion_point(special_field:finance.PaymentMethodCreated.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PaymentMethodCreated {
    fn default() -> &'a PaymentMethodCreated {
        <PaymentMethodCreated as ::protobuf::Message>::default_instance()
    }
}

impl PaymentMethodCreated {
    pub fn new() -> PaymentMethodCreated {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PaymentMethod>(
            "payment_method",
            |m: &PaymentMethodCreated| { &m.payment_method },
            |m: &mut PaymentMethodCreated| { &mut m.payment_method },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PaymentMethodCreated>(
            "PaymentMethodCreated",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PaymentMethodCreated {
    const NAME: &'static str = "PaymentMethodCreated";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.payment_method)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payment_method.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payment_method.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PaymentMethodCreated {
        PaymentMethodCreated::new()
    }

    fn clear(&mut self) {
        self.payment_method.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PaymentMethodCreated {
        static instance: PaymentMethodCreated = PaymentMethodCreated {
            payment_method: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PaymentMethodCreated {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PaymentMethodCreated").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PaymentMethodCreated {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaymentMethodCreated {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:finance.PaymentFailureCode)
pub enum PaymentFailureCode {
    // @@protoc_insertion_point(enum_value:finance.PaymentFailureCode.PAYMENT_FAILURE_CODE_UNSPECIFIED)
    PAYMENT_FAILURE_CODE_UNSPECIFIED = 0,
    // @@protoc_insertion_point(enum_value:finance.PaymentFailureCode.PAYMENT_FAILURE_CODE_NONE)
    PAYMENT_FAILURE_CODE_NONE = 1,
    // @@protoc_insertion_point(enum_value:finance.PaymentFailureCode.PAYMENT_FAILURE_CODE_OTHER)
    PAYMENT_FAILURE_CODE_OTHER = 2,
    // @@protoc_insertion_point(enum_value:finance.PaymentFailureCode.PAYMENT_FAILURE_CODE_CLOSED)
    PAYMENT_FAILURE_CODE_CLOSED = 3,
    // @@protoc_insertion_point(enum_value:finance.PaymentFailureCode.PAYMENT_FAILURE_CODE_ACCOUNT_INVALID)
    PAYMENT_FAILURE_CODE_ACCOUNT_INVALID = 4,
    // @@protoc_insertion_point(enum_value:finance.PaymentFailureCode.PAYMENT_FAILURE_CODE_ACCOUNT_NUMBER_INVALID)
    PAYMENT_FAILURE_CODE_ACCOUNT_NUMBER_INVALID = 5,
    // @@protoc_insertion_point(enum_value:finance.PaymentFailureCode.PAYMENT_FAILURE_CODE_ACCOUNT_COUNTRY_INVALID_ADDRESS)
    PAYMENT_FAILURE_CODE_ACCOUNT_COUNTRY_INVALID_ADDRESS = 6,
    // @@protoc_insertion_point(enum_value:finance.PaymentFailureCode.PAYMENT_FAILURE_CODE_ACCOUNT_INFORMATION_MISMATCH)
    PAYMENT_FAILURE_CODE_ACCOUNT_INFORMATION_MISMATCH = 7,
    // @@protoc_insertion_point(enum_value:finance.PaymentFailureCode.PAYMENT_FAILURE_CODE_AMOUNT_TOO_LARGE)
    PAYMENT_FAILURE_CODE_AMOUNT_TOO_LARGE = 8,
    // @@protoc_insertion_point(enum_value:finance.PaymentFailureCode.PAYMENT_FAILURE_CODE_CAPTURE_CHARGE_AUTHORIZATION_EXPIRE)
    PAYMENT_FAILURE_CODE_CAPTURE_CHARGE_AUTHORIZATION_EXPIRE = 9,
    // @@protoc_insertion_point(enum_value:finance.PaymentFailureCode.PAYMENT_FAILURE_CODE_CAPTURE_UNAUTHORIZED_PAYMENT)
    PAYMENT_FAILURE_CODE_CAPTURE_UNAUTHORIZED_PAYMENT = 10,
    // @@protoc_insertion_point(enum_value:finance.PaymentFailureCode.PAYMENT_FAILURE_CODE_CARD_DECLINED)
    PAYMENT_FAILURE_CODE_CARD_DECLINED = 11,
    // @@protoc_insertion_point(enum_value:finance.PaymentFailureCode.PAYMENT_FAILURE_CODE_CHARGE_ALREADY_CAPTURED)
    PAYMENT_FAILURE_CODE_CHARGE_ALREADY_CAPTURED = 12,
    // @@protoc_insertion_point(enum_value:finance.PaymentFailureCode.PAYMENT_FAILURE_CODE_CHARGE_ALREADY_REFUNDED)
    PAYMENT_FAILURE_CODE_CHARGE_ALREADY_REFUNDED = 13,
    // @@protoc_insertion_point(enum_value:finance.PaymentFailureCode.PAYMENT_FAILURE_CODE_CHARGE_DISPUTED)
    PAYMENT_FAILURE_CODE_CHARGE_DISPUTED = 14,
    // @@protoc_insertion_point(enum_value:finance.PaymentFailureCode.PAYMENT_FAILURE_CODE_CHARGE_EXPIRED_FOR_CAPTURE)
    PAYMENT_FAILURE_CODE_CHARGE_EXPIRED_FOR_CAPTURE = 15,
    // @@protoc_insertion_point(enum_value:finance.PaymentFailureCode.PAYMENT_FAILURE_CODE_CHARGE_NOT_REFUNDABLE)
    PAYMENT_FAILURE_CODE_CHARGE_NOT_REFUNDABLE = 16,
    // @@protoc_insertion_point(enum_value:finance.PaymentFailureCode.PAYMENT_FAILURE_CODE_COUNTRY_UNSUPPORTED)
    PAYMENT_FAILURE_CODE_COUNTRY_UNSUPPORTED = 17,
    // @@protoc_insertion_point(enum_value:finance.PaymentFailureCode.PAYMENT_FAILURE_CODE_DEBIT_NOT_AUTHORIZED)
    PAYMENT_FAILURE_CODE_DEBIT_NOT_AUTHORIZED = 18,
    // @@protoc_insertion_point(enum_value:finance.PaymentFailureCode.PAYMENT_FAILURE_CODE_EXPIRED_CARD)
    PAYMENT_FAILURE_CODE_EXPIRED_CARD = 19,
    // @@protoc_insertion_point(enum_value:finance.PaymentFailureCode.PAYMENT_FAILURE_CODE_INCORRECT_ADDRESS)
    PAYMENT_FAILURE_CODE_INCORRECT_ADDRESS = 20,
    // @@protoc_insertion_point(enum_value:finance.PaymentFailureCode.PAYMENT_FAILURE_CODE_INCORRECT_CVC)
    PAYMENT_FAILURE_CODE_INCORRECT_CVC = 21,
    // @@protoc_insertion_point(enum_value:finance.PaymentFailureCode.PAYMENT_FAILURE_CODE_INCORRECT_NUMBER)
    PAYMENT_FAILURE_CODE_INCORRECT_NUMBER = 22,
    // @@protoc_insertion_point(enum_value:finance.PaymentFailureCode.PAYMENT_FAILURE_CODE_INCORRECT_ZIP)
    PAYMENT_FAILURE_CODE_INCORRECT_ZIP = 23,
    // @@protoc_insertion_point(enum_value:finance.PaymentFailureCode.PAYMENT_FAILURE_CODE_INSUFFICIENT_FUNDS)
    PAYMENT_FAILURE_CODE_INSUFFICIENT_FUNDS = 24,
    // @@protoc_insertion_point(enum_value:finance.PaymentFailureCode.PAYMENT_FAILURE_CODE_INVALID_CVC)
    PAYMENT_FAILURE_CODE_INVALID_CVC = 25,
    // @@protoc_insertion_point(enum_value:finance.PaymentFailureCode.PAYMENT_FAILURE_CODE_INVALID_EXPIRY_MONTH)
    PAYMENT_FAILURE_CODE_INVALID_EXPIRY_MONTH = 26,
    // @@protoc_insertion_point(enum_value:finance.PaymentFailureCode.PAYMENT_FAILURE_CODE_INVALID_EXPIRY_YEAR)
    PAYMENT_FAILURE_CODE_INVALID_EXPIRY_YEAR = 27,
    // @@protoc_insertion_point(enum_value:finance.PaymentFailureCode.PAYMENT_FAILURE_CODE_INVALID_NUMBER)
    PAYMENT_FAILURE_CODE_INVALID_NUMBER = 28,
}

impl ::protobuf::Enum for PaymentFailureCode {
    const NAME: &'static str = "PaymentFailureCode";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PaymentFailureCode> {
        match value {
            0 => ::std::option::Option::Some(PaymentFailureCode::PAYMENT_FAILURE_CODE_UNSPECIFIED),
            1 => ::std::option::Option::Some(PaymentFailureCode::PAYMENT_FAILURE_CODE_NONE),
            2 => ::std::option::Option::Some(PaymentFailureCode::PAYMENT_FAILURE_CODE_OTHER),
            3 => ::std::option::Option::Some(PaymentFailureCode::PAYMENT_FAILURE_CODE_CLOSED),
            4 => ::std::option::Option::Some(PaymentFailureCode::PAYMENT_FAILURE_CODE_ACCOUNT_INVALID),
            5 => ::std::option::Option::Some(PaymentFailureCode::PAYMENT_FAILURE_CODE_ACCOUNT_NUMBER_INVALID),
            6 => ::std::option::Option::Some(PaymentFailureCode::PAYMENT_FAILURE_CODE_ACCOUNT_COUNTRY_INVALID_ADDRESS),
            7 => ::std::option::Option::Some(PaymentFailureCode::PAYMENT_FAILURE_CODE_ACCOUNT_INFORMATION_MISMATCH),
            8 => ::std::option::Option::Some(PaymentFailureCode::PAYMENT_FAILURE_CODE_AMOUNT_TOO_LARGE),
            9 => ::std::option::Option::Some(PaymentFailureCode::PAYMENT_FAILURE_CODE_CAPTURE_CHARGE_AUTHORIZATION_EXPIRE),
            10 => ::std::option::Option::Some(PaymentFailureCode::PAYMENT_FAILURE_CODE_CAPTURE_UNAUTHORIZED_PAYMENT),
            11 => ::std::option::Option::Some(PaymentFailureCode::PAYMENT_FAILURE_CODE_CARD_DECLINED),
            12 => ::std::option::Option::Some(PaymentFailureCode::PAYMENT_FAILURE_CODE_CHARGE_ALREADY_CAPTURED),
            13 => ::std::option::Option::Some(PaymentFailureCode::PAYMENT_FAILURE_CODE_CHARGE_ALREADY_REFUNDED),
            14 => ::std::option::Option::Some(PaymentFailureCode::PAYMENT_FAILURE_CODE_CHARGE_DISPUTED),
            15 => ::std::option::Option::Some(PaymentFailureCode::PAYMENT_FAILURE_CODE_CHARGE_EXPIRED_FOR_CAPTURE),
            16 => ::std::option::Option::Some(PaymentFailureCode::PAYMENT_FAILURE_CODE_CHARGE_NOT_REFUNDABLE),
            17 => ::std::option::Option::Some(PaymentFailureCode::PAYMENT_FAILURE_CODE_COUNTRY_UNSUPPORTED),
            18 => ::std::option::Option::Some(PaymentFailureCode::PAYMENT_FAILURE_CODE_DEBIT_NOT_AUTHORIZED),
            19 => ::std::option::Option::Some(PaymentFailureCode::PAYMENT_FAILURE_CODE_EXPIRED_CARD),
            20 => ::std::option::Option::Some(PaymentFailureCode::PAYMENT_FAILURE_CODE_INCORRECT_ADDRESS),
            21 => ::std::option::Option::Some(PaymentFailureCode::PAYMENT_FAILURE_CODE_INCORRECT_CVC),
            22 => ::std::option::Option::Some(PaymentFailureCode::PAYMENT_FAILURE_CODE_INCORRECT_NUMBER),
            23 => ::std::option::Option::Some(PaymentFailureCode::PAYMENT_FAILURE_CODE_INCORRECT_ZIP),
            24 => ::std::option::Option::Some(PaymentFailureCode::PAYMENT_FAILURE_CODE_INSUFFICIENT_FUNDS),
            25 => ::std::option::Option::Some(PaymentFailureCode::PAYMENT_FAILURE_CODE_INVALID_CVC),
            26 => ::std::option::Option::Some(PaymentFailureCode::PAYMENT_FAILURE_CODE_INVALID_EXPIRY_MONTH),
            27 => ::std::option::Option::Some(PaymentFailureCode::PAYMENT_FAILURE_CODE_INVALID_EXPIRY_YEAR),
            28 => ::std::option::Option::Some(PaymentFailureCode::PAYMENT_FAILURE_CODE_INVALID_NUMBER),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [PaymentFailureCode] = &[
        PaymentFailureCode::PAYMENT_FAILURE_CODE_UNSPECIFIED,
        PaymentFailureCode::PAYMENT_FAILURE_CODE_NONE,
        PaymentFailureCode::PAYMENT_FAILURE_CODE_OTHER,
        PaymentFailureCode::PAYMENT_FAILURE_CODE_CLOSED,
        PaymentFailureCode::PAYMENT_FAILURE_CODE_ACCOUNT_INVALID,
        PaymentFailureCode::PAYMENT_FAILURE_CODE_ACCOUNT_NUMBER_INVALID,
        PaymentFailureCode::PAYMENT_FAILURE_CODE_ACCOUNT_COUNTRY_INVALID_ADDRESS,
        PaymentFailureCode::PAYMENT_FAILURE_CODE_ACCOUNT_INFORMATION_MISMATCH,
        PaymentFailureCode::PAYMENT_FAILURE_CODE_AMOUNT_TOO_LARGE,
        PaymentFailureCode::PAYMENT_FAILURE_CODE_CAPTURE_CHARGE_AUTHORIZATION_EXPIRE,
        PaymentFailureCode::PAYMENT_FAILURE_CODE_CAPTURE_UNAUTHORIZED_PAYMENT,
        PaymentFailureCode::PAYMENT_FAILURE_CODE_CARD_DECLINED,
        PaymentFailureCode::PAYMENT_FAILURE_CODE_CHARGE_ALREADY_CAPTURED,
        PaymentFailureCode::PAYMENT_FAILURE_CODE_CHARGE_ALREADY_REFUNDED,
        PaymentFailureCode::PAYMENT_FAILURE_CODE_CHARGE_DISPUTED,
        PaymentFailureCode::PAYMENT_FAILURE_CODE_CHARGE_EXPIRED_FOR_CAPTURE,
        PaymentFailureCode::PAYMENT_FAILURE_CODE_CHARGE_NOT_REFUNDABLE,
        PaymentFailureCode::PAYMENT_FAILURE_CODE_COUNTRY_UNSUPPORTED,
        PaymentFailureCode::PAYMENT_FAILURE_CODE_DEBIT_NOT_AUTHORIZED,
        PaymentFailureCode::PAYMENT_FAILURE_CODE_EXPIRED_CARD,
        PaymentFailureCode::PAYMENT_FAILURE_CODE_INCORRECT_ADDRESS,
        PaymentFailureCode::PAYMENT_FAILURE_CODE_INCORRECT_CVC,
        PaymentFailureCode::PAYMENT_FAILURE_CODE_INCORRECT_NUMBER,
        PaymentFailureCode::PAYMENT_FAILURE_CODE_INCORRECT_ZIP,
        PaymentFailureCode::PAYMENT_FAILURE_CODE_INSUFFICIENT_FUNDS,
        PaymentFailureCode::PAYMENT_FAILURE_CODE_INVALID_CVC,
        PaymentFailureCode::PAYMENT_FAILURE_CODE_INVALID_EXPIRY_MONTH,
        PaymentFailureCode::PAYMENT_FAILURE_CODE_INVALID_EXPIRY_YEAR,
        PaymentFailureCode::PAYMENT_FAILURE_CODE_INVALID_NUMBER,
    ];
}

impl ::protobuf::EnumFull for PaymentFailureCode {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("PaymentFailureCode").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for PaymentFailureCode {
    fn default() -> Self {
        PaymentFailureCode::PAYMENT_FAILURE_CODE_UNSPECIFIED
    }
}

impl PaymentFailureCode {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<PaymentFailureCode>("PaymentFailureCode")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:finance.PaymentStatus)
pub enum PaymentStatus {
    // @@protoc_insertion_point(enum_value:finance.PaymentStatus.PAYMENT_STATUS_UNSPECIFIED)
    PAYMENT_STATUS_UNSPECIFIED = 0,
    // @@protoc_insertion_point(enum_value:finance.PaymentStatus.PAYMENT_STATUS_PENDING)
    PAYMENT_STATUS_PENDING = 1,
    // @@protoc_insertion_point(enum_value:finance.PaymentStatus.PAYMENT_STATUS_SUCCEEDED)
    PAYMENT_STATUS_SUCCEEDED = 2,
    // @@protoc_insertion_point(enum_value:finance.PaymentStatus.PAYMENT_STATUS_FAILED)
    PAYMENT_STATUS_FAILED = 3,
    // @@protoc_insertion_point(enum_value:finance.PaymentStatus.PAYMENT_STATUS_REFUNDED)
    PAYMENT_STATUS_REFUNDED = 4,
    // @@protoc_insertion_point(enum_value:finance.PaymentStatus.PAYMENT_STATUS_CANCELED)
    PAYMENT_STATUS_CANCELED = 5,
}

impl ::protobuf::Enum for PaymentStatus {
    const NAME: &'static str = "PaymentStatus";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PaymentStatus> {
        match value {
            0 => ::std::option::Option::Some(PaymentStatus::PAYMENT_STATUS_UNSPECIFIED),
            1 => ::std::option::Option::Some(PaymentStatus::PAYMENT_STATUS_PENDING),
            2 => ::std::option::Option::Some(PaymentStatus::PAYMENT_STATUS_SUCCEEDED),
            3 => ::std::option::Option::Some(PaymentStatus::PAYMENT_STATUS_FAILED),
            4 => ::std::option::Option::Some(PaymentStatus::PAYMENT_STATUS_REFUNDED),
            5 => ::std::option::Option::Some(PaymentStatus::PAYMENT_STATUS_CANCELED),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [PaymentStatus] = &[
        PaymentStatus::PAYMENT_STATUS_UNSPECIFIED,
        PaymentStatus::PAYMENT_STATUS_PENDING,
        PaymentStatus::PAYMENT_STATUS_SUCCEEDED,
        PaymentStatus::PAYMENT_STATUS_FAILED,
        PaymentStatus::PAYMENT_STATUS_REFUNDED,
        PaymentStatus::PAYMENT_STATUS_CANCELED,
    ];
}

impl ::protobuf::EnumFull for PaymentStatus {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("PaymentStatus").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for PaymentStatus {
    fn default() -> Self {
        PaymentStatus::PAYMENT_STATUS_UNSPECIFIED
    }
}

impl PaymentStatus {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<PaymentStatus>("PaymentStatus")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:finance.PaymentMethodType)
pub enum PaymentMethodType {
    // @@protoc_insertion_point(enum_value:finance.PaymentMethodType.PAYMENT_METHOD_TYPE_UNSPECIFIED)
    PAYMENT_METHOD_TYPE_UNSPECIFIED = 0,
    // @@protoc_insertion_point(enum_value:finance.PaymentMethodType.PAYMENT_METHOD_TYPE_CARD)
    PAYMENT_METHOD_TYPE_CARD = 1,
}

impl ::protobuf::Enum for PaymentMethodType {
    const NAME: &'static str = "PaymentMethodType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PaymentMethodType> {
        match value {
            0 => ::std::option::Option::Some(PaymentMethodType::PAYMENT_METHOD_TYPE_UNSPECIFIED),
            1 => ::std::option::Option::Some(PaymentMethodType::PAYMENT_METHOD_TYPE_CARD),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [PaymentMethodType] = &[
        PaymentMethodType::PAYMENT_METHOD_TYPE_UNSPECIFIED,
        PaymentMethodType::PAYMENT_METHOD_TYPE_CARD,
    ];
}

impl ::protobuf::EnumFull for PaymentMethodType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("PaymentMethodType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for PaymentMethodType {
    fn default() -> Self {
        PaymentMethodType::PAYMENT_METHOD_TYPE_UNSPECIFIED
    }
}

impl PaymentMethodType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<PaymentMethodType>("PaymentMethodType")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\rfinance.proto\x12\x07finance\x1a\x0cglobal.proto\"\n\n\x08Transfer\"\
    a\n\x07Invoice\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x14\n\x05to\
    tal\x18\x02\x20\x01(\x05R\x05total\x120\n\nline_items\x18\x03\x20\x03(\
    \x0b2\x11.finance.LineItemR\tlineItems\"c\n\tStatement\x12\x0e\n\x02id\
    \x18\x01\x20\x01(\tR\x02id\x12\x14\n\x05total\x18\x02\x20\x01(\x05R\x05t\
    otal\x120\n\nline_items\x18\x03\x20\x03(\x0b2\x11.finance.LineItemR\tlin\
    eItems\"^\n\x04Bill\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x14\n\
    \x05total\x18\x02\x20\x01(\x05R\x05total\x120\n\nline_items\x18\x03\x20\
    \x03(\x0b2\x11.finance.LineItemR\tlineItems\"e\n\x0bTransaction\x12\x0e\
    \n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x14\n\x05total\x18\x02\x20\x01(\
    \x05R\x05total\x120\n\nline_items\x18\x03\x20\x03(\x0b2\x11.finance.Line\
    ItemR\tlineItems\"\xf3\x03\n\x08LineItem\x12\x0e\n\x02id\x18\x01\x20\x01\
    (\tR\x02id\x12\x18\n\x07account\x18\x02\x20\x01(\tR\x07account\x12\x12\n\
    \x04code\x18\x03\x20\x01(\tR\x04code\x12\x1a\n\x08quantity\x18\x04\x20\
    \x01(\x05R\x08quantity\x12\x1d\n\nunit_price\x18\x05\x20\x01(\x05R\tunit\
    Price\x12\x12\n\x04name\x18\x06\x20\x01(\tR\x04name\x12\x20\n\x0bdescrip\
    tion\x18\x07\x20\x01(\tR\x0bdescription\x12\x16\n\x06amount\x18\x08\x20\
    \x01(\x05R\x06amount\x12,\n\x08currency\x18\t\x20\x01(\x0e2\x10.global.C\
    urrencyR\x08currency\x12)\n\titem_rate\x18\n\x20\x01(\x0b2\x0c.global.Ra\
    teR\x08itemRate\x12'\n\x08tax_rate\x18\x0b\x20\x01(\x0b2\x0c.global.Rate\
    R\x07taxRate\x12\x1c\n\treference\x18\x0c\x20\x01(\tR\treference\x12A\n\
    \nattributes\x18\r\x20\x03(\x0b2!.finance.LineItem.AttributesEntryR\natt\
    ributes\x1a=\n\x0fAttributesEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\
    \x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"\x9a\
    \x01\n\x0fExperienceTuple\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\
    \x12\x20\n\x0bdescription\x18\x03\x20\x01(\tR\x0bdescription\x12\x1a\n\
    \x08quantity\x18\x04\x20\x01(\x05R\x08quantity\x12\x1d\n\nunit_price\x18\
    \x05\x20\x01(\x05R\tunitPrice\x12\x16\n\x06amount\x18\x06\x20\x01(\x05R\
    \x06amount\"\x19\n\x07Finance\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\
    \"\"\n\x07Payroll\x12\x17\n\x07crew_id\x18\x01\x20\x01(\tR\x06crewId\"\
    \xb6\x04\n\x07Payment\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x19\
    \n\x08guest_id\x18\x02\x20\x01(\tR\x07guestId\x12\x1d\n\njourney_id\x18\
    \x03\x20\x01(\tR\tjourneyId\x12\x1f\n\x0bcustomer_id\x18\x04\x20\x01(\tR\
    \ncustomerId\x12\x1d\n\npayment_id\x18\x05\x20\x01(\tR\tpaymentId\x12\
    \x16\n\x06amount\x18\x06\x20\x01(\x03R\x06amount\x12'\n\x0famount_refund\
    ed\x18\x07\x20\x01(\x03R\x0eamountRefunded\x12'\n\x0famount_captured\x18\
    \x08\x20\x01(\x03R\x0eamountCaptured\x12\x1b\n\tauth_date\x18\t\x20\x01(\
    \x03R\x08authDate\x12!\n\x0ccapture_date\x18\n\x20\x01(\x03R\x0bcaptureD\
    ate\x12\x1f\n\x0brefund_date\x18\x0b\x20\x01(\x03R\nrefundDate\x12.\n\
    \x06status\x18\x0c\x20\x01(\x0e2\x16.finance.PaymentStatusR\x06status\
    \x12>\n\x0cfailure_code\x18\r\x20\x01(\x0e2\x1b.finance.PaymentFailureCo\
    deR\x0bfailureCode\x12'\n\x0ffailure_message\x18\x0e\x20\x01(\tR\x0efail\
    ureMessage\x12=\n\x0epayment_intent\x18\x0f\x20\x01(\x0b2\x16.finance.Pa\
    ymentIntentR\rpaymentIntent\"|\n\rPaymentIntent\x12\x0e\n\x02id\x18\x01\
    \x20\x01(\tR\x02id\x12\x16\n\x06amount\x18\x02\x20\x01(\x03R\x06amount\
    \x12+\n\x11amount_capturable\x18\x03\x20\x01(\x03R\x10amountCapturable\
    \x12\x16\n\x06status\x18\x04\x20\x01(\tR\x06status\"\xad\x02\n\rPaymentM\
    ethod\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x19\n\x08guest_id\
    \x18\x02\x20\x01(\tR\x07guestId\x12\x1f\n\x0bcustomer_id\x18\x03\x20\x01\
    (\tR\ncustomerId\x12\x1b\n\tvendor_id\x18\x04\x20\x01(\tR\x08vendorId\
    \x12\x1b\n\tlast_four\x18\x05\x20\x01(\tR\x08lastFour\x12\x14\n\x05brand\
    \x18\x06\x20\x01(\tR\x05brand\x12\x18\n\x07country\x18\x07\x20\x01(\tR\
    \x07country\x12\x1b\n\texp_month\x18\x08\x20\x01(\x05R\x08expMonth\x12\
    \x19\n\x08exp_year\x18\t\x20\x01(\x05R\x07expYear\x12.\n\x04type\x18\n\
    \x20\x01(\x0e2\x1a.finance.PaymentMethodTypeR\x04type\"?\n\x11PaymentAut\
    horized\x12*\n\x07payment\x18\x01\x20\x01(\x0b2\x10.finance.PaymentR\x07\
    payment\"=\n\x0fPaymentCaptured\x12*\n\x07payment\x18\x01\x20\x01(\x0b2\
    \x10.finance.PaymentR\x07payment\"=\n\x0fPaymentRefunded\x12*\n\x07payme\
    nt\x18\x01\x20\x01(\x0b2\x10.finance.PaymentR\x07payment\"<\n\x0ePayment\
    Updated\x12*\n\x07payment\x18\x01\x20\x01(\x0b2\x10.finance.PaymentR\x07\
    payment\"U\n\x14PaymentMethodCreated\x12=\n\x0epayment_method\x18\x01\
    \x20\x01(\x0b2\x16.finance.PaymentMethodR\rpaymentMethod*\xa5\n\n\x12Pay\
    mentFailureCode\x12$\n\x20PAYMENT_FAILURE_CODE_UNSPECIFIED\x10\0\x12\x1d\
    \n\x19PAYMENT_FAILURE_CODE_NONE\x10\x01\x12\x1e\n\x1aPAYMENT_FAILURE_COD\
    E_OTHER\x10\x02\x12\x1f\n\x1bPAYMENT_FAILURE_CODE_CLOSED\x10\x03\x12(\n$\
    PAYMENT_FAILURE_CODE_ACCOUNT_INVALID\x10\x04\x12/\n+PAYMENT_FAILURE_CODE\
    _ACCOUNT_NUMBER_INVALID\x10\x05\x128\n4PAYMENT_FAILURE_CODE_ACCOUNT_COUN\
    TRY_INVALID_ADDRESS\x10\x06\x125\n1PAYMENT_FAILURE_CODE_ACCOUNT_INFORMAT\
    ION_MISMATCH\x10\x07\x12)\n%PAYMENT_FAILURE_CODE_AMOUNT_TOO_LARGE\x10\
    \x08\x12<\n8PAYMENT_FAILURE_CODE_CAPTURE_CHARGE_AUTHORIZATION_EXPIRE\x10\
    \t\x125\n1PAYMENT_FAILURE_CODE_CAPTURE_UNAUTHORIZED_PAYMENT\x10\n\x12&\n\
    \"PAYMENT_FAILURE_CODE_CARD_DECLINED\x10\x0b\x120\n,PAYMENT_FAILURE_CODE\
    _CHARGE_ALREADY_CAPTURED\x10\x0c\x120\n,PAYMENT_FAILURE_CODE_CHARGE_ALRE\
    ADY_REFUNDED\x10\r\x12(\n$PAYMENT_FAILURE_CODE_CHARGE_DISPUTED\x10\x0e\
    \x123\n/PAYMENT_FAILURE_CODE_CHARGE_EXPIRED_FOR_CAPTURE\x10\x0f\x12.\n*P\
    AYMENT_FAILURE_CODE_CHARGE_NOT_REFUNDABLE\x10\x10\x12,\n(PAYMENT_FAILURE\
    _CODE_COUNTRY_UNSUPPORTED\x10\x11\x12-\n)PAYMENT_FAILURE_CODE_DEBIT_NOT_\
    AUTHORIZED\x10\x12\x12%\n!PAYMENT_FAILURE_CODE_EXPIRED_CARD\x10\x13\x12*\
    \n&PAYMENT_FAILURE_CODE_INCORRECT_ADDRESS\x10\x14\x12&\n\"PAYMENT_FAILUR\
    E_CODE_INCORRECT_CVC\x10\x15\x12)\n%PAYMENT_FAILURE_CODE_INCORRECT_NUMBE\
    R\x10\x16\x12&\n\"PAYMENT_FAILURE_CODE_INCORRECT_ZIP\x10\x17\x12+\n'PAYM\
    ENT_FAILURE_CODE_INSUFFICIENT_FUNDS\x10\x18\x12$\n\x20PAYMENT_FAILURE_CO\
    DE_INVALID_CVC\x10\x19\x12-\n)PAYMENT_FAILURE_CODE_INVALID_EXPIRY_MONTH\
    \x10\x1a\x12,\n(PAYMENT_FAILURE_CODE_INVALID_EXPIRY_YEAR\x10\x1b\x12'\n#\
    PAYMENT_FAILURE_CODE_INVALID_NUMBER\x10\x1c*\xbe\x01\n\rPaymentStatus\
    \x12\x1e\n\x1aPAYMENT_STATUS_UNSPECIFIED\x10\0\x12\x1a\n\x16PAYMENT_STAT\
    US_PENDING\x10\x01\x12\x1c\n\x18PAYMENT_STATUS_SUCCEEDED\x10\x02\x12\x19\
    \n\x15PAYMENT_STATUS_FAILED\x10\x03\x12\x1b\n\x17PAYMENT_STATUS_REFUNDED\
    \x10\x04\x12\x1b\n\x17PAYMENT_STATUS_CANCELED\x10\x05*V\n\x11PaymentMeth\
    odType\x12#\n\x1fPAYMENT_METHOD_TYPE_UNSPECIFIED\x10\0\x12\x1c\n\x18PAYM\
    ENT_METHOD_TYPE_CARD\x10\x01B/Z-github.com/tonychill/ifitu/apis/pb/go/fi\
    nanceJ\xcc0\n\x07\x12\x05\0\0\xaf\x01\x01\n\x08\n\x01\x0c\x12\x03\0\0\
    \x12\n\x08\n\x01\x02\x12\x03\x01\0\x10\n\t\n\x02\x03\0\x12\x03\x02\0\x16\
    \n\x08\n\x01\x08\x12\x03\x03\0D\n\t\n\x02\x08\x0b\x12\x03\x03\0D\n\n\n\
    \x02\x04\0\x12\x04\x06\0\x08\x01\n\n\n\x03\x04\0\x01\x12\x03\x06\x08\x10\
    \n\n\n\x02\x04\x01\x12\x04\t\0\r\x01\n\n\n\x03\x04\x01\x01\x12\x03\t\x08\
    \x0f\n\x0b\n\x04\x04\x01\x02\0\x12\x03\n\x02\x10\n\x0c\n\x05\x04\x01\x02\
    \0\x05\x12\x03\n\x02\x08\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03\n\t\x0b\n\
    \x0c\n\x05\x04\x01\x02\0\x03\x12\x03\n\x0e\x0f\n\x0b\n\x04\x04\x01\x02\
    \x01\x12\x03\x0b\x02\x12\n\x0c\n\x05\x04\x01\x02\x01\x05\x12\x03\x0b\x02\
    \x07\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\x03\x0b\x08\r\n\x0c\n\x05\x04\
    \x01\x02\x01\x03\x12\x03\x0b\x10\x11\n\x0b\n\x04\x04\x01\x02\x02\x12\x03\
    \x0c\x02#\n\x0c\n\x05\x04\x01\x02\x02\x04\x12\x03\x0c\x02\n\n\x0c\n\x05\
    \x04\x01\x02\x02\x06\x12\x03\x0c\x0b\x13\n\x0c\n\x05\x04\x01\x02\x02\x01\
    \x12\x03\x0c\x14\x1e\n\x0c\n\x05\x04\x01\x02\x02\x03\x12\x03\x0c!\"\n\n\
    \n\x02\x04\x02\x12\x04\x0f\0\x13\x01\n\n\n\x03\x04\x02\x01\x12\x03\x0f\
    \x08\x11\n\x0b\n\x04\x04\x02\x02\0\x12\x03\x10\x02\x10\n\x0c\n\x05\x04\
    \x02\x02\0\x05\x12\x03\x10\x02\x08\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03\
    \x10\t\x0b\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03\x10\x0e\x0f\n\x0b\n\x04\
    \x04\x02\x02\x01\x12\x03\x11\x02\x12\n\x0c\n\x05\x04\x02\x02\x01\x05\x12\
    \x03\x11\x02\x07\n\x0c\n\x05\x04\x02\x02\x01\x01\x12\x03\x11\x08\r\n\x0c\
    \n\x05\x04\x02\x02\x01\x03\x12\x03\x11\x10\x11\n\x0b\n\x04\x04\x02\x02\
    \x02\x12\x03\x12\x02#\n\x0c\n\x05\x04\x02\x02\x02\x04\x12\x03\x12\x02\n\
    \n\x0c\n\x05\x04\x02\x02\x02\x06\x12\x03\x12\x0b\x13\n\x0c\n\x05\x04\x02\
    \x02\x02\x01\x12\x03\x12\x14\x1e\n\x0c\n\x05\x04\x02\x02\x02\x03\x12\x03\
    \x12!\"\n\n\n\x02\x04\x03\x12\x04\x15\0\x19\x01\n\n\n\x03\x04\x03\x01\
    \x12\x03\x15\x08\x0c\n\x0b\n\x04\x04\x03\x02\0\x12\x03\x16\x02\x10\n\x0c\
    \n\x05\x04\x03\x02\0\x05\x12\x03\x16\x02\x08\n\x0c\n\x05\x04\x03\x02\0\
    \x01\x12\x03\x16\t\x0b\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x03\x16\x0e\x0f\
    \n\x0b\n\x04\x04\x03\x02\x01\x12\x03\x17\x02\x12\n\x0c\n\x05\x04\x03\x02\
    \x01\x05\x12\x03\x17\x02\x07\n\x0c\n\x05\x04\x03\x02\x01\x01\x12\x03\x17\
    \x08\r\n\x0c\n\x05\x04\x03\x02\x01\x03\x12\x03\x17\x10\x11\n\x0b\n\x04\
    \x04\x03\x02\x02\x12\x03\x18\x02#\n\x0c\n\x05\x04\x03\x02\x02\x04\x12\
    \x03\x18\x02\n\n\x0c\n\x05\x04\x03\x02\x02\x06\x12\x03\x18\x0b\x13\n\x0c\
    \n\x05\x04\x03\x02\x02\x01\x12\x03\x18\x14\x1e\n\x0c\n\x05\x04\x03\x02\
    \x02\x03\x12\x03\x18!\"\n\n\n\x02\x04\x04\x12\x04\x1b\0\x1f\x01\n\n\n\
    \x03\x04\x04\x01\x12\x03\x1b\x08\x13\n\x0b\n\x04\x04\x04\x02\0\x12\x03\
    \x1c\x02\x10\n\x0c\n\x05\x04\x04\x02\0\x05\x12\x03\x1c\x02\x08\n\x0c\n\
    \x05\x04\x04\x02\0\x01\x12\x03\x1c\t\x0b\n\x0c\n\x05\x04\x04\x02\0\x03\
    \x12\x03\x1c\x0e\x0f\n\x0b\n\x04\x04\x04\x02\x01\x12\x03\x1d\x02\x12\n\
    \x0c\n\x05\x04\x04\x02\x01\x05\x12\x03\x1d\x02\x07\n\x0c\n\x05\x04\x04\
    \x02\x01\x01\x12\x03\x1d\x08\r\n\x0c\n\x05\x04\x04\x02\x01\x03\x12\x03\
    \x1d\x10\x11\n\x0b\n\x04\x04\x04\x02\x02\x12\x03\x1e\x02#\n\x0c\n\x05\
    \x04\x04\x02\x02\x04\x12\x03\x1e\x02\n\n\x0c\n\x05\x04\x04\x02\x02\x06\
    \x12\x03\x1e\x0b\x13\n\x0c\n\x05\x04\x04\x02\x02\x01\x12\x03\x1e\x14\x1e\
    \n\x0c\n\x05\x04\x04\x02\x02\x03\x12\x03\x1e!\"\n\n\n\x02\x04\x05\x12\
    \x04!\03\x01\n\n\n\x03\x04\x05\x01\x12\x03!\x08\x10\n\x0b\n\x04\x04\x05\
    \x02\0\x12\x03\"\x02\x10\n\x0c\n\x05\x04\x05\x02\0\x05\x12\x03\"\x02\x08\
    \n\x0c\n\x05\x04\x05\x02\0\x01\x12\x03\"\t\x0b\n\x0c\n\x05\x04\x05\x02\0\
    \x03\x12\x03\"\x0e\x0f\n\x0b\n\x04\x04\x05\x02\x01\x12\x03#\x02\x15\n\
    \x0c\n\x05\x04\x05\x02\x01\x05\x12\x03#\x02\x08\n\x0c\n\x05\x04\x05\x02\
    \x01\x01\x12\x03#\t\x10\n\x0c\n\x05\x04\x05\x02\x01\x03\x12\x03#\x13\x14\
    \n\x0b\n\x04\x04\x05\x02\x02\x12\x03$\x02\x12\n\x0c\n\x05\x04\x05\x02\
    \x02\x05\x12\x03$\x02\x08\n\x0c\n\x05\x04\x05\x02\x02\x01\x12\x03$\t\r\n\
    \x0c\n\x05\x04\x05\x02\x02\x03\x12\x03$\x10\x11\n\x0b\n\x04\x04\x05\x02\
    \x03\x12\x03%\x02\x15\n\x0c\n\x05\x04\x05\x02\x03\x05\x12\x03%\x02\x07\n\
    \x0c\n\x05\x04\x05\x02\x03\x01\x12\x03%\x08\x10\n\x0c\n\x05\x04\x05\x02\
    \x03\x03\x12\x03%\x13\x14\n\x0b\n\x04\x04\x05\x02\x04\x12\x03&\x02\x17\n\
    \x0c\n\x05\x04\x05\x02\x04\x05\x12\x03&\x02\x07\n\x0c\n\x05\x04\x05\x02\
    \x04\x01\x12\x03&\x08\x12\n\x0c\n\x05\x04\x05\x02\x04\x03\x12\x03&\x15\
    \x16\n\x0b\n\x04\x04\x05\x02\x05\x12\x03'\x02\x12\n\x0c\n\x05\x04\x05\
    \x02\x05\x05\x12\x03'\x02\x08\n\x0c\n\x05\x04\x05\x02\x05\x01\x12\x03'\t\
    \r\n\x0c\n\x05\x04\x05\x02\x05\x03\x12\x03'\x10\x11\n\x0b\n\x04\x04\x05\
    \x02\x06\x12\x03(\x02\x19\n\x0c\n\x05\x04\x05\x02\x06\x05\x12\x03(\x02\
    \x08\n\x0c\n\x05\x04\x05\x02\x06\x01\x12\x03(\t\x14\n\x0c\n\x05\x04\x05\
    \x02\x06\x03\x12\x03(\x17\x18\n\x0b\n\x04\x04\x05\x02\x07\x12\x03)\x02\
    \x13\n\x0c\n\x05\x04\x05\x02\x07\x05\x12\x03)\x02\x07\n\x0c\n\x05\x04\
    \x05\x02\x07\x01\x12\x03)\x08\x0e\n\x0c\n\x05\x04\x05\x02\x07\x03\x12\
    \x03)\x11\x12\n\x0b\n\x04\x04\x05\x02\x08\x12\x03*\x02\x1f\n\x0c\n\x05\
    \x04\x05\x02\x08\x06\x12\x03*\x02\x11\n\x0c\n\x05\x04\x05\x02\x08\x01\
    \x12\x03*\x12\x1a\n\x0c\n\x05\x04\x05\x02\x08\x03\x12\x03*\x1d\x1e\n\x80\
    \x01\n\x04\x04\x05\x02\t\x12\x03-\x02\x1d\x1as\x20TODO:\x20maybe\x20this\
    \x20should\x20just\x20be\x20an\x20item\x20as\x20it\x20already\x20has\x20\
    a\x20type\x20of\x20tax\x20\n\x20or\x20should/could\x20it\x20be\x20a\x20l\
    ist\x20of\x20rates?\x20\n\n\x0c\n\x05\x04\x05\x02\t\x06\x12\x03-\x02\r\n\
    \x0c\n\x05\x04\x05\x02\t\x01\x12\x03-\x0e\x17\n\x0c\n\x05\x04\x05\x02\t\
    \x03\x12\x03-\x1a\x1c\n\x0b\n\x04\x04\x05\x02\n\x12\x03.\x02\x1c\n\x0c\n\
    \x05\x04\x05\x02\n\x06\x12\x03.\x02\r\n\x0c\n\x05\x04\x05\x02\n\x01\x12\
    \x03.\x0e\x16\n\x0c\n\x05\x04\x05\x02\n\x03\x12\x03.\x19\x1b\n+\n\x04\
    \x04\x05\x02\x0b\x12\x030\x02\x18\"\x1e\x20FIXME:\x20??\x20reference\x20\
    to\x20what?\n\n\x0c\n\x05\x04\x05\x02\x0b\x05\x12\x030\x02\x08\n\x0c\n\
    \x05\x04\x05\x02\x0b\x01\x12\x030\t\x12\n\x0c\n\x05\x04\x05\x02\x0b\x03\
    \x12\x030\x15\x17\n\x0b\n\x04\x04\x05\x02\x0c\x12\x031\x02&\n\x0c\n\x05\
    \x04\x05\x02\x0c\x06\x12\x031\x02\x15\n\x0c\n\x05\x04\x05\x02\x0c\x01\
    \x12\x031\x16\x20\n\x0c\n\x05\x04\x05\x02\x0c\x03\x12\x031#%\n\n\n\x02\
    \x04\x06\x12\x045\0<\x01\n\n\n\x03\x04\x06\x01\x12\x035\x08\x17\n\x0b\n\
    \x04\x04\x06\x02\0\x12\x036\x02\x12\n\x0c\n\x05\x04\x06\x02\0\x05\x12\
    \x036\x02\x08\n\x0c\n\x05\x04\x06\x02\0\x01\x12\x036\t\r\n\x0c\n\x05\x04\
    \x06\x02\0\x03\x12\x036\x10\x11\n\x0b\n\x04\x04\x06\x02\x01\x12\x037\x02\
    \x19\n\x0c\n\x05\x04\x06\x02\x01\x05\x12\x037\x02\x08\n\x0c\n\x05\x04\
    \x06\x02\x01\x01\x12\x037\t\x14\n\x0c\n\x05\x04\x06\x02\x01\x03\x12\x037\
    \x17\x18\n\x0b\n\x04\x04\x06\x02\x02\x12\x038\x02\x15\n\x0c\n\x05\x04\
    \x06\x02\x02\x05\x12\x038\x02\x07\n\x0c\n\x05\x04\x06\x02\x02\x01\x12\
    \x038\x08\x10\n\x0c\n\x05\x04\x06\x02\x02\x03\x12\x038\x13\x14\n\x0b\n\
    \x04\x04\x06\x02\x03\x12\x039\x02\x17\n\x0c\n\x05\x04\x06\x02\x03\x05\
    \x12\x039\x02\x07\n\x0c\n\x05\x04\x06\x02\x03\x01\x12\x039\x08\x12\n\x0c\
    \n\x05\x04\x06\x02\x03\x03\x12\x039\x15\x16\n\x0b\n\x04\x04\x06\x02\x04\
    \x12\x03:\x02\x13\n\x0c\n\x05\x04\x06\x02\x04\x05\x12\x03:\x02\x07\n\x0c\
    \n\x05\x04\x06\x02\x04\x01\x12\x03:\x08\x0e\n\x0c\n\x05\x04\x06\x02\x04\
    \x03\x12\x03:\x11\x12\n\n\n\x02\x04\x07\x12\x04>\0@\x01\n\n\n\x03\x04\
    \x07\x01\x12\x03>\x08\x0f\n\x0b\n\x04\x04\x07\x02\0\x12\x03?\x02\x10\n\
    \x0c\n\x05\x04\x07\x02\0\x05\x12\x03?\x02\x08\n\x0c\n\x05\x04\x07\x02\0\
    \x01\x12\x03?\t\x0b\n\x0c\n\x05\x04\x07\x02\0\x03\x12\x03?\x0e\x0f\n\n\n\
    \x02\x04\x08\x12\x04B\0D\x01\n\n\n\x03\x04\x08\x01\x12\x03B\x08\x0f\n\
    \x0b\n\x04\x04\x08\x02\0\x12\x03C\x02\x15\n\x0c\n\x05\x04\x08\x02\0\x05\
    \x12\x03C\x02\x08\n\x0c\n\x05\x04\x08\x02\0\x01\x12\x03C\t\x10\n\x0c\n\
    \x05\x04\x08\x02\0\x03\x12\x03C\x13\x14\n\n\n\x02\x04\t\x12\x04G\0W\x01\
    \n\n\n\x03\x04\t\x01\x12\x03G\x08\x0f\n\x0b\n\x04\x04\t\x02\0\x12\x03H\
    \x02\x10\n\x0c\n\x05\x04\t\x02\0\x05\x12\x03H\x02\x08\n\x0c\n\x05\x04\t\
    \x02\0\x01\x12\x03H\t\x0b\n\x0c\n\x05\x04\t\x02\0\x03\x12\x03H\x0e\x0f\n\
    \x0b\n\x04\x04\t\x02\x01\x12\x03I\x02\x16\n\x0c\n\x05\x04\t\x02\x01\x05\
    \x12\x03I\x02\x08\n\x0c\n\x05\x04\t\x02\x01\x01\x12\x03I\t\x11\n\x0c\n\
    \x05\x04\t\x02\x01\x03\x12\x03I\x14\x15\n\x0b\n\x04\x04\t\x02\x02\x12\
    \x03J\x02\x18\n\x0c\n\x05\x04\t\x02\x02\x05\x12\x03J\x02\x08\n\x0c\n\x05\
    \x04\t\x02\x02\x01\x12\x03J\t\x13\n\x0c\n\x05\x04\t\x02\x02\x03\x12\x03J\
    \x16\x17\n\x0b\n\x04\x04\t\x02\x03\x12\x03K\x02\x19\n\x0c\n\x05\x04\t\
    \x02\x03\x05\x12\x03K\x02\x08\n\x0c\n\x05\x04\t\x02\x03\x01\x12\x03K\t\
    \x14\n\x0c\n\x05\x04\t\x02\x03\x03\x12\x03K\x17\x18\n\x0b\n\x04\x04\t\
    \x02\x04\x12\x03L\x02\x18\n\x0c\n\x05\x04\t\x02\x04\x05\x12\x03L\x02\x08\
    \n\x0c\n\x05\x04\t\x02\x04\x01\x12\x03L\t\x13\n\x0c\n\x05\x04\t\x02\x04\
    \x03\x12\x03L\x16\x17\n\x0b\n\x04\x04\t\x02\x05\x12\x03M\x02\x14\n\x0c\n\
    \x05\x04\t\x02\x05\x05\x12\x03M\x02\x07\n\x0c\n\x05\x04\t\x02\x05\x01\
    \x12\x03M\t\x0f\n\x0c\n\x05\x04\t\x02\x05\x03\x12\x03M\x12\x13\n\x0b\n\
    \x04\x04\t\x02\x06\x12\x03N\x02\x1d\n\x0c\n\x05\x04\t\x02\x06\x05\x12\
    \x03N\x02\x07\n\x0c\n\x05\x04\t\x02\x06\x01\x12\x03N\t\x18\n\x0c\n\x05\
    \x04\t\x02\x06\x03\x12\x03N\x1b\x1c\n\x0b\n\x04\x04\t\x02\x07\x12\x03O\
    \x02\x1d\n\x0c\n\x05\x04\t\x02\x07\x05\x12\x03O\x02\x07\n\x0c\n\x05\x04\
    \t\x02\x07\x01\x12\x03O\t\x18\n\x0c\n\x05\x04\t\x02\x07\x03\x12\x03O\x1b\
    \x1c\n\x0b\n\x04\x04\t\x02\x08\x12\x03P\x02\x17\n\x0c\n\x05\x04\t\x02\
    \x08\x05\x12\x03P\x02\x07\n\x0c\n\x05\x04\t\x02\x08\x01\x12\x03P\t\x12\n\
    \x0c\n\x05\x04\t\x02\x08\x03\x12\x03P\x15\x16\n\x0b\n\x04\x04\t\x02\t\
    \x12\x03Q\x02\x1b\n\x0c\n\x05\x04\t\x02\t\x05\x12\x03Q\x02\x07\n\x0c\n\
    \x05\x04\t\x02\t\x01\x12\x03Q\t\x15\n\x0c\n\x05\x04\t\x02\t\x03\x12\x03Q\
    \x18\x1a\n\x0b\n\x04\x04\t\x02\n\x12\x03R\x02\x1a\n\x0c\n\x05\x04\t\x02\
    \n\x05\x12\x03R\x02\x07\n\x0c\n\x05\x04\t\x02\n\x01\x12\x03R\t\x14\n\x0c\
    \n\x05\x04\t\x02\n\x03\x12\x03R\x17\x19\n\x0b\n\x04\x04\t\x02\x0b\x12\
    \x03S\x02\x1c\n\x0c\n\x05\x04\t\x02\x0b\x06\x12\x03S\x02\x0f\n\x0c\n\x05\
    \x04\t\x02\x0b\x01\x12\x03S\x10\x16\n\x0c\n\x05\x04\t\x02\x0b\x03\x12\
    \x03S\x19\x1b\n\x0b\n\x04\x04\t\x02\x0c\x12\x03T\x02'\n\x0c\n\x05\x04\t\
    \x02\x0c\x06\x12\x03T\x02\x14\n\x0c\n\x05\x04\t\x02\x0c\x01\x12\x03T\x15\
    !\n\x0c\n\x05\x04\t\x02\x0c\x03\x12\x03T$&\n\x0b\n\x04\x04\t\x02\r\x12\
    \x03U\x02\x1e\n\x0c\n\x05\x04\t\x02\r\x05\x12\x03U\x02\x08\n\x0c\n\x05\
    \x04\t\x02\r\x01\x12\x03U\t\x18\n\x0c\n\x05\x04\t\x02\r\x03\x12\x03U\x1b\
    \x1d\n\x0b\n\x04\x04\t\x02\x0e\x12\x03V\x02$\n\x0c\n\x05\x04\t\x02\x0e\
    \x06\x12\x03V\x02\x0f\n\x0c\n\x05\x04\t\x02\x0e\x01\x12\x03V\x10\x1e\n\
    \x0c\n\x05\x04\t\x02\x0e\x03\x12\x03V!#\n1\n\x02\x05\0\x12\x04Y\0w\x01\"\
    %\x20https://stripe.com/docs/error-codes\n\n\n\n\x03\x05\0\x01\x12\x03Y\
    \x05\x17\n+\n\x04\x05\0\x02\0\x12\x03Z\x02'\"\x1e\x20default\x20value,\
    \x20so\x20no\x20failure\n\n\x0c\n\x05\x05\0\x02\0\x01\x12\x03Z\x02\"\n\
    \x0c\n\x05\x05\0\x02\0\x02\x12\x03Z%&\n+\n\x04\x05\0\x02\x01\x12\x03[\
    \x02\x20\"\x1e\x20default\x20value,\x20so\x20no\x20failure\n\n\x0c\n\x05\
    \x05\0\x02\x01\x01\x12\x03[\x02\x1b\n\x0c\n\x05\x05\0\x02\x01\x02\x12\
    \x03[\x1e\x1f\n0\n\x04\x05\0\x02\x02\x12\x03\\\x02!\"#\x20not\x20one\x20\
    of\x20the\x20items\x20listed\x20below\n\n\x0c\n\x05\x05\0\x02\x02\x01\
    \x12\x03\\\x02\x1c\n\x0c\n\x05\x05\0\x02\x02\x02\x12\x03\\\x1f\x20\n\x0b\
    \n\x04\x05\0\x02\x03\x12\x03]\x02\"\n\x0c\n\x05\x05\0\x02\x03\x01\x12\
    \x03]\x02\x1d\n\x0c\n\x05\x05\0\x02\x03\x02\x12\x03]\x20!\n\x0b\n\x04\
    \x05\0\x02\x04\x12\x03^\x02+\n\x0c\n\x05\x05\0\x02\x04\x01\x12\x03^\x02&\
    \n\x0c\n\x05\x05\0\x02\x04\x02\x12\x03^)*\n\x0b\n\x04\x05\0\x02\x05\x12\
    \x03_\x022\n\x0c\n\x05\x05\0\x02\x05\x01\x12\x03_\x02-\n\x0c\n\x05\x05\0\
    \x02\x05\x02\x12\x03_01\n\x0b\n\x04\x05\0\x02\x06\x12\x03`\x02;\n\x0c\n\
    \x05\x05\0\x02\x06\x01\x12\x03`\x026\n\x0c\n\x05\x05\0\x02\x06\x02\x12\
    \x03`9:\n\x0b\n\x04\x05\0\x02\x07\x12\x03a\x028\n\x0c\n\x05\x05\0\x02\
    \x07\x01\x12\x03a\x023\n\x0c\n\x05\x05\0\x02\x07\x02\x12\x03a67\n\x0b\n\
    \x04\x05\0\x02\x08\x12\x03b\x02,\n\x0c\n\x05\x05\0\x02\x08\x01\x12\x03b\
    \x02'\n\x0c\n\x05\x05\0\x02\x08\x02\x12\x03b*+\n\x0b\n\x04\x05\0\x02\t\
    \x12\x03c\x02?\n\x0c\n\x05\x05\0\x02\t\x01\x12\x03c\x02:\n\x0c\n\x05\x05\
    \0\x02\t\x02\x12\x03c=>\n\x0b\n\x04\x05\0\x02\n\x12\x03d\x029\n\x0c\n\
    \x05\x05\0\x02\n\x01\x12\x03d\x023\n\x0c\n\x05\x05\0\x02\n\x02\x12\x03d6\
    8\n\x0b\n\x04\x05\0\x02\x0b\x12\x03e\x02*\n\x0c\n\x05\x05\0\x02\x0b\x01\
    \x12\x03e\x02$\n\x0c\n\x05\x05\0\x02\x0b\x02\x12\x03e')\n\x0b\n\x04\x05\
    \0\x02\x0c\x12\x03f\x024\n\x0c\n\x05\x05\0\x02\x0c\x01\x12\x03f\x02.\n\
    \x0c\n\x05\x05\0\x02\x0c\x02\x12\x03f13\n\x0b\n\x04\x05\0\x02\r\x12\x03g\
    \x024\n\x0c\n\x05\x05\0\x02\r\x01\x12\x03g\x02.\n\x0c\n\x05\x05\0\x02\r\
    \x02\x12\x03g13\n\x0b\n\x04\x05\0\x02\x0e\x12\x03h\x02,\n\x0c\n\x05\x05\
    \0\x02\x0e\x01\x12\x03h\x02&\n\x0c\n\x05\x05\0\x02\x0e\x02\x12\x03h)+\n\
    \x0b\n\x04\x05\0\x02\x0f\x12\x03i\x027\n\x0c\n\x05\x05\0\x02\x0f\x01\x12\
    \x03i\x021\n\x0c\n\x05\x05\0\x02\x0f\x02\x12\x03i46\n\x0b\n\x04\x05\0\
    \x02\x10\x12\x03j\x022\n\x0c\n\x05\x05\0\x02\x10\x01\x12\x03j\x02,\n\x0c\
    \n\x05\x05\0\x02\x10\x02\x12\x03j/1\n\x0b\n\x04\x05\0\x02\x11\x12\x03k\
    \x020\n\x0c\n\x05\x05\0\x02\x11\x01\x12\x03k\x02*\n\x0c\n\x05\x05\0\x02\
    \x11\x02\x12\x03k-/\n\x0b\n\x04\x05\0\x02\x12\x12\x03l\x021\n\x0c\n\x05\
    \x05\0\x02\x12\x01\x12\x03l\x02+\n\x0c\n\x05\x05\0\x02\x12\x02\x12\x03l.\
    0\n\x0b\n\x04\x05\0\x02\x13\x12\x03m\x02)\n\x0c\n\x05\x05\0\x02\x13\x01\
    \x12\x03m\x02#\n\x0c\n\x05\x05\0\x02\x13\x02\x12\x03m&(\n\x0b\n\x04\x05\
    \0\x02\x14\x12\x03n\x02.\n\x0c\n\x05\x05\0\x02\x14\x01\x12\x03n\x02(\n\
    \x0c\n\x05\x05\0\x02\x14\x02\x12\x03n+-\n\x0b\n\x04\x05\0\x02\x15\x12\
    \x03o\x02*\n\x0c\n\x05\x05\0\x02\x15\x01\x12\x03o\x02$\n\x0c\n\x05\x05\0\
    \x02\x15\x02\x12\x03o')\n\x0b\n\x04\x05\0\x02\x16\x12\x03p\x02-\n\x0c\n\
    \x05\x05\0\x02\x16\x01\x12\x03p\x02'\n\x0c\n\x05\x05\0\x02\x16\x02\x12\
    \x03p*,\n\x0b\n\x04\x05\0\x02\x17\x12\x03q\x02*\n\x0c\n\x05\x05\0\x02\
    \x17\x01\x12\x03q\x02$\n\x0c\n\x05\x05\0\x02\x17\x02\x12\x03q')\n\x0b\n\
    \x04\x05\0\x02\x18\x12\x03r\x02/\n\x0c\n\x05\x05\0\x02\x18\x01\x12\x03r\
    \x02)\n\x0c\n\x05\x05\0\x02\x18\x02\x12\x03r,.\n\x0b\n\x04\x05\0\x02\x19\
    \x12\x03s\x02(\n\x0c\n\x05\x05\0\x02\x19\x01\x12\x03s\x02\"\n\x0c\n\x05\
    \x05\0\x02\x19\x02\x12\x03s%'\n\x0b\n\x04\x05\0\x02\x1a\x12\x03t\x021\n\
    \x0c\n\x05\x05\0\x02\x1a\x01\x12\x03t\x02+\n\x0c\n\x05\x05\0\x02\x1a\x02\
    \x12\x03t.0\n\x0b\n\x04\x05\0\x02\x1b\x12\x03u\x020\n\x0c\n\x05\x05\0\
    \x02\x1b\x01\x12\x03u\x02*\n\x0c\n\x05\x05\0\x02\x1b\x02\x12\x03u-/\n\
    \x0b\n\x04\x05\0\x02\x1c\x12\x03v\x02+\n\x0c\n\x05\x05\0\x02\x1c\x01\x12\
    \x03v\x02%\n\x0c\n\x05\x05\0\x02\x1c\x02\x12\x03v(*\n\x0b\n\x02\x05\x01\
    \x12\x05y\0\x80\x01\x01\n\n\n\x03\x05\x01\x01\x12\x03y\x05\x12\n\x0b\n\
    \x04\x05\x01\x02\0\x12\x03z\x02!\n\x0c\n\x05\x05\x01\x02\0\x01\x12\x03z\
    \x02\x1c\n\x0c\n\x05\x05\x01\x02\0\x02\x12\x03z\x1f\x20\n7\n\x04\x05\x01\
    \x02\x01\x12\x03{\x02\x1d\"*\x20has\x20been\x20authorized\x20and\x20awai\
    ting\x20capture\n\n\x0c\n\x05\x05\x01\x02\x01\x01\x12\x03{\x02\x18\n\x0c\
    \n\x05\x05\x01\x02\x01\x02\x12\x03{\x1b\x1c\n\x17\n\x04\x05\x01\x02\x02\
    \x12\x03|\x02\x1f\"\n\x20captured\n\n\x0c\n\x05\x05\x01\x02\x02\x01\x12\
    \x03|\x02\x1a\n\x0c\n\x05\x05\x01\x02\x02\x02\x12\x03|\x1d\x1e\n\x0b\n\
    \x04\x05\x01\x02\x03\x12\x03}\x02\x1c\n\x0c\n\x05\x05\x01\x02\x03\x01\
    \x12\x03}\x02\x17\n\x0c\n\x05\x05\x01\x02\x03\x02\x12\x03}\x1a\x1b\n\x0b\
    \n\x04\x05\x01\x02\x04\x12\x03~\x02\x1e\n\x0c\n\x05\x05\x01\x02\x04\x01\
    \x12\x03~\x02\x19\n\x0c\n\x05\x05\x01\x02\x04\x02\x12\x03~\x1c\x1d\n\x0b\
    \n\x04\x05\x01\x02\x05\x12\x03\x7f\x02\x1e\n\x0c\n\x05\x05\x01\x02\x05\
    \x01\x12\x03\x7f\x02\x19\n\x0c\n\x05\x05\x01\x02\x05\x02\x12\x03\x7f\x1c\
    \x1d\n\x0c\n\x02\x04\n\x12\x06\x82\x01\0\x87\x01\x01\n\x0b\n\x03\x04\n\
    \x01\x12\x04\x82\x01\x08\x15\n\x0c\n\x04\x04\n\x02\0\x12\x04\x83\x01\x02\
    \x10\n\r\n\x05\x04\n\x02\0\x05\x12\x04\x83\x01\x02\x08\n\r\n\x05\x04\n\
    \x02\0\x01\x12\x04\x83\x01\t\x0b\n\r\n\x05\x04\n\x02\0\x03\x12\x04\x83\
    \x01\x0e\x0f\n\x0c\n\x04\x04\n\x02\x01\x12\x04\x84\x01\x02\x14\n\r\n\x05\
    \x04\n\x02\x01\x05\x12\x04\x84\x01\x02\x07\n\r\n\x05\x04\n\x02\x01\x01\
    \x12\x04\x84\x01\t\x0f\n\r\n\x05\x04\n\x02\x01\x03\x12\x04\x84\x01\x12\
    \x13\n\x0c\n\x04\x04\n\x02\x02\x12\x04\x85\x01\x02\x1f\n\r\n\x05\x04\n\
    \x02\x02\x05\x12\x04\x85\x01\x02\x07\n\r\n\x05\x04\n\x02\x02\x01\x12\x04\
    \x85\x01\t\x1a\n\r\n\x05\x04\n\x02\x02\x03\x12\x04\x85\x01\x1d\x1e\n\x0c\
    \n\x04\x04\n\x02\x03\x12\x04\x86\x01\x02\x14\n\r\n\x05\x04\n\x02\x03\x05\
    \x12\x04\x86\x01\x02\x08\n\r\n\x05\x04\n\x02\x03\x01\x12\x04\x86\x01\t\
    \x0f\n\r\n\x05\x04\n\x02\x03\x03\x12\x04\x86\x01\x12\x13\n\x0c\n\x02\x04\
    \x0b\x12\x06\x89\x01\0\x95\x01\x01\n\x0b\n\x03\x04\x0b\x01\x12\x04\x89\
    \x01\x08\x15\n\x0c\n\x04\x04\x0b\x02\0\x12\x04\x8a\x01\x02\x10\n\r\n\x05\
    \x04\x0b\x02\0\x05\x12\x04\x8a\x01\x02\x08\n\r\n\x05\x04\x0b\x02\0\x01\
    \x12\x04\x8a\x01\t\x0b\n\r\n\x05\x04\x0b\x02\0\x03\x12\x04\x8a\x01\x0e\
    \x0f\n\x0c\n\x04\x04\x0b\x02\x01\x12\x04\x8b\x01\x02\x16\n\r\n\x05\x04\
    \x0b\x02\x01\x05\x12\x04\x8b\x01\x02\x08\n\r\n\x05\x04\x0b\x02\x01\x01\
    \x12\x04\x8b\x01\t\x11\n\r\n\x05\x04\x0b\x02\x01\x03\x12\x04\x8b\x01\x14\
    \x15\n\x0c\n\x04\x04\x0b\x02\x02\x12\x04\x8c\x01\x02\x19\n\r\n\x05\x04\
    \x0b\x02\x02\x05\x12\x04\x8c\x01\x02\x08\n\r\n\x05\x04\x0b\x02\x02\x01\
    \x12\x04\x8c\x01\t\x14\n\r\n\x05\x04\x0b\x02\x02\x03\x12\x04\x8c\x01\x17\
    \x18\n\x0c\n\x04\x04\x0b\x02\x03\x12\x04\x8d\x01\x02\x17\n\r\n\x05\x04\
    \x0b\x02\x03\x05\x12\x04\x8d\x01\x02\x08\n\r\n\x05\x04\x0b\x02\x03\x01\
    \x12\x04\x8d\x01\t\x12\n\r\n\x05\x04\x0b\x02\x03\x03\x12\x04\x8d\x01\x15\
    \x16\n\x0c\n\x04\x04\x0b\x02\x04\x12\x04\x8e\x01\x02\x17\n\r\n\x05\x04\
    \x0b\x02\x04\x05\x12\x04\x8e\x01\x02\x08\n\r\n\x05\x04\x0b\x02\x04\x01\
    \x12\x04\x8e\x01\t\x12\n\r\n\x05\x04\x0b\x02\x04\x03\x12\x04\x8e\x01\x15\
    \x16\n\x0c\n\x04\x04\x0b\x02\x05\x12\x04\x8f\x01\x02\x13\n\r\n\x05\x04\
    \x0b\x02\x05\x05\x12\x04\x8f\x01\x02\x08\n\r\n\x05\x04\x0b\x02\x05\x01\
    \x12\x04\x8f\x01\t\x0e\n\r\n\x05\x04\x0b\x02\x05\x03\x12\x04\x8f\x01\x11\
    \x12\n\x0c\n\x04\x04\x0b\x02\x06\x12\x04\x90\x01\x02\x15\n\r\n\x05\x04\
    \x0b\x02\x06\x05\x12\x04\x90\x01\x02\x08\n\r\n\x05\x04\x0b\x02\x06\x01\
    \x12\x04\x90\x01\t\x10\n\r\n\x05\x04\x0b\x02\x06\x03\x12\x04\x90\x01\x13\
    \x14\n\x0c\n\x04\x04\x0b\x02\x07\x12\x04\x91\x01\x02\x17\n\r\n\x05\x04\
    \x0b\x02\x07\x05\x12\x04\x91\x01\x02\x07\n\r\n\x05\x04\x0b\x02\x07\x01\
    \x12\x04\x91\x01\t\x12\n\r\n\x05\x04\x0b\x02\x07\x03\x12\x04\x91\x01\x15\
    \x16\n\x0c\n\x04\x04\x0b\x02\x08\x12\x04\x92\x01\x02\x16\n\r\n\x05\x04\
    \x0b\x02\x08\x05\x12\x04\x92\x01\x02\x07\n\r\n\x05\x04\x0b\x02\x08\x01\
    \x12\x04\x92\x01\t\x11\n\r\n\x05\x04\x0b\x02\x08\x03\x12\x04\x92\x01\x14\
    \x15\n\x0c\n\x04\x04\x0b\x02\t\x12\x04\x94\x01\x02\x20\n\r\n\x05\x04\x0b\
    \x02\t\x06\x12\x04\x94\x01\x02\x13\n\r\n\x05\x04\x0b\x02\t\x01\x12\x04\
    \x94\x01\x16\x1a\n\r\n\x05\x04\x0b\x02\t\x03\x12\x04\x94\x01\x1d\x1f\n\
    \x0c\n\x02\x05\x02\x12\x06\x97\x01\0\x9a\x01\x01\n\x0b\n\x03\x05\x02\x01\
    \x12\x04\x97\x01\x05\x16\n\x0c\n\x04\x05\x02\x02\0\x12\x04\x98\x01\x02&\
    \n\r\n\x05\x05\x02\x02\0\x01\x12\x04\x98\x01\x02!\n\r\n\x05\x05\x02\x02\
    \0\x02\x12\x04\x98\x01$%\n\x0c\n\x04\x05\x02\x02\x01\x12\x04\x99\x01\x02\
    \x1f\n\r\n\x05\x05\x02\x02\x01\x01\x12\x04\x99\x01\x02\x1a\n\r\n\x05\x05\
    \x02\x02\x01\x02\x12\x04\x99\x01\x1d\x1e\n#\n\x02\x04\x0c\x12\x06\x9d\
    \x01\0\x9f\x01\x01\x1a\x15\x20event\x20source\x20events\n\n\x0b\n\x03\
    \x04\x0c\x01\x12\x04\x9d\x01\x08\x19\n\x0c\n\x04\x04\x0c\x02\0\x12\x04\
    \x9e\x01\x02\x16\n\r\n\x05\x04\x0c\x02\0\x06\x12\x04\x9e\x01\x02\t\n\r\n\
    \x05\x04\x0c\x02\0\x01\x12\x04\x9e\x01\n\x11\n\r\n\x05\x04\x0c\x02\0\x03\
    \x12\x04\x9e\x01\x14\x15\n\x0c\n\x02\x04\r\x12\x06\xa1\x01\0\xa3\x01\x01\
    \n\x0b\n\x03\x04\r\x01\x12\x04\xa1\x01\x08\x17\n\x0c\n\x04\x04\r\x02\0\
    \x12\x04\xa2\x01\x02\x16\n\r\n\x05\x04\r\x02\0\x06\x12\x04\xa2\x01\x02\t\
    \n\r\n\x05\x04\r\x02\0\x01\x12\x04\xa2\x01\n\x11\n\r\n\x05\x04\r\x02\0\
    \x03\x12\x04\xa2\x01\x14\x15\n\x0c\n\x02\x04\x0e\x12\x06\xa5\x01\0\xa7\
    \x01\x01\n\x0b\n\x03\x04\x0e\x01\x12\x04\xa5\x01\x08\x17\n\x0c\n\x04\x04\
    \x0e\x02\0\x12\x04\xa6\x01\x02\x16\n\r\n\x05\x04\x0e\x02\0\x06\x12\x04\
    \xa6\x01\x02\t\n\r\n\x05\x04\x0e\x02\0\x01\x12\x04\xa6\x01\n\x11\n\r\n\
    \x05\x04\x0e\x02\0\x03\x12\x04\xa6\x01\x14\x15\n\x0c\n\x02\x04\x0f\x12\
    \x06\xa9\x01\0\xab\x01\x01\n\x0b\n\x03\x04\x0f\x01\x12\x04\xa9\x01\x08\
    \x16\n\x0c\n\x04\x04\x0f\x02\0\x12\x04\xaa\x01\x02\x16\n\r\n\x05\x04\x0f\
    \x02\0\x06\x12\x04\xaa\x01\x02\t\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\xaa\
    \x01\n\x11\n\r\n\x05\x04\x0f\x02\0\x03\x12\x04\xaa\x01\x14\x15\n\x0c\n\
    \x02\x04\x10\x12\x06\xad\x01\0\xaf\x01\x01\n\x0b\n\x03\x04\x10\x01\x12\
    \x04\xad\x01\x08\x1c\n\x0c\n\x04\x04\x10\x02\0\x12\x04\xae\x01\x02#\n\r\
    \n\x05\x04\x10\x02\0\x06\x12\x04\xae\x01\x02\x0f\n\r\n\x05\x04\x10\x02\0\
    \x01\x12\x04\xae\x01\x10\x1e\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\xae\x01\
    !\"b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::global::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(17);
            messages.push(Transfer::generated_message_descriptor_data());
            messages.push(Invoice::generated_message_descriptor_data());
            messages.push(Statement::generated_message_descriptor_data());
            messages.push(Bill::generated_message_descriptor_data());
            messages.push(Transaction::generated_message_descriptor_data());
            messages.push(LineItem::generated_message_descriptor_data());
            messages.push(ExperienceTuple::generated_message_descriptor_data());
            messages.push(Finance::generated_message_descriptor_data());
            messages.push(Payroll::generated_message_descriptor_data());
            messages.push(Payment::generated_message_descriptor_data());
            messages.push(PaymentIntent::generated_message_descriptor_data());
            messages.push(PaymentMethod::generated_message_descriptor_data());
            messages.push(PaymentAuthorized::generated_message_descriptor_data());
            messages.push(PaymentCaptured::generated_message_descriptor_data());
            messages.push(PaymentRefunded::generated_message_descriptor_data());
            messages.push(PaymentUpdated::generated_message_descriptor_data());
            messages.push(PaymentMethodCreated::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(3);
            enums.push(PaymentFailureCode::generated_enum_descriptor_data());
            enums.push(PaymentStatus::generated_enum_descriptor_data());
            enums.push(PaymentMethodType::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
