// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `global.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:global.Customer)
pub struct Customer {
    // message fields
    // @@protoc_insertion_point(field:global.Customer.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:global.Customer.user_name)
    pub user_name: ::std::string::String,
    // @@protoc_insertion_point(field:global.Customer.first_name)
    pub first_name: ::std::string::String,
    // @@protoc_insertion_point(field:global.Customer.last_name)
    pub last_name: ::std::string::String,
    // @@protoc_insertion_point(field:global.Customer.email)
    pub email: ::std::string::String,
    // @@protoc_insertion_point(field:global.Customer.phone)
    pub phone: ::std::string::String,
    // @@protoc_insertion_point(field:global.Customer.date_of_birth)
    pub date_of_birth: i64,
    // @@protoc_insertion_point(field:global.Customer.created_at)
    pub created_at: i64,
    // @@protoc_insertion_point(field:global.Customer.updated_at)
    pub updated_at: i64,
    // @@protoc_insertion_point(field:global.Customer.deleted_at)
    pub deleted_at: i64,
    // @@protoc_insertion_point(field:global.Customer.address)
    pub address: ::protobuf::MessageField<Address>,
    // @@protoc_insertion_point(field:global.Customer.profile_image_url)
    pub profile_image_url: ::std::string::String,
    ///  add alergies as top line item
    ///  repeated Preference preferences = 13;
    ///  Note above the persona property.
    ///  Persona persona = 14; // Part fo the truth engine
    ///  string gender = 15;
    // @@protoc_insertion_point(field:global.Customer.role_ids)
    pub role_ids: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:global.Customer.policy_ids)
    pub policy_ids: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:global.Customer.crew_ids)
    pub crew_ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:global.Customer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Customer {
    fn default() -> &'a Customer {
        <Customer as ::protobuf::Message>::default_instance()
    }
}

impl Customer {
    pub fn new() -> Customer {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(15);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Customer| { &m.id },
            |m: &mut Customer| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "user_name",
            |m: &Customer| { &m.user_name },
            |m: &mut Customer| { &mut m.user_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "first_name",
            |m: &Customer| { &m.first_name },
            |m: &mut Customer| { &mut m.first_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "last_name",
            |m: &Customer| { &m.last_name },
            |m: &mut Customer| { &mut m.last_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "email",
            |m: &Customer| { &m.email },
            |m: &mut Customer| { &mut m.email },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "phone",
            |m: &Customer| { &m.phone },
            |m: &mut Customer| { &mut m.phone },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "date_of_birth",
            |m: &Customer| { &m.date_of_birth },
            |m: &mut Customer| { &mut m.date_of_birth },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "created_at",
            |m: &Customer| { &m.created_at },
            |m: &mut Customer| { &mut m.created_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "updated_at",
            |m: &Customer| { &m.updated_at },
            |m: &mut Customer| { &mut m.updated_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "deleted_at",
            |m: &Customer| { &m.deleted_at },
            |m: &mut Customer| { &mut m.deleted_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Address>(
            "address",
            |m: &Customer| { &m.address },
            |m: &mut Customer| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "profile_image_url",
            |m: &Customer| { &m.profile_image_url },
            |m: &mut Customer| { &mut m.profile_image_url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "role_ids",
            |m: &Customer| { &m.role_ids },
            |m: &mut Customer| { &mut m.role_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "policy_ids",
            |m: &Customer| { &m.policy_ids },
            |m: &mut Customer| { &mut m.policy_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "crew_ids",
            |m: &Customer| { &m.crew_ids },
            |m: &mut Customer| { &mut m.crew_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Customer>(
            "Customer",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Customer {
    const NAME: &'static str = "Customer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.user_name = is.read_string()?;
                },
                26 => {
                    self.first_name = is.read_string()?;
                },
                34 => {
                    self.last_name = is.read_string()?;
                },
                42 => {
                    self.email = is.read_string()?;
                },
                50 => {
                    self.phone = is.read_string()?;
                },
                56 => {
                    self.date_of_birth = is.read_int64()?;
                },
                64 => {
                    self.created_at = is.read_int64()?;
                },
                72 => {
                    self.updated_at = is.read_int64()?;
                },
                80 => {
                    self.deleted_at = is.read_int64()?;
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.address)?;
                },
                98 => {
                    self.profile_image_url = is.read_string()?;
                },
                130 => {
                    self.role_ids.push(is.read_string()?);
                },
                138 => {
                    self.policy_ids.push(is.read_string()?);
                },
                146 => {
                    self.crew_ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.user_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.user_name);
        }
        if !self.first_name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.first_name);
        }
        if !self.last_name.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.last_name);
        }
        if !self.email.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.email);
        }
        if !self.phone.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.phone);
        }
        if self.date_of_birth != 0 {
            my_size += ::protobuf::rt::int64_size(7, self.date_of_birth);
        }
        if self.created_at != 0 {
            my_size += ::protobuf::rt::int64_size(8, self.created_at);
        }
        if self.updated_at != 0 {
            my_size += ::protobuf::rt::int64_size(9, self.updated_at);
        }
        if self.deleted_at != 0 {
            my_size += ::protobuf::rt::int64_size(10, self.deleted_at);
        }
        if let Some(v) = self.address.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.profile_image_url.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.profile_image_url);
        }
        for value in &self.role_ids {
            my_size += ::protobuf::rt::string_size(16, &value);
        };
        for value in &self.policy_ids {
            my_size += ::protobuf::rt::string_size(17, &value);
        };
        for value in &self.crew_ids {
            my_size += ::protobuf::rt::string_size(18, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.user_name.is_empty() {
            os.write_string(2, &self.user_name)?;
        }
        if !self.first_name.is_empty() {
            os.write_string(3, &self.first_name)?;
        }
        if !self.last_name.is_empty() {
            os.write_string(4, &self.last_name)?;
        }
        if !self.email.is_empty() {
            os.write_string(5, &self.email)?;
        }
        if !self.phone.is_empty() {
            os.write_string(6, &self.phone)?;
        }
        if self.date_of_birth != 0 {
            os.write_int64(7, self.date_of_birth)?;
        }
        if self.created_at != 0 {
            os.write_int64(8, self.created_at)?;
        }
        if self.updated_at != 0 {
            os.write_int64(9, self.updated_at)?;
        }
        if self.deleted_at != 0 {
            os.write_int64(10, self.deleted_at)?;
        }
        if let Some(v) = self.address.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if !self.profile_image_url.is_empty() {
            os.write_string(12, &self.profile_image_url)?;
        }
        for v in &self.role_ids {
            os.write_string(16, &v)?;
        };
        for v in &self.policy_ids {
            os.write_string(17, &v)?;
        };
        for v in &self.crew_ids {
            os.write_string(18, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Customer {
        Customer::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.user_name.clear();
        self.first_name.clear();
        self.last_name.clear();
        self.email.clear();
        self.phone.clear();
        self.date_of_birth = 0;
        self.created_at = 0;
        self.updated_at = 0;
        self.deleted_at = 0;
        self.address.clear();
        self.profile_image_url.clear();
        self.role_ids.clear();
        self.policy_ids.clear();
        self.crew_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Customer {
        static instance: Customer = Customer {
            id: ::std::string::String::new(),
            user_name: ::std::string::String::new(),
            first_name: ::std::string::String::new(),
            last_name: ::std::string::String::new(),
            email: ::std::string::String::new(),
            phone: ::std::string::String::new(),
            date_of_birth: 0,
            created_at: 0,
            updated_at: 0,
            deleted_at: 0,
            address: ::protobuf::MessageField::none(),
            profile_image_url: ::std::string::String::new(),
            role_ids: ::std::vec::Vec::new(),
            policy_ids: ::std::vec::Vec::new(),
            crew_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Customer {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Customer").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Customer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Customer {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:global.Experience)
pub struct Experience {
    // message fields
    // @@protoc_insertion_point(field:global.Experience.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:global.Experience.partner_id)
    pub partner_id: ::std::string::String,
    // @@protoc_insertion_point(field:global.Experience.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:global.Experience.description)
    pub description: ::std::string::String,
    // @@protoc_insertion_point(field:global.Experience.type)
    pub type_: ::protobuf::EnumOrUnknown<ExperienceType>,
    // @@protoc_insertion_point(field:global.Experience.media)
    pub media: ::std::vec::Vec<Content>,
    // @@protoc_insertion_point(field:global.Experience.start_date)
    pub start_date: i64,
    // @@protoc_insertion_point(field:global.Experience.end_date)
    pub end_date: i64,
    // @@protoc_insertion_point(field:global.Experience.tags)
    pub tags: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:global.Experience.rules)
    pub rules: ::std::vec::Vec<Rule>,
    // @@protoc_insertion_point(field:global.Experience.rates)
    pub rates: ::std::vec::Vec<Rate>,
    // @@protoc_insertion_point(field:global.Experience.features)
    pub features: ::std::vec::Vec<Feature>,
    // @@protoc_insertion_point(field:global.Experience.spaces)
    pub spaces: ::std::vec::Vec<Space>,
    // @@protoc_insertion_point(field:global.Experience.impressions)
    pub impressions: ::std::vec::Vec<Impression>,
    // @@protoc_insertion_point(field:global.Experience.comments)
    pub comments: ::std::vec::Vec<Comment>,
    // @@protoc_insertion_point(field:global.Experience.locations)
    pub locations: ::std::vec::Vec<Location>,
    // @@protoc_insertion_point(field:global.Experience.calendars)
    pub calendars: ::std::vec::Vec<Calendar>,
    // @@protoc_insertion_point(field:global.Experience.customers)
    pub customers: ::std::vec::Vec<Customer>,
    // special fields
    // @@protoc_insertion_point(special_field:global.Experience.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Experience {
    fn default() -> &'a Experience {
        <Experience as ::protobuf::Message>::default_instance()
    }
}

impl Experience {
    pub fn new() -> Experience {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(18);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Experience| { &m.id },
            |m: &mut Experience| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "partner_id",
            |m: &Experience| { &m.partner_id },
            |m: &mut Experience| { &mut m.partner_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &Experience| { &m.name },
            |m: &mut Experience| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "description",
            |m: &Experience| { &m.description },
            |m: &mut Experience| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &Experience| { &m.type_ },
            |m: &mut Experience| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "media",
            |m: &Experience| { &m.media },
            |m: &mut Experience| { &mut m.media },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "start_date",
            |m: &Experience| { &m.start_date },
            |m: &mut Experience| { &mut m.start_date },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "end_date",
            |m: &Experience| { &m.end_date },
            |m: &mut Experience| { &mut m.end_date },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tags",
            |m: &Experience| { &m.tags },
            |m: &mut Experience| { &mut m.tags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "rules",
            |m: &Experience| { &m.rules },
            |m: &mut Experience| { &mut m.rules },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "rates",
            |m: &Experience| { &m.rates },
            |m: &mut Experience| { &mut m.rates },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "features",
            |m: &Experience| { &m.features },
            |m: &mut Experience| { &mut m.features },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "spaces",
            |m: &Experience| { &m.spaces },
            |m: &mut Experience| { &mut m.spaces },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "impressions",
            |m: &Experience| { &m.impressions },
            |m: &mut Experience| { &mut m.impressions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "comments",
            |m: &Experience| { &m.comments },
            |m: &mut Experience| { &mut m.comments },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "locations",
            |m: &Experience| { &m.locations },
            |m: &mut Experience| { &mut m.locations },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "calendars",
            |m: &Experience| { &m.calendars },
            |m: &mut Experience| { &mut m.calendars },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "customers",
            |m: &Experience| { &m.customers },
            |m: &mut Experience| { &mut m.customers },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Experience>(
            "Experience",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Experience {
    const NAME: &'static str = "Experience";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.partner_id = is.read_string()?;
                },
                26 => {
                    self.name = is.read_string()?;
                },
                34 => {
                    self.description = is.read_string()?;
                },
                40 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                50 => {
                    self.media.push(is.read_message()?);
                },
                56 => {
                    self.start_date = is.read_int64()?;
                },
                64 => {
                    self.end_date = is.read_int64()?;
                },
                74 => {
                    self.tags.push(is.read_string()?);
                },
                82 => {
                    self.rules.push(is.read_message()?);
                },
                90 => {
                    self.rates.push(is.read_message()?);
                },
                98 => {
                    self.features.push(is.read_message()?);
                },
                106 => {
                    self.spaces.push(is.read_message()?);
                },
                114 => {
                    self.impressions.push(is.read_message()?);
                },
                122 => {
                    self.comments.push(is.read_message()?);
                },
                130 => {
                    self.locations.push(is.read_message()?);
                },
                138 => {
                    self.calendars.push(is.read_message()?);
                },
                146 => {
                    self.customers.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.partner_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.partner_id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.description);
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(ExperienceType::EXPERIENCE_TYPE_UNSPECIFIED) {
            my_size += ::protobuf::rt::int32_size(5, self.type_.value());
        }
        for value in &self.media {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.start_date != 0 {
            my_size += ::protobuf::rt::int64_size(7, self.start_date);
        }
        if self.end_date != 0 {
            my_size += ::protobuf::rt::int64_size(8, self.end_date);
        }
        for value in &self.tags {
            my_size += ::protobuf::rt::string_size(9, &value);
        };
        for value in &self.rules {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.rates {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.features {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.spaces {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.impressions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.comments {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.locations {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.calendars {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.customers {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.partner_id.is_empty() {
            os.write_string(2, &self.partner_id)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.description.is_empty() {
            os.write_string(4, &self.description)?;
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(ExperienceType::EXPERIENCE_TYPE_UNSPECIFIED) {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        for v in &self.media {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        if self.start_date != 0 {
            os.write_int64(7, self.start_date)?;
        }
        if self.end_date != 0 {
            os.write_int64(8, self.end_date)?;
        }
        for v in &self.tags {
            os.write_string(9, &v)?;
        };
        for v in &self.rules {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        };
        for v in &self.rates {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        };
        for v in &self.features {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        };
        for v in &self.spaces {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        };
        for v in &self.impressions {
            ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        };
        for v in &self.comments {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        };
        for v in &self.locations {
            ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
        };
        for v in &self.calendars {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        };
        for v in &self.customers {
            ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Experience {
        Experience::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.partner_id.clear();
        self.name.clear();
        self.description.clear();
        self.type_ = ::protobuf::EnumOrUnknown::new(ExperienceType::EXPERIENCE_TYPE_UNSPECIFIED);
        self.media.clear();
        self.start_date = 0;
        self.end_date = 0;
        self.tags.clear();
        self.rules.clear();
        self.rates.clear();
        self.features.clear();
        self.spaces.clear();
        self.impressions.clear();
        self.comments.clear();
        self.locations.clear();
        self.calendars.clear();
        self.customers.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Experience {
        static instance: Experience = Experience {
            id: ::std::string::String::new(),
            partner_id: ::std::string::String::new(),
            name: ::std::string::String::new(),
            description: ::std::string::String::new(),
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            media: ::std::vec::Vec::new(),
            start_date: 0,
            end_date: 0,
            tags: ::std::vec::Vec::new(),
            rules: ::std::vec::Vec::new(),
            rates: ::std::vec::Vec::new(),
            features: ::std::vec::Vec::new(),
            spaces: ::std::vec::Vec::new(),
            impressions: ::std::vec::Vec::new(),
            comments: ::std::vec::Vec::new(),
            locations: ::std::vec::Vec::new(),
            calendars: ::std::vec::Vec::new(),
            customers: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Experience {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Experience").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Experience {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Experience {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:global.Confirmation)
pub struct Confirmation {
    // message fields
    // @@protoc_insertion_point(field:global.Confirmation.experience_id)
    pub experience_id: ::std::string::String,
    // @@protoc_insertion_point(field:global.Confirmation.experience_total)
    pub experience_total: i64,
    // @@protoc_insertion_point(field:global.Confirmation.share_of_total)
    pub share_of_total: i64,
    // @@protoc_insertion_point(field:global.Confirmation.payment_method_id)
    pub payment_method_id: ::std::string::String,
    // @@protoc_insertion_point(field:global.Confirmation.status)
    pub status: ::protobuf::EnumOrUnknown<ConfirmationStatus>,
    // @@protoc_insertion_point(field:global.Confirmation.client_secret)
    pub client_secret: ::std::string::String,
    // @@protoc_insertion_point(field:global.Confirmation.currency)
    pub currency: ::protobuf::EnumOrUnknown<Currency>,
    // special fields
    // @@protoc_insertion_point(special_field:global.Confirmation.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Confirmation {
    fn default() -> &'a Confirmation {
        <Confirmation as ::protobuf::Message>::default_instance()
    }
}

impl Confirmation {
    pub fn new() -> Confirmation {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "experience_id",
            |m: &Confirmation| { &m.experience_id },
            |m: &mut Confirmation| { &mut m.experience_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "experience_total",
            |m: &Confirmation| { &m.experience_total },
            |m: &mut Confirmation| { &mut m.experience_total },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "share_of_total",
            |m: &Confirmation| { &m.share_of_total },
            |m: &mut Confirmation| { &mut m.share_of_total },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "payment_method_id",
            |m: &Confirmation| { &m.payment_method_id },
            |m: &mut Confirmation| { &mut m.payment_method_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "status",
            |m: &Confirmation| { &m.status },
            |m: &mut Confirmation| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "client_secret",
            |m: &Confirmation| { &m.client_secret },
            |m: &mut Confirmation| { &mut m.client_secret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "currency",
            |m: &Confirmation| { &m.currency },
            |m: &mut Confirmation| { &mut m.currency },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Confirmation>(
            "Confirmation",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Confirmation {
    const NAME: &'static str = "Confirmation";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.experience_id = is.read_string()?;
                },
                16 => {
                    self.experience_total = is.read_int64()?;
                },
                24 => {
                    self.share_of_total = is.read_int64()?;
                },
                34 => {
                    self.payment_method_id = is.read_string()?;
                },
                40 => {
                    self.status = is.read_enum_or_unknown()?;
                },
                50 => {
                    self.client_secret = is.read_string()?;
                },
                56 => {
                    self.currency = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.experience_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.experience_id);
        }
        if self.experience_total != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.experience_total);
        }
        if self.share_of_total != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.share_of_total);
        }
        if !self.payment_method_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.payment_method_id);
        }
        if self.status != ::protobuf::EnumOrUnknown::new(ConfirmationStatus::CONFIRMATION_STATUS_UNSPECIFIED) {
            my_size += ::protobuf::rt::int32_size(5, self.status.value());
        }
        if !self.client_secret.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.client_secret);
        }
        if self.currency != ::protobuf::EnumOrUnknown::new(Currency::CURRENCY_UNSPECIFIED) {
            my_size += ::protobuf::rt::int32_size(7, self.currency.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.experience_id.is_empty() {
            os.write_string(1, &self.experience_id)?;
        }
        if self.experience_total != 0 {
            os.write_int64(2, self.experience_total)?;
        }
        if self.share_of_total != 0 {
            os.write_int64(3, self.share_of_total)?;
        }
        if !self.payment_method_id.is_empty() {
            os.write_string(4, &self.payment_method_id)?;
        }
        if self.status != ::protobuf::EnumOrUnknown::new(ConfirmationStatus::CONFIRMATION_STATUS_UNSPECIFIED) {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&self.status))?;
        }
        if !self.client_secret.is_empty() {
            os.write_string(6, &self.client_secret)?;
        }
        if self.currency != ::protobuf::EnumOrUnknown::new(Currency::CURRENCY_UNSPECIFIED) {
            os.write_enum(7, ::protobuf::EnumOrUnknown::value(&self.currency))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Confirmation {
        Confirmation::new()
    }

    fn clear(&mut self) {
        self.experience_id.clear();
        self.experience_total = 0;
        self.share_of_total = 0;
        self.payment_method_id.clear();
        self.status = ::protobuf::EnumOrUnknown::new(ConfirmationStatus::CONFIRMATION_STATUS_UNSPECIFIED);
        self.client_secret.clear();
        self.currency = ::protobuf::EnumOrUnknown::new(Currency::CURRENCY_UNSPECIFIED);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Confirmation {
        static instance: Confirmation = Confirmation {
            experience_id: ::std::string::String::new(),
            experience_total: 0,
            share_of_total: 0,
            payment_method_id: ::std::string::String::new(),
            status: ::protobuf::EnumOrUnknown::from_i32(0),
            client_secret: ::std::string::String::new(),
            currency: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Confirmation {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Confirmation").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Confirmation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Confirmation {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:global.Comment)
pub struct Comment {
    // message fields
    // @@protoc_insertion_point(field:global.Comment.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:global.Comment.owner_id)
    pub owner_id: ::std::string::String,
    // @@protoc_insertion_point(field:global.Comment.partner_id)
    pub partner_id: ::std::string::String,
    // @@protoc_insertion_point(field:global.Comment.entity_id)
    pub entity_id: ::std::string::String,
    // @@protoc_insertion_point(field:global.Comment.entity_type)
    pub entity_type: ::std::string::String,
    // @@protoc_insertion_point(field:global.Comment.body)
    pub body: ::std::string::String,
    // @@protoc_insertion_point(field:global.Comment.created_at)
    pub created_at: ::std::string::String,
    // @@protoc_insertion_point(field:global.Comment.updated_at)
    pub updated_at: ::std::string::String,
    // @@protoc_insertion_point(field:global.Comment.deleted_at)
    pub deleted_at: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:global.Comment.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Comment {
    fn default() -> &'a Comment {
        <Comment as ::protobuf::Message>::default_instance()
    }
}

impl Comment {
    pub fn new() -> Comment {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Comment| { &m.id },
            |m: &mut Comment| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "owner_id",
            |m: &Comment| { &m.owner_id },
            |m: &mut Comment| { &mut m.owner_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "partner_id",
            |m: &Comment| { &m.partner_id },
            |m: &mut Comment| { &mut m.partner_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "entity_id",
            |m: &Comment| { &m.entity_id },
            |m: &mut Comment| { &mut m.entity_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "entity_type",
            |m: &Comment| { &m.entity_type },
            |m: &mut Comment| { &mut m.entity_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "body",
            |m: &Comment| { &m.body },
            |m: &mut Comment| { &mut m.body },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "created_at",
            |m: &Comment| { &m.created_at },
            |m: &mut Comment| { &mut m.created_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "updated_at",
            |m: &Comment| { &m.updated_at },
            |m: &mut Comment| { &mut m.updated_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "deleted_at",
            |m: &Comment| { &m.deleted_at },
            |m: &mut Comment| { &mut m.deleted_at },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Comment>(
            "Comment",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Comment {
    const NAME: &'static str = "Comment";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.owner_id = is.read_string()?;
                },
                26 => {
                    self.partner_id = is.read_string()?;
                },
                34 => {
                    self.entity_id = is.read_string()?;
                },
                42 => {
                    self.entity_type = is.read_string()?;
                },
                50 => {
                    self.body = is.read_string()?;
                },
                58 => {
                    self.created_at = is.read_string()?;
                },
                66 => {
                    self.updated_at = is.read_string()?;
                },
                74 => {
                    self.deleted_at = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.owner_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.owner_id);
        }
        if !self.partner_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.partner_id);
        }
        if !self.entity_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.entity_id);
        }
        if !self.entity_type.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.entity_type);
        }
        if !self.body.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.body);
        }
        if !self.created_at.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.created_at);
        }
        if !self.updated_at.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.updated_at);
        }
        if !self.deleted_at.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.deleted_at);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.owner_id.is_empty() {
            os.write_string(2, &self.owner_id)?;
        }
        if !self.partner_id.is_empty() {
            os.write_string(3, &self.partner_id)?;
        }
        if !self.entity_id.is_empty() {
            os.write_string(4, &self.entity_id)?;
        }
        if !self.entity_type.is_empty() {
            os.write_string(5, &self.entity_type)?;
        }
        if !self.body.is_empty() {
            os.write_string(6, &self.body)?;
        }
        if !self.created_at.is_empty() {
            os.write_string(7, &self.created_at)?;
        }
        if !self.updated_at.is_empty() {
            os.write_string(8, &self.updated_at)?;
        }
        if !self.deleted_at.is_empty() {
            os.write_string(9, &self.deleted_at)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Comment {
        Comment::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.owner_id.clear();
        self.partner_id.clear();
        self.entity_id.clear();
        self.entity_type.clear();
        self.body.clear();
        self.created_at.clear();
        self.updated_at.clear();
        self.deleted_at.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Comment {
        static instance: Comment = Comment {
            id: ::std::string::String::new(),
            owner_id: ::std::string::String::new(),
            partner_id: ::std::string::String::new(),
            entity_id: ::std::string::String::new(),
            entity_type: ::std::string::String::new(),
            body: ::std::string::String::new(),
            created_at: ::std::string::String::new(),
            updated_at: ::std::string::String::new(),
            deleted_at: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Comment {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Comment").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Comment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Comment {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:global.Feature)
pub struct Feature {
    // message fields
    // @@protoc_insertion_point(field:global.Feature.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:global.Feature.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:global.Feature.description)
    pub description: ::std::string::String,
    // @@protoc_insertion_point(field:global.Feature.type)
    pub type_: ::std::string::String,
    // @@protoc_insertion_point(field:global.Feature.created_at)
    pub created_at: ::std::string::String,
    // @@protoc_insertion_point(field:global.Feature.updated_at)
    pub updated_at: ::std::string::String,
    // @@protoc_insertion_point(field:global.Feature.deleted_at)
    pub deleted_at: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:global.Feature.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Feature {
    fn default() -> &'a Feature {
        <Feature as ::protobuf::Message>::default_instance()
    }
}

impl Feature {
    pub fn new() -> Feature {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Feature| { &m.id },
            |m: &mut Feature| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &Feature| { &m.name },
            |m: &mut Feature| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "description",
            |m: &Feature| { &m.description },
            |m: &mut Feature| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &Feature| { &m.type_ },
            |m: &mut Feature| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "created_at",
            |m: &Feature| { &m.created_at },
            |m: &mut Feature| { &mut m.created_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "updated_at",
            |m: &Feature| { &m.updated_at },
            |m: &mut Feature| { &mut m.updated_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "deleted_at",
            |m: &Feature| { &m.deleted_at },
            |m: &mut Feature| { &mut m.deleted_at },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Feature>(
            "Feature",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Feature {
    const NAME: &'static str = "Feature";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                26 => {
                    self.description = is.read_string()?;
                },
                34 => {
                    self.type_ = is.read_string()?;
                },
                42 => {
                    self.created_at = is.read_string()?;
                },
                50 => {
                    self.updated_at = is.read_string()?;
                },
                58 => {
                    self.deleted_at = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.description);
        }
        if !self.type_.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.type_);
        }
        if !self.created_at.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.created_at);
        }
        if !self.updated_at.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.updated_at);
        }
        if !self.deleted_at.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.deleted_at);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.description.is_empty() {
            os.write_string(3, &self.description)?;
        }
        if !self.type_.is_empty() {
            os.write_string(4, &self.type_)?;
        }
        if !self.created_at.is_empty() {
            os.write_string(5, &self.created_at)?;
        }
        if !self.updated_at.is_empty() {
            os.write_string(6, &self.updated_at)?;
        }
        if !self.deleted_at.is_empty() {
            os.write_string(7, &self.deleted_at)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Feature {
        Feature::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.name.clear();
        self.description.clear();
        self.type_.clear();
        self.created_at.clear();
        self.updated_at.clear();
        self.deleted_at.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Feature {
        static instance: Feature = Feature {
            id: ::std::string::String::new(),
            name: ::std::string::String::new(),
            description: ::std::string::String::new(),
            type_: ::std::string::String::new(),
            created_at: ::std::string::String::new(),
            updated_at: ::std::string::String::new(),
            deleted_at: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Feature {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Feature").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Feature {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Feature {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:global.Rate)
pub struct Rate {
    // message fields
    // @@protoc_insertion_point(field:global.Rate.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:global.Rate.partner_id)
    pub partner_id: ::std::string::String,
    // @@protoc_insertion_point(field:global.Rate.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:global.Rate.description)
    pub description: ::std::string::String,
    // @@protoc_insertion_point(field:global.Rate.experiences)
    pub experiences: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:global.Rate.rate_type)
    pub rate_type: ::protobuf::EnumOrUnknown<RateType>,
    // @@protoc_insertion_point(field:global.Rate.start_date)
    pub start_date: i64,
    // @@protoc_insertion_point(field:global.Rate.end_date)
    pub end_date: i64,
    // @@protoc_insertion_point(field:global.Rate.amount)
    pub amount: i64,
    // @@protoc_insertion_point(field:global.Rate.currency)
    pub currency: ::protobuf::EnumOrUnknown<Currency>,
    ///  TODO: add number of guests, number of hours, etc.
    // @@protoc_insertion_point(field:global.Rate.frequency)
    pub frequency: ::protobuf::EnumOrUnknown<RateFrequency>,
    // @@protoc_insertion_point(field:global.Rate.metadata)
    pub metadata: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // @@protoc_insertion_point(field:global.Rate.created_at)
    pub created_at: i64,
    // @@protoc_insertion_point(field:global.Rate.updated_at)
    pub updated_at: i64,
    // special fields
    // @@protoc_insertion_point(special_field:global.Rate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Rate {
    fn default() -> &'a Rate {
        <Rate as ::protobuf::Message>::default_instance()
    }
}

impl Rate {
    pub fn new() -> Rate {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(14);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Rate| { &m.id },
            |m: &mut Rate| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "partner_id",
            |m: &Rate| { &m.partner_id },
            |m: &mut Rate| { &mut m.partner_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &Rate| { &m.name },
            |m: &mut Rate| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "description",
            |m: &Rate| { &m.description },
            |m: &mut Rate| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "experiences",
            |m: &Rate| { &m.experiences },
            |m: &mut Rate| { &mut m.experiences },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "rate_type",
            |m: &Rate| { &m.rate_type },
            |m: &mut Rate| { &mut m.rate_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "start_date",
            |m: &Rate| { &m.start_date },
            |m: &mut Rate| { &mut m.start_date },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "end_date",
            |m: &Rate| { &m.end_date },
            |m: &mut Rate| { &mut m.end_date },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "amount",
            |m: &Rate| { &m.amount },
            |m: &mut Rate| { &mut m.amount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "currency",
            |m: &Rate| { &m.currency },
            |m: &mut Rate| { &mut m.currency },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "frequency",
            |m: &Rate| { &m.frequency },
            |m: &mut Rate| { &mut m.frequency },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "metadata",
            |m: &Rate| { &m.metadata },
            |m: &mut Rate| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "created_at",
            |m: &Rate| { &m.created_at },
            |m: &mut Rate| { &mut m.created_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "updated_at",
            |m: &Rate| { &m.updated_at },
            |m: &mut Rate| { &mut m.updated_at },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Rate>(
            "Rate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Rate {
    const NAME: &'static str = "Rate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.partner_id = is.read_string()?;
                },
                26 => {
                    self.name = is.read_string()?;
                },
                34 => {
                    self.description = is.read_string()?;
                },
                42 => {
                    self.experiences.push(is.read_string()?);
                },
                48 => {
                    self.rate_type = is.read_enum_or_unknown()?;
                },
                56 => {
                    self.start_date = is.read_int64()?;
                },
                64 => {
                    self.end_date = is.read_int64()?;
                },
                72 => {
                    self.amount = is.read_int64()?;
                },
                80 => {
                    self.currency = is.read_enum_or_unknown()?;
                },
                88 => {
                    self.frequency = is.read_enum_or_unknown()?;
                },
                98 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.metadata.insert(key, value);
                },
                104 => {
                    self.created_at = is.read_int64()?;
                },
                112 => {
                    self.updated_at = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.partner_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.partner_id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.description);
        }
        for value in &self.experiences {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        if self.rate_type != ::protobuf::EnumOrUnknown::new(RateType::RATE_TYPE_UNSPECIFIED) {
            my_size += ::protobuf::rt::int32_size(6, self.rate_type.value());
        }
        if self.start_date != 0 {
            my_size += ::protobuf::rt::int64_size(7, self.start_date);
        }
        if self.end_date != 0 {
            my_size += ::protobuf::rt::int64_size(8, self.end_date);
        }
        if self.amount != 0 {
            my_size += ::protobuf::rt::int64_size(9, self.amount);
        }
        if self.currency != ::protobuf::EnumOrUnknown::new(Currency::CURRENCY_UNSPECIFIED) {
            my_size += ::protobuf::rt::int32_size(10, self.currency.value());
        }
        if self.frequency != ::protobuf::EnumOrUnknown::new(RateFrequency::RATE_FREQUENCY_UNSPECIFIED) {
            my_size += ::protobuf::rt::int32_size(11, self.frequency.value());
        }
        for (k, v) in &self.metadata {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if self.created_at != 0 {
            my_size += ::protobuf::rt::int64_size(13, self.created_at);
        }
        if self.updated_at != 0 {
            my_size += ::protobuf::rt::int64_size(14, self.updated_at);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.partner_id.is_empty() {
            os.write_string(2, &self.partner_id)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.description.is_empty() {
            os.write_string(4, &self.description)?;
        }
        for v in &self.experiences {
            os.write_string(5, &v)?;
        };
        if self.rate_type != ::protobuf::EnumOrUnknown::new(RateType::RATE_TYPE_UNSPECIFIED) {
            os.write_enum(6, ::protobuf::EnumOrUnknown::value(&self.rate_type))?;
        }
        if self.start_date != 0 {
            os.write_int64(7, self.start_date)?;
        }
        if self.end_date != 0 {
            os.write_int64(8, self.end_date)?;
        }
        if self.amount != 0 {
            os.write_int64(9, self.amount)?;
        }
        if self.currency != ::protobuf::EnumOrUnknown::new(Currency::CURRENCY_UNSPECIFIED) {
            os.write_enum(10, ::protobuf::EnumOrUnknown::value(&self.currency))?;
        }
        if self.frequency != ::protobuf::EnumOrUnknown::new(RateFrequency::RATE_FREQUENCY_UNSPECIFIED) {
            os.write_enum(11, ::protobuf::EnumOrUnknown::value(&self.frequency))?;
        }
        for (k, v) in &self.metadata {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(98)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        if self.created_at != 0 {
            os.write_int64(13, self.created_at)?;
        }
        if self.updated_at != 0 {
            os.write_int64(14, self.updated_at)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Rate {
        Rate::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.partner_id.clear();
        self.name.clear();
        self.description.clear();
        self.experiences.clear();
        self.rate_type = ::protobuf::EnumOrUnknown::new(RateType::RATE_TYPE_UNSPECIFIED);
        self.start_date = 0;
        self.end_date = 0;
        self.amount = 0;
        self.currency = ::protobuf::EnumOrUnknown::new(Currency::CURRENCY_UNSPECIFIED);
        self.frequency = ::protobuf::EnumOrUnknown::new(RateFrequency::RATE_FREQUENCY_UNSPECIFIED);
        self.metadata.clear();
        self.created_at = 0;
        self.updated_at = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Rate {
        static instance: ::protobuf::rt::Lazy<Rate> = ::protobuf::rt::Lazy::new();
        instance.get(Rate::new)
    }
}

impl ::protobuf::MessageFull for Rate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Rate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Rate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Rate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:global.TaxRate)
pub struct TaxRate {
    // message fields
    // @@protoc_insertion_point(field:global.TaxRate.id)
    pub id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:global.TaxRate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TaxRate {
    fn default() -> &'a TaxRate {
        <TaxRate as ::protobuf::Message>::default_instance()
    }
}

impl TaxRate {
    pub fn new() -> TaxRate {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &TaxRate| { &m.id },
            |m: &mut TaxRate| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TaxRate>(
            "TaxRate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TaxRate {
    const NAME: &'static str = "TaxRate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TaxRate {
        TaxRate::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TaxRate {
        static instance: TaxRate = TaxRate {
            id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TaxRate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TaxRate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TaxRate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TaxRate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:global.TelematicUpdate)
pub struct TelematicUpdate {
    // message fields
    // @@protoc_insertion_point(field:global.TelematicUpdate.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:global.TelematicUpdate.type)
    pub type_: ::std::string::String,
    // @@protoc_insertion_point(field:global.TelematicUpdate.description)
    pub description: ::std::string::String,
    // @@protoc_insertion_point(field:global.TelematicUpdate.timestamp)
    pub timestamp: i64,
    // @@protoc_insertion_point(field:global.TelematicUpdate.location)
    pub location: ::protobuf::MessageField<Location>,
    // @@protoc_insertion_point(field:global.TelematicUpdate.prev_update_id)
    pub prev_update_id: ::std::string::String,
    // @@protoc_insertion_point(field:global.TelematicUpdate.next_update_id)
    pub next_update_id: ::std::string::String,
    // @@protoc_insertion_point(field:global.TelematicUpdate.metadata)
    pub metadata: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:global.TelematicUpdate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TelematicUpdate {
    fn default() -> &'a TelematicUpdate {
        <TelematicUpdate as ::protobuf::Message>::default_instance()
    }
}

impl TelematicUpdate {
    pub fn new() -> TelematicUpdate {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &TelematicUpdate| { &m.id },
            |m: &mut TelematicUpdate| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &TelematicUpdate| { &m.type_ },
            |m: &mut TelematicUpdate| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "description",
            |m: &TelematicUpdate| { &m.description },
            |m: &mut TelematicUpdate| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "timestamp",
            |m: &TelematicUpdate| { &m.timestamp },
            |m: &mut TelematicUpdate| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Location>(
            "location",
            |m: &TelematicUpdate| { &m.location },
            |m: &mut TelematicUpdate| { &mut m.location },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "prev_update_id",
            |m: &TelematicUpdate| { &m.prev_update_id },
            |m: &mut TelematicUpdate| { &mut m.prev_update_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "next_update_id",
            |m: &TelematicUpdate| { &m.next_update_id },
            |m: &mut TelematicUpdate| { &mut m.next_update_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "metadata",
            |m: &TelematicUpdate| { &m.metadata },
            |m: &mut TelematicUpdate| { &mut m.metadata },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TelematicUpdate>(
            "TelematicUpdate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TelematicUpdate {
    const NAME: &'static str = "TelematicUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.type_ = is.read_string()?;
                },
                26 => {
                    self.description = is.read_string()?;
                },
                32 => {
                    self.timestamp = is.read_int64()?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.location)?;
                },
                50 => {
                    self.prev_update_id = is.read_string()?;
                },
                58 => {
                    self.next_update_id = is.read_string()?;
                },
                122 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.metadata.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.type_.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.type_);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.description);
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::int64_size(4, self.timestamp);
        }
        if let Some(v) = self.location.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.prev_update_id.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.prev_update_id);
        }
        if !self.next_update_id.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.next_update_id);
        }
        for (k, v) in &self.metadata {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.type_.is_empty() {
            os.write_string(2, &self.type_)?;
        }
        if !self.description.is_empty() {
            os.write_string(3, &self.description)?;
        }
        if self.timestamp != 0 {
            os.write_int64(4, self.timestamp)?;
        }
        if let Some(v) = self.location.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if !self.prev_update_id.is_empty() {
            os.write_string(6, &self.prev_update_id)?;
        }
        if !self.next_update_id.is_empty() {
            os.write_string(7, &self.next_update_id)?;
        }
        for (k, v) in &self.metadata {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(122)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TelematicUpdate {
        TelematicUpdate::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.type_.clear();
        self.description.clear();
        self.timestamp = 0;
        self.location.clear();
        self.prev_update_id.clear();
        self.next_update_id.clear();
        self.metadata.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TelematicUpdate {
        static instance: ::protobuf::rt::Lazy<TelematicUpdate> = ::protobuf::rt::Lazy::new();
        instance.get(TelematicUpdate::new)
    }
}

impl ::protobuf::MessageFull for TelematicUpdate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TelematicUpdate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TelematicUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TelematicUpdate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:global.Location)
pub struct Location {
    // message fields
    // @@protoc_insertion_point(field:global.Location.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:global.Location.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:global.Location.description)
    pub description: ::std::string::String,
    // @@protoc_insertion_point(field:global.Location.address)
    pub address: ::protobuf::MessageField<Address>,
    // @@protoc_insertion_point(field:global.Location.geo)
    pub geo: ::protobuf::MessageField<Geo>,
    // @@protoc_insertion_point(field:global.Location.type)
    pub type_: ::protobuf::EnumOrUnknown<LocationType>,
    // special fields
    // @@protoc_insertion_point(special_field:global.Location.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Location {
    fn default() -> &'a Location {
        <Location as ::protobuf::Message>::default_instance()
    }
}

impl Location {
    pub fn new() -> Location {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Location| { &m.id },
            |m: &mut Location| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &Location| { &m.name },
            |m: &mut Location| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "description",
            |m: &Location| { &m.description },
            |m: &mut Location| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Address>(
            "address",
            |m: &Location| { &m.address },
            |m: &mut Location| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Geo>(
            "geo",
            |m: &Location| { &m.geo },
            |m: &mut Location| { &mut m.geo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &Location| { &m.type_ },
            |m: &mut Location| { &mut m.type_ },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Location>(
            "Location",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Location {
    const NAME: &'static str = "Location";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                26 => {
                    self.description = is.read_string()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.address)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.geo)?;
                },
                48 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.description);
        }
        if let Some(v) = self.address.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.geo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(LocationType::LOCATION_TYPE_UNSPECIFIED) {
            my_size += ::protobuf::rt::int32_size(6, self.type_.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.description.is_empty() {
            os.write_string(3, &self.description)?;
        }
        if let Some(v) = self.address.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.geo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(LocationType::LOCATION_TYPE_UNSPECIFIED) {
            os.write_enum(6, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Location {
        Location::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.name.clear();
        self.description.clear();
        self.address.clear();
        self.geo.clear();
        self.type_ = ::protobuf::EnumOrUnknown::new(LocationType::LOCATION_TYPE_UNSPECIFIED);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Location {
        static instance: Location = Location {
            id: ::std::string::String::new(),
            name: ::std::string::String::new(),
            description: ::std::string::String::new(),
            address: ::protobuf::MessageField::none(),
            geo: ::protobuf::MessageField::none(),
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Location {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Location").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Location {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Location {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:global.Geo)
pub struct Geo {
    // message fields
    // @@protoc_insertion_point(field:global.Geo.latitude)
    pub latitude: f32,
    // @@protoc_insertion_point(field:global.Geo.longitude)
    pub longitude: f32,
    // @@protoc_insertion_point(field:global.Geo.altitude)
    pub altitude: f32,
    // @@protoc_insertion_point(field:global.Geo.speed)
    pub speed: f32,
    // @@protoc_insertion_point(field:global.Geo.heading)
    pub heading: f32,
    // @@protoc_insertion_point(field:global.Geo.accuracy)
    pub accuracy: f32,
    // special fields
    // @@protoc_insertion_point(special_field:global.Geo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Geo {
    fn default() -> &'a Geo {
        <Geo as ::protobuf::Message>::default_instance()
    }
}

impl Geo {
    pub fn new() -> Geo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "latitude",
            |m: &Geo| { &m.latitude },
            |m: &mut Geo| { &mut m.latitude },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "longitude",
            |m: &Geo| { &m.longitude },
            |m: &mut Geo| { &mut m.longitude },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "altitude",
            |m: &Geo| { &m.altitude },
            |m: &mut Geo| { &mut m.altitude },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "speed",
            |m: &Geo| { &m.speed },
            |m: &mut Geo| { &mut m.speed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "heading",
            |m: &Geo| { &m.heading },
            |m: &mut Geo| { &mut m.heading },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "accuracy",
            |m: &Geo| { &m.accuracy },
            |m: &mut Geo| { &mut m.accuracy },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Geo>(
            "Geo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Geo {
    const NAME: &'static str = "Geo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.latitude = is.read_float()?;
                },
                21 => {
                    self.longitude = is.read_float()?;
                },
                29 => {
                    self.altitude = is.read_float()?;
                },
                37 => {
                    self.speed = is.read_float()?;
                },
                45 => {
                    self.heading = is.read_float()?;
                },
                53 => {
                    self.accuracy = is.read_float()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.latitude != 0. {
            my_size += 1 + 4;
        }
        if self.longitude != 0. {
            my_size += 1 + 4;
        }
        if self.altitude != 0. {
            my_size += 1 + 4;
        }
        if self.speed != 0. {
            my_size += 1 + 4;
        }
        if self.heading != 0. {
            my_size += 1 + 4;
        }
        if self.accuracy != 0. {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.latitude != 0. {
            os.write_float(1, self.latitude)?;
        }
        if self.longitude != 0. {
            os.write_float(2, self.longitude)?;
        }
        if self.altitude != 0. {
            os.write_float(3, self.altitude)?;
        }
        if self.speed != 0. {
            os.write_float(4, self.speed)?;
        }
        if self.heading != 0. {
            os.write_float(5, self.heading)?;
        }
        if self.accuracy != 0. {
            os.write_float(6, self.accuracy)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Geo {
        Geo::new()
    }

    fn clear(&mut self) {
        self.latitude = 0.;
        self.longitude = 0.;
        self.altitude = 0.;
        self.speed = 0.;
        self.heading = 0.;
        self.accuracy = 0.;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Geo {
        static instance: Geo = Geo {
            latitude: 0.,
            longitude: 0.,
            altitude: 0.,
            speed: 0.,
            heading: 0.,
            accuracy: 0.,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Geo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Geo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Geo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Geo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:global.Address)
pub struct Address {
    // message fields
    // @@protoc_insertion_point(field:global.Address.street)
    pub street: ::std::string::String,
    // @@protoc_insertion_point(field:global.Address.street_2)
    pub street_2: ::std::string::String,
    // @@protoc_insertion_point(field:global.Address.city)
    pub city: ::std::string::String,
    // @@protoc_insertion_point(field:global.Address.state)
    pub state: ::std::string::String,
    // @@protoc_insertion_point(field:global.Address.country)
    pub country: ::std::string::String,
    // @@protoc_insertion_point(field:global.Address.zip)
    pub zip: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:global.Address.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Address {
    fn default() -> &'a Address {
        <Address as ::protobuf::Message>::default_instance()
    }
}

impl Address {
    pub fn new() -> Address {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "street",
            |m: &Address| { &m.street },
            |m: &mut Address| { &mut m.street },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "street_2",
            |m: &Address| { &m.street_2 },
            |m: &mut Address| { &mut m.street_2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "city",
            |m: &Address| { &m.city },
            |m: &mut Address| { &mut m.city },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "state",
            |m: &Address| { &m.state },
            |m: &mut Address| { &mut m.state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "country",
            |m: &Address| { &m.country },
            |m: &mut Address| { &mut m.country },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "zip",
            |m: &Address| { &m.zip },
            |m: &mut Address| { &mut m.zip },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Address>(
            "Address",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Address {
    const NAME: &'static str = "Address";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.street = is.read_string()?;
                },
                18 => {
                    self.street_2 = is.read_string()?;
                },
                26 => {
                    self.city = is.read_string()?;
                },
                34 => {
                    self.state = is.read_string()?;
                },
                42 => {
                    self.country = is.read_string()?;
                },
                50 => {
                    self.zip = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.street.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.street);
        }
        if !self.street_2.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.street_2);
        }
        if !self.city.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.city);
        }
        if !self.state.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.state);
        }
        if !self.country.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.country);
        }
        if !self.zip.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.zip);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.street.is_empty() {
            os.write_string(1, &self.street)?;
        }
        if !self.street_2.is_empty() {
            os.write_string(2, &self.street_2)?;
        }
        if !self.city.is_empty() {
            os.write_string(3, &self.city)?;
        }
        if !self.state.is_empty() {
            os.write_string(4, &self.state)?;
        }
        if !self.country.is_empty() {
            os.write_string(5, &self.country)?;
        }
        if !self.zip.is_empty() {
            os.write_string(6, &self.zip)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Address {
        Address::new()
    }

    fn clear(&mut self) {
        self.street.clear();
        self.street_2.clear();
        self.city.clear();
        self.state.clear();
        self.country.clear();
        self.zip.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Address {
        static instance: Address = Address {
            street: ::std::string::String::new(),
            street_2: ::std::string::String::new(),
            city: ::std::string::String::new(),
            state: ::std::string::String::new(),
            country: ::std::string::String::new(),
            zip: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Address {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Address").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Address {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Address {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Meant to be super flexible to allow for any type of query
///  still with some level of static typing. 
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:global.Query)
pub struct Query {
    // message fields
    // @@protoc_insertion_point(field:global.Query.terms)
    pub terms: ::std::vec::Vec<Term>,
    // @@protoc_insertion_point(field:global.Query.page)
    pub page: i32,
    // @@protoc_insertion_point(field:global.Query.page_size)
    pub page_size: i32,
    // @@protoc_insertion_point(field:global.Query.order)
    pub order: ::protobuf::EnumOrUnknown<Order>,
    // special fields
    // @@protoc_insertion_point(special_field:global.Query.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Query {
    fn default() -> &'a Query {
        <Query as ::protobuf::Message>::default_instance()
    }
}

impl Query {
    pub fn new() -> Query {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "terms",
            |m: &Query| { &m.terms },
            |m: &mut Query| { &mut m.terms },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &Query| { &m.page },
            |m: &mut Query| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page_size",
            |m: &Query| { &m.page_size },
            |m: &mut Query| { &mut m.page_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "order",
            |m: &Query| { &m.order },
            |m: &mut Query| { &mut m.order },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Query>(
            "Query",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Query {
    const NAME: &'static str = "Query";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.terms.push(is.read_message()?);
                },
                16 => {
                    self.page = is.read_int32()?;
                },
                24 => {
                    self.page_size = is.read_int32()?;
                },
                32 => {
                    self.order = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.terms {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.page != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.page);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.page_size);
        }
        if self.order != ::protobuf::EnumOrUnknown::new(Order::ORDER_UNSPECIFIED) {
            my_size += ::protobuf::rt::int32_size(4, self.order.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.terms {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if self.page != 0 {
            os.write_int32(2, self.page)?;
        }
        if self.page_size != 0 {
            os.write_int32(3, self.page_size)?;
        }
        if self.order != ::protobuf::EnumOrUnknown::new(Order::ORDER_UNSPECIFIED) {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&self.order))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Query {
        Query::new()
    }

    fn clear(&mut self) {
        self.terms.clear();
        self.page = 0;
        self.page_size = 0;
        self.order = ::protobuf::EnumOrUnknown::new(Order::ORDER_UNSPECIFIED);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Query {
        static instance: Query = Query {
            terms: ::std::vec::Vec::new(),
            page: 0,
            page_size: 0,
            order: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Query {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Query").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Query {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Query {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:global.Term)
pub struct Term {
    // message fields
    ///  TODO: make type an enum: [string, int, float, bool, 
    ///  date, time, datetime, geo, address, phone, email, url, uuid, id]\
    // @@protoc_insertion_point(field:global.Term.key)
    pub key: ::std::string::String,
    // @@protoc_insertion_point(field:global.Term.value)
    pub value: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:global.Term.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Term {
    fn default() -> &'a Term {
        <Term as ::protobuf::Message>::default_instance()
    }
}

impl Term {
    pub fn new() -> Term {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &Term| { &m.key },
            |m: &mut Term| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &Term| { &m.value },
            |m: &mut Term| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Term>(
            "Term",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Term {
    const NAME: &'static str = "Term";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key = is.read_string()?;
                },
                18 => {
                    self.value = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.key.is_empty() {
            os.write_string(1, &self.key)?;
        }
        if !self.value.is_empty() {
            os.write_string(2, &self.value)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Term {
        Term::new()
    }

    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Term {
        static instance: Term = Term {
            key: ::std::string::String::new(),
            value: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Term {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Term").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Term {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Term {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:global.Rating)
pub struct Rating {
    // message fields
    // @@protoc_insertion_point(field:global.Rating.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:global.Rating.guest_id)
    pub guest_id: ::std::string::String,
    // @@protoc_insertion_point(field:global.Rating.partner_id)
    pub partner_id: ::std::string::String,
    // @@protoc_insertion_point(field:global.Rating.project_id)
    pub project_id: ::std::string::String,
    // @@protoc_insertion_point(field:global.Rating.score)
    pub score: i32,
    // @@protoc_insertion_point(field:global.Rating.comment)
    pub comment: ::std::string::String,
    // @@protoc_insertion_point(field:global.Rating.created_at)
    pub created_at: ::std::string::String,
    // @@protoc_insertion_point(field:global.Rating.updated_at)
    pub updated_at: ::std::string::String,
    // @@protoc_insertion_point(field:global.Rating.deleted_at)
    pub deleted_at: ::std::string::String,
    // message oneof groups
    pub rating_type: ::std::option::Option<rating::Rating_type>,
    // special fields
    // @@protoc_insertion_point(special_field:global.Rating.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Rating {
    fn default() -> &'a Rating {
        <Rating as ::protobuf::Message>::default_instance()
    }
}

impl Rating {
    pub fn new() -> Rating {
        ::std::default::Default::default()
    }

    // string sample = 10;

    pub fn sample(&self) -> &str {
        match self.rating_type {
            ::std::option::Option::Some(rating::Rating_type::Sample(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_sample(&mut self) {
        self.rating_type = ::std::option::Option::None;
    }

    pub fn has_sample(&self) -> bool {
        match self.rating_type {
            ::std::option::Option::Some(rating::Rating_type::Sample(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sample(&mut self, v: ::std::string::String) {
        self.rating_type = ::std::option::Option::Some(rating::Rating_type::Sample(v))
    }

    // Mutable pointer to the field.
    pub fn mut_sample(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(rating::Rating_type::Sample(_)) = self.rating_type {
        } else {
            self.rating_type = ::std::option::Option::Some(rating::Rating_type::Sample(::std::string::String::new()));
        }
        match self.rating_type {
            ::std::option::Option::Some(rating::Rating_type::Sample(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_sample(&mut self) -> ::std::string::String {
        if self.has_sample() {
            match self.rating_type.take() {
                ::std::option::Option::Some(rating::Rating_type::Sample(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Rating| { &m.id },
            |m: &mut Rating| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "guest_id",
            |m: &Rating| { &m.guest_id },
            |m: &mut Rating| { &mut m.guest_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "partner_id",
            |m: &Rating| { &m.partner_id },
            |m: &mut Rating| { &mut m.partner_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "project_id",
            |m: &Rating| { &m.project_id },
            |m: &mut Rating| { &mut m.project_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "score",
            |m: &Rating| { &m.score },
            |m: &mut Rating| { &mut m.score },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "comment",
            |m: &Rating| { &m.comment },
            |m: &mut Rating| { &mut m.comment },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "created_at",
            |m: &Rating| { &m.created_at },
            |m: &mut Rating| { &mut m.created_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "updated_at",
            |m: &Rating| { &m.updated_at },
            |m: &mut Rating| { &mut m.updated_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "deleted_at",
            |m: &Rating| { &m.deleted_at },
            |m: &mut Rating| { &mut m.deleted_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "sample",
            Rating::has_sample,
            Rating::sample,
            Rating::set_sample,
        ));
        oneofs.push(rating::Rating_type::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Rating>(
            "Rating",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Rating {
    const NAME: &'static str = "Rating";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.guest_id = is.read_string()?;
                },
                26 => {
                    self.partner_id = is.read_string()?;
                },
                34 => {
                    self.project_id = is.read_string()?;
                },
                40 => {
                    self.score = is.read_int32()?;
                },
                50 => {
                    self.comment = is.read_string()?;
                },
                58 => {
                    self.created_at = is.read_string()?;
                },
                66 => {
                    self.updated_at = is.read_string()?;
                },
                74 => {
                    self.deleted_at = is.read_string()?;
                },
                82 => {
                    self.rating_type = ::std::option::Option::Some(rating::Rating_type::Sample(is.read_string()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.guest_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.guest_id);
        }
        if !self.partner_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.partner_id);
        }
        if !self.project_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.project_id);
        }
        if self.score != 0 {
            my_size += ::protobuf::rt::int32_size(5, self.score);
        }
        if !self.comment.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.comment);
        }
        if !self.created_at.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.created_at);
        }
        if !self.updated_at.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.updated_at);
        }
        if !self.deleted_at.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.deleted_at);
        }
        if let ::std::option::Option::Some(ref v) = self.rating_type {
            match v {
                &rating::Rating_type::Sample(ref v) => {
                    my_size += ::protobuf::rt::string_size(10, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.guest_id.is_empty() {
            os.write_string(2, &self.guest_id)?;
        }
        if !self.partner_id.is_empty() {
            os.write_string(3, &self.partner_id)?;
        }
        if !self.project_id.is_empty() {
            os.write_string(4, &self.project_id)?;
        }
        if self.score != 0 {
            os.write_int32(5, self.score)?;
        }
        if !self.comment.is_empty() {
            os.write_string(6, &self.comment)?;
        }
        if !self.created_at.is_empty() {
            os.write_string(7, &self.created_at)?;
        }
        if !self.updated_at.is_empty() {
            os.write_string(8, &self.updated_at)?;
        }
        if !self.deleted_at.is_empty() {
            os.write_string(9, &self.deleted_at)?;
        }
        if let ::std::option::Option::Some(ref v) = self.rating_type {
            match v {
                &rating::Rating_type::Sample(ref v) => {
                    os.write_string(10, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Rating {
        Rating::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.guest_id.clear();
        self.partner_id.clear();
        self.project_id.clear();
        self.score = 0;
        self.comment.clear();
        self.created_at.clear();
        self.updated_at.clear();
        self.deleted_at.clear();
        self.rating_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Rating {
        static instance: Rating = Rating {
            id: ::std::string::String::new(),
            guest_id: ::std::string::String::new(),
            partner_id: ::std::string::String::new(),
            project_id: ::std::string::String::new(),
            score: 0,
            comment: ::std::string::String::new(),
            created_at: ::std::string::String::new(),
            updated_at: ::std::string::String::new(),
            deleted_at: ::std::string::String::new(),
            rating_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Rating {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Rating").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Rating {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Rating {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Rating`
pub mod rating {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:global.Rating.rating_type)
    pub enum Rating_type {
        // @@protoc_insertion_point(oneof_field:global.Rating.sample)
        Sample(::std::string::String),
    }

    impl ::protobuf::Oneof for Rating_type {
    }

    impl ::protobuf::OneofFull for Rating_type {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::Rating as ::protobuf::MessageFull>::descriptor().oneof_by_name("rating_type").unwrap()).clone()
        }
    }

    impl Rating_type {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Rating_type>("rating_type")
        }
    }
}

///  TODO: look in to analytics tracking
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:global.Impression)
pub struct Impression {
    // message fields
    // @@protoc_insertion_point(field:global.Impression.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:global.Impression.duration)
    pub duration: i64,
    // @@protoc_insertion_point(field:global.Impression.source)
    pub source: ::protobuf::MessageField<Source>,
    // special fields
    // @@protoc_insertion_point(special_field:global.Impression.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Impression {
    fn default() -> &'a Impression {
        <Impression as ::protobuf::Message>::default_instance()
    }
}

impl Impression {
    pub fn new() -> Impression {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Impression| { &m.id },
            |m: &mut Impression| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "duration",
            |m: &Impression| { &m.duration },
            |m: &mut Impression| { &mut m.duration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Source>(
            "source",
            |m: &Impression| { &m.source },
            |m: &mut Impression| { &mut m.source },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Impression>(
            "Impression",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Impression {
    const NAME: &'static str = "Impression";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                16 => {
                    self.duration = is.read_int64()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.source)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if self.duration != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.duration);
        }
        if let Some(v) = self.source.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if self.duration != 0 {
            os.write_int64(2, self.duration)?;
        }
        if let Some(v) = self.source.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Impression {
        Impression::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.duration = 0;
        self.source.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Impression {
        static instance: Impression = Impression {
            id: ::std::string::String::new(),
            duration: 0,
            source: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Impression {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Impression").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Impression {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Impression {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:global.Source)
pub struct Source {
    // message fields
    // @@protoc_insertion_point(field:global.Source.id)
    pub id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:global.Source.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Source {
    fn default() -> &'a Source {
        <Source as ::protobuf::Message>::default_instance()
    }
}

impl Source {
    pub fn new() -> Source {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Source| { &m.id },
            |m: &mut Source| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Source>(
            "Source",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Source {
    const NAME: &'static str = "Source";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Source {
        Source::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Source {
        static instance: Source = Source {
            id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Source {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Source").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Source {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Source {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  A calendar is a collection of related events, as well as additional 
/// metadata that defines it. Each  
/// calendar is identified by an ID which is an email address. Calendars 
/// can have multiple owners. When a reservation is created a calendar is 
/// created as well and tied to the reservation. 
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:global.Calendar)
pub struct Calendar {
    // message fields
    // @@protoc_insertion_point(field:global.Calendar.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:global.Calendar.owner_id)
    pub owner_id: ::std::string::String,
    // @@protoc_insertion_point(field:global.Calendar.resource_id)
    pub resource_id: ::std::string::String,
    // @@protoc_insertion_point(field:global.Calendar.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:global.Calendar.description)
    pub description: ::std::string::String,
    // @@protoc_insertion_point(field:global.Calendar.created_at)
    pub created_at: i64,
    // @@protoc_insertion_point(field:global.Calendar.updated_at)
    pub updated_at: i64,
    // @@protoc_insertion_point(field:global.Calendar.rules)
    pub rules: ::std::vec::Vec<Rule>,
    // @@protoc_insertion_point(field:global.Calendar.events)
    pub events: ::std::vec::Vec<Event>,
    // special fields
    // @@protoc_insertion_point(special_field:global.Calendar.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Calendar {
    fn default() -> &'a Calendar {
        <Calendar as ::protobuf::Message>::default_instance()
    }
}

impl Calendar {
    pub fn new() -> Calendar {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Calendar| { &m.id },
            |m: &mut Calendar| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "owner_id",
            |m: &Calendar| { &m.owner_id },
            |m: &mut Calendar| { &mut m.owner_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "resource_id",
            |m: &Calendar| { &m.resource_id },
            |m: &mut Calendar| { &mut m.resource_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &Calendar| { &m.name },
            |m: &mut Calendar| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "description",
            |m: &Calendar| { &m.description },
            |m: &mut Calendar| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "created_at",
            |m: &Calendar| { &m.created_at },
            |m: &mut Calendar| { &mut m.created_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "updated_at",
            |m: &Calendar| { &m.updated_at },
            |m: &mut Calendar| { &mut m.updated_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "rules",
            |m: &Calendar| { &m.rules },
            |m: &mut Calendar| { &mut m.rules },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "events",
            |m: &Calendar| { &m.events },
            |m: &mut Calendar| { &mut m.events },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Calendar>(
            "Calendar",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Calendar {
    const NAME: &'static str = "Calendar";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.owner_id = is.read_string()?;
                },
                26 => {
                    self.resource_id = is.read_string()?;
                },
                34 => {
                    self.name = is.read_string()?;
                },
                42 => {
                    self.description = is.read_string()?;
                },
                48 => {
                    self.created_at = is.read_int64()?;
                },
                56 => {
                    self.updated_at = is.read_int64()?;
                },
                66 => {
                    self.rules.push(is.read_message()?);
                },
                74 => {
                    self.events.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.owner_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.owner_id);
        }
        if !self.resource_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.resource_id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.name);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.description);
        }
        if self.created_at != 0 {
            my_size += ::protobuf::rt::int64_size(6, self.created_at);
        }
        if self.updated_at != 0 {
            my_size += ::protobuf::rt::int64_size(7, self.updated_at);
        }
        for value in &self.rules {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.events {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.owner_id.is_empty() {
            os.write_string(2, &self.owner_id)?;
        }
        if !self.resource_id.is_empty() {
            os.write_string(3, &self.resource_id)?;
        }
        if !self.name.is_empty() {
            os.write_string(4, &self.name)?;
        }
        if !self.description.is_empty() {
            os.write_string(5, &self.description)?;
        }
        if self.created_at != 0 {
            os.write_int64(6, self.created_at)?;
        }
        if self.updated_at != 0 {
            os.write_int64(7, self.updated_at)?;
        }
        for v in &self.rules {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        for v in &self.events {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Calendar {
        Calendar::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.owner_id.clear();
        self.resource_id.clear();
        self.name.clear();
        self.description.clear();
        self.created_at = 0;
        self.updated_at = 0;
        self.rules.clear();
        self.events.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Calendar {
        static instance: Calendar = Calendar {
            id: ::std::string::String::new(),
            owner_id: ::std::string::String::new(),
            resource_id: ::std::string::String::new(),
            name: ::std::string::String::new(),
            description: ::std::string::String::new(),
            created_at: 0,
            updated_at: 0,
            rules: ::std::vec::Vec::new(),
            events: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Calendar {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Calendar").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Calendar {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Calendar {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// An event is an object associated with a specific date or time range. 
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:global.Event)
pub struct Event {
    // message fields
    // @@protoc_insertion_point(field:global.Event.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:global.Event.primary_calendar)
    pub primary_calendar: ::protobuf::MessageField<Calendar>,
    ///  Calendars where the event would show i.e. calendars of attending guests. 
    // @@protoc_insertion_point(field:global.Event.associated_calendars)
    pub associated_calendars: ::std::vec::Vec<Calendar>,
    // special fields
    // @@protoc_insertion_point(special_field:global.Event.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Event {
    fn default() -> &'a Event {
        <Event as ::protobuf::Message>::default_instance()
    }
}

impl Event {
    pub fn new() -> Event {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Event| { &m.id },
            |m: &mut Event| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Calendar>(
            "primary_calendar",
            |m: &Event| { &m.primary_calendar },
            |m: &mut Event| { &mut m.primary_calendar },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "associated_calendars",
            |m: &Event| { &m.associated_calendars },
            |m: &mut Event| { &mut m.associated_calendars },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Event>(
            "Event",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Event {
    const NAME: &'static str = "Event";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.primary_calendar)?;
                },
                26 => {
                    self.associated_calendars.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if let Some(v) = self.primary_calendar.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.associated_calendars {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if let Some(v) = self.primary_calendar.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.associated_calendars {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Event {
        Event::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.primary_calendar.clear();
        self.associated_calendars.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Event {
        static instance: Event = Event {
            id: ::std::string::String::new(),
            primary_calendar: ::protobuf::MessageField::none(),
            associated_calendars: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Event {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Event").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Event {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Event {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:global.Note)
pub struct Note {
    // message fields
    // @@protoc_insertion_point(field:global.Note.guest_id)
    pub guest_id: ::std::string::String,
    // @@protoc_insertion_point(field:global.Note.partner_id)
    pub partner_id: ::std::string::String,
    // @@protoc_insertion_point(field:global.Note.project_id)
    pub project_id: ::std::string::String,
    // @@protoc_insertion_point(field:global.Note.title)
    pub title: ::std::string::String,
    // @@protoc_insertion_point(field:global.Note.body)
    pub body: ::std::string::String,
    // @@protoc_insertion_point(field:global.Note.created_at)
    pub created_at: ::std::string::String,
    // @@protoc_insertion_point(field:global.Note.updated_at)
    pub updated_at: ::std::string::String,
    // @@protoc_insertion_point(field:global.Note.deleted_at)
    pub deleted_at: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:global.Note.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Note {
    fn default() -> &'a Note {
        <Note as ::protobuf::Message>::default_instance()
    }
}

impl Note {
    pub fn new() -> Note {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "guest_id",
            |m: &Note| { &m.guest_id },
            |m: &mut Note| { &mut m.guest_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "partner_id",
            |m: &Note| { &m.partner_id },
            |m: &mut Note| { &mut m.partner_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "project_id",
            |m: &Note| { &m.project_id },
            |m: &mut Note| { &mut m.project_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "title",
            |m: &Note| { &m.title },
            |m: &mut Note| { &mut m.title },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "body",
            |m: &Note| { &m.body },
            |m: &mut Note| { &mut m.body },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "created_at",
            |m: &Note| { &m.created_at },
            |m: &mut Note| { &mut m.created_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "updated_at",
            |m: &Note| { &m.updated_at },
            |m: &mut Note| { &mut m.updated_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "deleted_at",
            |m: &Note| { &m.deleted_at },
            |m: &mut Note| { &mut m.deleted_at },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Note>(
            "Note",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Note {
    const NAME: &'static str = "Note";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.guest_id = is.read_string()?;
                },
                18 => {
                    self.partner_id = is.read_string()?;
                },
                26 => {
                    self.project_id = is.read_string()?;
                },
                34 => {
                    self.title = is.read_string()?;
                },
                42 => {
                    self.body = is.read_string()?;
                },
                50 => {
                    self.created_at = is.read_string()?;
                },
                58 => {
                    self.updated_at = is.read_string()?;
                },
                66 => {
                    self.deleted_at = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.guest_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.guest_id);
        }
        if !self.partner_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.partner_id);
        }
        if !self.project_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.project_id);
        }
        if !self.title.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.title);
        }
        if !self.body.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.body);
        }
        if !self.created_at.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.created_at);
        }
        if !self.updated_at.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.updated_at);
        }
        if !self.deleted_at.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.deleted_at);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.guest_id.is_empty() {
            os.write_string(1, &self.guest_id)?;
        }
        if !self.partner_id.is_empty() {
            os.write_string(2, &self.partner_id)?;
        }
        if !self.project_id.is_empty() {
            os.write_string(3, &self.project_id)?;
        }
        if !self.title.is_empty() {
            os.write_string(4, &self.title)?;
        }
        if !self.body.is_empty() {
            os.write_string(5, &self.body)?;
        }
        if !self.created_at.is_empty() {
            os.write_string(6, &self.created_at)?;
        }
        if !self.updated_at.is_empty() {
            os.write_string(7, &self.updated_at)?;
        }
        if !self.deleted_at.is_empty() {
            os.write_string(8, &self.deleted_at)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Note {
        Note::new()
    }

    fn clear(&mut self) {
        self.guest_id.clear();
        self.partner_id.clear();
        self.project_id.clear();
        self.title.clear();
        self.body.clear();
        self.created_at.clear();
        self.updated_at.clear();
        self.deleted_at.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Note {
        static instance: Note = Note {
            guest_id: ::std::string::String::new(),
            partner_id: ::std::string::String::new(),
            project_id: ::std::string::String::new(),
            title: ::std::string::String::new(),
            body: ::std::string::String::new(),
            created_at: ::std::string::String::new(),
            updated_at: ::std::string::String::new(),
            deleted_at: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Note {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Note").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Note {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Note {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:global.Error)
pub struct Error {
    // message fields
    // @@protoc_insertion_point(field:global.Error.code)
    pub code: ::std::string::String,
    // @@protoc_insertion_point(field:global.Error.message)
    pub message: ::std::string::String,
    // @@protoc_insertion_point(field:global.Error.timestamp)
    pub timestamp: i64,
    // special fields
    // @@protoc_insertion_point(special_field:global.Error.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Error {
    fn default() -> &'a Error {
        <Error as ::protobuf::Message>::default_instance()
    }
}

impl Error {
    pub fn new() -> Error {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "code",
            |m: &Error| { &m.code },
            |m: &mut Error| { &mut m.code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "message",
            |m: &Error| { &m.message },
            |m: &mut Error| { &mut m.message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "timestamp",
            |m: &Error| { &m.timestamp },
            |m: &mut Error| { &mut m.timestamp },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Error>(
            "Error",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Error {
    const NAME: &'static str = "Error";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.code = is.read_string()?;
                },
                18 => {
                    self.message = is.read_string()?;
                },
                24 => {
                    self.timestamp = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.code.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.code);
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.message);
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.timestamp);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.code.is_empty() {
            os.write_string(1, &self.code)?;
        }
        if !self.message.is_empty() {
            os.write_string(2, &self.message)?;
        }
        if self.timestamp != 0 {
            os.write_int64(3, self.timestamp)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Error {
        Error::new()
    }

    fn clear(&mut self) {
        self.code.clear();
        self.message.clear();
        self.timestamp = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Error {
        static instance: Error = Error {
            code: ::std::string::String::new(),
            message: ::std::string::String::new(),
            timestamp: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Error {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Error").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Error {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Error {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:global.Rule)
pub struct Rule {
    // message fields
    // @@protoc_insertion_point(field:global.Rule.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:global.Rule.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:global.Rule.description)
    pub description: ::std::string::String,
    // @@protoc_insertion_point(field:global.Rule.start_time)
    pub start_time: i64,
    // @@protoc_insertion_point(field:global.Rule.end_time)
    pub end_time: i64,
    // @@protoc_insertion_point(field:global.Rule.principal)
    pub principal: ::protobuf::MessageField<Entity>,
    // @@protoc_insertion_point(field:global.Rule.options)
    pub options: ::std::vec::Vec<Option>,
    // special fields
    // @@protoc_insertion_point(special_field:global.Rule.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Rule {
    fn default() -> &'a Rule {
        <Rule as ::protobuf::Message>::default_instance()
    }
}

impl Rule {
    pub fn new() -> Rule {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Rule| { &m.id },
            |m: &mut Rule| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &Rule| { &m.name },
            |m: &mut Rule| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "description",
            |m: &Rule| { &m.description },
            |m: &mut Rule| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "start_time",
            |m: &Rule| { &m.start_time },
            |m: &mut Rule| { &mut m.start_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "end_time",
            |m: &Rule| { &m.end_time },
            |m: &mut Rule| { &mut m.end_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Entity>(
            "principal",
            |m: &Rule| { &m.principal },
            |m: &mut Rule| { &mut m.principal },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "options",
            |m: &Rule| { &m.options },
            |m: &mut Rule| { &mut m.options },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Rule>(
            "Rule",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Rule {
    const NAME: &'static str = "Rule";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                26 => {
                    self.description = is.read_string()?;
                },
                32 => {
                    self.start_time = is.read_int64()?;
                },
                40 => {
                    self.end_time = is.read_int64()?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.principal)?;
                },
                58 => {
                    self.options.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.description);
        }
        if self.start_time != 0 {
            my_size += ::protobuf::rt::int64_size(4, self.start_time);
        }
        if self.end_time != 0 {
            my_size += ::protobuf::rt::int64_size(5, self.end_time);
        }
        if let Some(v) = self.principal.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.options {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.description.is_empty() {
            os.write_string(3, &self.description)?;
        }
        if self.start_time != 0 {
            os.write_int64(4, self.start_time)?;
        }
        if self.end_time != 0 {
            os.write_int64(5, self.end_time)?;
        }
        if let Some(v) = self.principal.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        for v in &self.options {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Rule {
        Rule::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.name.clear();
        self.description.clear();
        self.start_time = 0;
        self.end_time = 0;
        self.principal.clear();
        self.options.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Rule {
        static instance: Rule = Rule {
            id: ::std::string::String::new(),
            name: ::std::string::String::new(),
            description: ::std::string::String::new(),
            start_time: 0,
            end_time: 0,
            principal: ::protobuf::MessageField::none(),
            options: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Rule {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Rule").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Rule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Rule {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  boat entity and captain entity
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:global.Option)
pub struct Option {
    // message fields
    // @@protoc_insertion_point(field:global.Option.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:global.Option.description)
    pub description: ::std::string::String,
    // @@protoc_insertion_point(field:global.Option.required)
    pub required: bool,
    // @@protoc_insertion_point(field:global.Option.entity)
    pub entity: ::protobuf::MessageField<Entity>,
    // special fields
    // @@protoc_insertion_point(special_field:global.Option.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Option {
    fn default() -> &'a Option {
        <Option as ::protobuf::Message>::default_instance()
    }
}

impl Option {
    pub fn new() -> Option {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &Option| { &m.name },
            |m: &mut Option| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "description",
            |m: &Option| { &m.description },
            |m: &mut Option| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "required",
            |m: &Option| { &m.required },
            |m: &mut Option| { &mut m.required },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Entity>(
            "entity",
            |m: &Option| { &m.entity },
            |m: &mut Option| { &mut m.entity },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Option>(
            "Option",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Option {
    const NAME: &'static str = "Option";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                18 => {
                    self.description = is.read_string()?;
                },
                24 => {
                    self.required = is.read_bool()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.entity)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.description);
        }
        if self.required != false {
            my_size += 1 + 1;
        }
        if let Some(v) = self.entity.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.description.is_empty() {
            os.write_string(2, &self.description)?;
        }
        if self.required != false {
            os.write_bool(3, self.required)?;
        }
        if let Some(v) = self.entity.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Option {
        Option::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.description.clear();
        self.required = false;
        self.entity.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Option {
        static instance: Option = Option {
            name: ::std::string::String::new(),
            description: ::std::string::String::new(),
            required: false,
            entity: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Option {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Option").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Option {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Option {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:global.Caveat)
pub struct Caveat {
    // message fields
    // @@protoc_insertion_point(field:global.Caveat.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:global.Caveat.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:global.Caveat.description)
    pub description: ::std::string::String,
    // @@protoc_insertion_point(field:global.Caveat.start_time)
    pub start_time: i64,
    // @@protoc_insertion_point(field:global.Caveat.end_time)
    pub end_time: i64,
    // special fields
    // @@protoc_insertion_point(special_field:global.Caveat.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Caveat {
    fn default() -> &'a Caveat {
        <Caveat as ::protobuf::Message>::default_instance()
    }
}

impl Caveat {
    pub fn new() -> Caveat {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Caveat| { &m.id },
            |m: &mut Caveat| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &Caveat| { &m.name },
            |m: &mut Caveat| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "description",
            |m: &Caveat| { &m.description },
            |m: &mut Caveat| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "start_time",
            |m: &Caveat| { &m.start_time },
            |m: &mut Caveat| { &mut m.start_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "end_time",
            |m: &Caveat| { &m.end_time },
            |m: &mut Caveat| { &mut m.end_time },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Caveat>(
            "Caveat",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Caveat {
    const NAME: &'static str = "Caveat";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                26 => {
                    self.description = is.read_string()?;
                },
                32 => {
                    self.start_time = is.read_int64()?;
                },
                40 => {
                    self.end_time = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.description);
        }
        if self.start_time != 0 {
            my_size += ::protobuf::rt::int64_size(4, self.start_time);
        }
        if self.end_time != 0 {
            my_size += ::protobuf::rt::int64_size(5, self.end_time);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.description.is_empty() {
            os.write_string(3, &self.description)?;
        }
        if self.start_time != 0 {
            os.write_int64(4, self.start_time)?;
        }
        if self.end_time != 0 {
            os.write_int64(5, self.end_time)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Caveat {
        Caveat::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.name.clear();
        self.description.clear();
        self.start_time = 0;
        self.end_time = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Caveat {
        static instance: Caveat = Caveat {
            id: ::std::string::String::new(),
            name: ::std::string::String::new(),
            description: ::std::string::String::new(),
            start_time: 0,
            end_time: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Caveat {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Caveat").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Caveat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Caveat {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:global.Entity)
pub struct Entity {
    // message fields
    // @@protoc_insertion_point(field:global.Entity.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:global.Entity.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:global.Entity.description)
    pub description: ::std::string::String,
    // @@protoc_insertion_point(field:global.Entity.required)
    pub required: bool,
    // @@protoc_insertion_point(field:global.Entity.type)
    pub type_: ::protobuf::EnumOrUnknown<EntityType>,
    // @@protoc_insertion_point(field:global.Entity.role)
    pub role: ::std::string::String,
    // @@protoc_insertion_point(field:global.Entity.start_time)
    pub start_time: i64,
    // @@protoc_insertion_point(field:global.Entity.end_time)
    pub end_time: i64,
    // @@protoc_insertion_point(field:global.Entity.permissions)
    pub permissions: ::std::vec::Vec<Permission>,
    // special fields
    // @@protoc_insertion_point(special_field:global.Entity.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Entity {
    fn default() -> &'a Entity {
        <Entity as ::protobuf::Message>::default_instance()
    }
}

impl Entity {
    pub fn new() -> Entity {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Entity| { &m.id },
            |m: &mut Entity| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &Entity| { &m.name },
            |m: &mut Entity| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "description",
            |m: &Entity| { &m.description },
            |m: &mut Entity| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "required",
            |m: &Entity| { &m.required },
            |m: &mut Entity| { &mut m.required },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &Entity| { &m.type_ },
            |m: &mut Entity| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "role",
            |m: &Entity| { &m.role },
            |m: &mut Entity| { &mut m.role },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "start_time",
            |m: &Entity| { &m.start_time },
            |m: &mut Entity| { &mut m.start_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "end_time",
            |m: &Entity| { &m.end_time },
            |m: &mut Entity| { &mut m.end_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "permissions",
            |m: &Entity| { &m.permissions },
            |m: &mut Entity| { &mut m.permissions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Entity>(
            "Entity",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Entity {
    const NAME: &'static str = "Entity";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                26 => {
                    self.description = is.read_string()?;
                },
                32 => {
                    self.required = is.read_bool()?;
                },
                40 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                50 => {
                    self.role = is.read_string()?;
                },
                56 => {
                    self.start_time = is.read_int64()?;
                },
                64 => {
                    self.end_time = is.read_int64()?;
                },
                74 => {
                    self.permissions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.description);
        }
        if self.required != false {
            my_size += 1 + 1;
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(EntityType::ENTITY_TYPE_UNSPECIFIED) {
            my_size += ::protobuf::rt::int32_size(5, self.type_.value());
        }
        if !self.role.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.role);
        }
        if self.start_time != 0 {
            my_size += ::protobuf::rt::int64_size(7, self.start_time);
        }
        if self.end_time != 0 {
            my_size += ::protobuf::rt::int64_size(8, self.end_time);
        }
        for value in &self.permissions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.description.is_empty() {
            os.write_string(3, &self.description)?;
        }
        if self.required != false {
            os.write_bool(4, self.required)?;
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(EntityType::ENTITY_TYPE_UNSPECIFIED) {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        if !self.role.is_empty() {
            os.write_string(6, &self.role)?;
        }
        if self.start_time != 0 {
            os.write_int64(7, self.start_time)?;
        }
        if self.end_time != 0 {
            os.write_int64(8, self.end_time)?;
        }
        for v in &self.permissions {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Entity {
        Entity::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.name.clear();
        self.description.clear();
        self.required = false;
        self.type_ = ::protobuf::EnumOrUnknown::new(EntityType::ENTITY_TYPE_UNSPECIFIED);
        self.role.clear();
        self.start_time = 0;
        self.end_time = 0;
        self.permissions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Entity {
        static instance: Entity = Entity {
            id: ::std::string::String::new(),
            name: ::std::string::String::new(),
            description: ::std::string::String::new(),
            required: false,
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            role: ::std::string::String::new(),
            start_time: 0,
            end_time: 0,
            permissions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Entity {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Entity").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Entity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Entity {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:global.Permission)
pub struct Permission {
    // message fields
    // @@protoc_insertion_point(field:global.Permission.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:global.Permission.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:global.Permission.description)
    pub description: ::std::string::String,
    // @@protoc_insertion_point(field:global.Permission.allow)
    pub allow: bool,
    // @@protoc_insertion_point(field:global.Permission.start_time)
    pub start_time: i64,
    // @@protoc_insertion_point(field:global.Permission.end_time)
    pub end_time: i64,
    // special fields
    // @@protoc_insertion_point(special_field:global.Permission.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Permission {
    fn default() -> &'a Permission {
        <Permission as ::protobuf::Message>::default_instance()
    }
}

impl Permission {
    pub fn new() -> Permission {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Permission| { &m.id },
            |m: &mut Permission| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &Permission| { &m.name },
            |m: &mut Permission| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "description",
            |m: &Permission| { &m.description },
            |m: &mut Permission| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "allow",
            |m: &Permission| { &m.allow },
            |m: &mut Permission| { &mut m.allow },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "start_time",
            |m: &Permission| { &m.start_time },
            |m: &mut Permission| { &mut m.start_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "end_time",
            |m: &Permission| { &m.end_time },
            |m: &mut Permission| { &mut m.end_time },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Permission>(
            "Permission",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Permission {
    const NAME: &'static str = "Permission";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                26 => {
                    self.description = is.read_string()?;
                },
                32 => {
                    self.allow = is.read_bool()?;
                },
                40 => {
                    self.start_time = is.read_int64()?;
                },
                48 => {
                    self.end_time = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.description);
        }
        if self.allow != false {
            my_size += 1 + 1;
        }
        if self.start_time != 0 {
            my_size += ::protobuf::rt::int64_size(5, self.start_time);
        }
        if self.end_time != 0 {
            my_size += ::protobuf::rt::int64_size(6, self.end_time);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.description.is_empty() {
            os.write_string(3, &self.description)?;
        }
        if self.allow != false {
            os.write_bool(4, self.allow)?;
        }
        if self.start_time != 0 {
            os.write_int64(5, self.start_time)?;
        }
        if self.end_time != 0 {
            os.write_int64(6, self.end_time)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Permission {
        Permission::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.name.clear();
        self.description.clear();
        self.allow = false;
        self.start_time = 0;
        self.end_time = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Permission {
        static instance: Permission = Permission {
            id: ::std::string::String::new(),
            name: ::std::string::String::new(),
            description: ::std::string::String::new(),
            allow: false,
            start_time: 0,
            end_time: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Permission {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Permission").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Permission {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Permission {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:global.Content)
pub struct Content {
    // message fields
    // @@protoc_insertion_point(field:global.Content.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:global.Content.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:global.Content.description)
    pub description: ::std::string::String,
    // @@protoc_insertion_point(field:global.Content.url)
    pub url: ::std::string::String,
    // @@protoc_insertion_point(field:global.Content.mime_type)
    pub mime_type: ::std::string::String,
    // @@protoc_insertion_point(field:global.Content.size)
    pub size: i64,
    // @@protoc_insertion_point(field:global.Content.data)
    pub data: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:global.Content.creator_id)
    pub creator_id: ::std::string::String,
    // @@protoc_insertion_point(field:global.Content.creator_type)
    pub creator_type: ::protobuf::EnumOrUnknown<CreatorType>,
    // @@protoc_insertion_point(field:global.Content.created_at)
    pub created_at: i64,
    // @@protoc_insertion_point(field:global.Content.impressions)
    pub impressions: ::std::vec::Vec<Impression>,
    // @@protoc_insertion_point(field:global.Content.content_type)
    pub content_type: ::protobuf::EnumOrUnknown<ContentType>,
    // @@protoc_insertion_point(field:global.Content.metadata)
    pub metadata: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // @@protoc_insertion_point(field:global.Content.associations)
    pub associations: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:global.Content.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Content {
    fn default() -> &'a Content {
        <Content as ::protobuf::Message>::default_instance()
    }
}

impl Content {
    pub fn new() -> Content {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(14);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Content| { &m.id },
            |m: &mut Content| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &Content| { &m.name },
            |m: &mut Content| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "description",
            |m: &Content| { &m.description },
            |m: &mut Content| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "url",
            |m: &Content| { &m.url },
            |m: &mut Content| { &mut m.url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mime_type",
            |m: &Content| { &m.mime_type },
            |m: &mut Content| { &mut m.mime_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "size",
            |m: &Content| { &m.size },
            |m: &mut Content| { &mut m.size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data",
            |m: &Content| { &m.data },
            |m: &mut Content| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "creator_id",
            |m: &Content| { &m.creator_id },
            |m: &mut Content| { &mut m.creator_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "creator_type",
            |m: &Content| { &m.creator_type },
            |m: &mut Content| { &mut m.creator_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "created_at",
            |m: &Content| { &m.created_at },
            |m: &mut Content| { &mut m.created_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "impressions",
            |m: &Content| { &m.impressions },
            |m: &mut Content| { &mut m.impressions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "content_type",
            |m: &Content| { &m.content_type },
            |m: &mut Content| { &mut m.content_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "metadata",
            |m: &Content| { &m.metadata },
            |m: &mut Content| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "associations",
            |m: &Content| { &m.associations },
            |m: &mut Content| { &mut m.associations },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Content>(
            "Content",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Content {
    const NAME: &'static str = "Content";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                26 => {
                    self.description = is.read_string()?;
                },
                34 => {
                    self.url = is.read_string()?;
                },
                42 => {
                    self.mime_type = is.read_string()?;
                },
                48 => {
                    self.size = is.read_int64()?;
                },
                58 => {
                    self.data = is.read_bytes()?;
                },
                66 => {
                    self.creator_id = is.read_string()?;
                },
                72 => {
                    self.creator_type = is.read_enum_or_unknown()?;
                },
                80 => {
                    self.created_at = is.read_int64()?;
                },
                90 => {
                    self.impressions.push(is.read_message()?);
                },
                96 => {
                    self.content_type = is.read_enum_or_unknown()?;
                },
                106 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.metadata.insert(key, value);
                },
                114 => {
                    self.associations.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.description);
        }
        if !self.url.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.url);
        }
        if !self.mime_type.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.mime_type);
        }
        if self.size != 0 {
            my_size += ::protobuf::rt::int64_size(6, self.size);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(7, &self.data);
        }
        if !self.creator_id.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.creator_id);
        }
        if self.creator_type != ::protobuf::EnumOrUnknown::new(CreatorType::CREATOR_TYPE_UNSPECIFIED) {
            my_size += ::protobuf::rt::int32_size(9, self.creator_type.value());
        }
        if self.created_at != 0 {
            my_size += ::protobuf::rt::int64_size(10, self.created_at);
        }
        for value in &self.impressions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.content_type != ::protobuf::EnumOrUnknown::new(ContentType::CONTENT_TYPE_UNSPECIFIED) {
            my_size += ::protobuf::rt::int32_size(12, self.content_type.value());
        }
        for (k, v) in &self.metadata {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for value in &self.associations {
            my_size += ::protobuf::rt::string_size(14, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.description.is_empty() {
            os.write_string(3, &self.description)?;
        }
        if !self.url.is_empty() {
            os.write_string(4, &self.url)?;
        }
        if !self.mime_type.is_empty() {
            os.write_string(5, &self.mime_type)?;
        }
        if self.size != 0 {
            os.write_int64(6, self.size)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(7, &self.data)?;
        }
        if !self.creator_id.is_empty() {
            os.write_string(8, &self.creator_id)?;
        }
        if self.creator_type != ::protobuf::EnumOrUnknown::new(CreatorType::CREATOR_TYPE_UNSPECIFIED) {
            os.write_enum(9, ::protobuf::EnumOrUnknown::value(&self.creator_type))?;
        }
        if self.created_at != 0 {
            os.write_int64(10, self.created_at)?;
        }
        for v in &self.impressions {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        };
        if self.content_type != ::protobuf::EnumOrUnknown::new(ContentType::CONTENT_TYPE_UNSPECIFIED) {
            os.write_enum(12, ::protobuf::EnumOrUnknown::value(&self.content_type))?;
        }
        for (k, v) in &self.metadata {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(106)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        for v in &self.associations {
            os.write_string(14, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Content {
        Content::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.name.clear();
        self.description.clear();
        self.url.clear();
        self.mime_type.clear();
        self.size = 0;
        self.data.clear();
        self.creator_id.clear();
        self.creator_type = ::protobuf::EnumOrUnknown::new(CreatorType::CREATOR_TYPE_UNSPECIFIED);
        self.created_at = 0;
        self.impressions.clear();
        self.content_type = ::protobuf::EnumOrUnknown::new(ContentType::CONTENT_TYPE_UNSPECIFIED);
        self.metadata.clear();
        self.associations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Content {
        static instance: ::protobuf::rt::Lazy<Content> = ::protobuf::rt::Lazy::new();
        instance.get(Content::new)
    }
}

impl ::protobuf::MessageFull for Content {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Content").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Content {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Content {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  TODO: do we need this? 
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:global.ContentPacket)
pub struct ContentPacket {
    // message fields
    // @@protoc_insertion_point(field:global.ContentPacket.current_packets_total)
    pub current_packets_total: i64,
    ///  int64 current_packets_sent = 1; 
    // @@protoc_insertion_point(field:global.ContentPacket.media)
    pub media: ::protobuf::MessageField<Content>,
    // special fields
    // @@protoc_insertion_point(special_field:global.ContentPacket.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ContentPacket {
    fn default() -> &'a ContentPacket {
        <ContentPacket as ::protobuf::Message>::default_instance()
    }
}

impl ContentPacket {
    pub fn new() -> ContentPacket {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "current_packets_total",
            |m: &ContentPacket| { &m.current_packets_total },
            |m: &mut ContentPacket| { &mut m.current_packets_total },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Content>(
            "media",
            |m: &ContentPacket| { &m.media },
            |m: &mut ContentPacket| { &mut m.media },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ContentPacket>(
            "ContentPacket",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ContentPacket {
    const NAME: &'static str = "ContentPacket";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.current_packets_total = is.read_int64()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.media)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.current_packets_total != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.current_packets_total);
        }
        if let Some(v) = self.media.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.current_packets_total != 0 {
            os.write_int64(1, self.current_packets_total)?;
        }
        if let Some(v) = self.media.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ContentPacket {
        ContentPacket::new()
    }

    fn clear(&mut self) {
        self.current_packets_total = 0;
        self.media.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ContentPacket {
        static instance: ContentPacket = ContentPacket {
            current_packets_total: 0,
            media: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ContentPacket {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ContentPacket").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ContentPacket {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContentPacket {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:global.Space)
pub struct Space {
    // message fields
    // @@protoc_insertion_point(field:global.Space.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:global.Space.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:global.Space.description)
    pub description: ::std::string::String,
    // @@protoc_insertion_point(field:global.Space.type)
    pub type_: ::protobuf::EnumOrUnknown<SpaceType>,
    // @@protoc_insertion_point(field:global.Space.sub_type)
    pub sub_type: ::protobuf::EnumOrUnknown<SpaceSubType>,
    // @@protoc_insertion_point(field:global.Space.guest_capacity)
    pub guest_capacity: i32,
    // @@protoc_insertion_point(field:global.Space.size)
    pub size: ::protobuf::MessageField<Size>,
    // @@protoc_insertion_point(field:global.Space.level)
    pub level: i64,
    // @@protoc_insertion_point(field:global.Space.media)
    pub media: ::std::vec::Vec<Content>,
    // @@protoc_insertion_point(field:global.Space.amenities)
    pub amenities: ::std::vec::Vec<Amenity>,
    ///  Some spaces have inner inner spaces such as a master bedroom 
    ///  having a  bathroom.
    // @@protoc_insertion_point(field:global.Space.spaces)
    pub spaces: ::std::vec::Vec<Space>,
    ///  data is used to store the specific data for a space type.
    // @@protoc_insertion_point(field:global.Space.attributes)
    pub attributes: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:global.Space.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Space {
    fn default() -> &'a Space {
        <Space as ::protobuf::Message>::default_instance()
    }
}

impl Space {
    pub fn new() -> Space {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Space| { &m.id },
            |m: &mut Space| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &Space| { &m.name },
            |m: &mut Space| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "description",
            |m: &Space| { &m.description },
            |m: &mut Space| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &Space| { &m.type_ },
            |m: &mut Space| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sub_type",
            |m: &Space| { &m.sub_type },
            |m: &mut Space| { &mut m.sub_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "guest_capacity",
            |m: &Space| { &m.guest_capacity },
            |m: &mut Space| { &mut m.guest_capacity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Size>(
            "size",
            |m: &Space| { &m.size },
            |m: &mut Space| { &mut m.size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "level",
            |m: &Space| { &m.level },
            |m: &mut Space| { &mut m.level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "media",
            |m: &Space| { &m.media },
            |m: &mut Space| { &mut m.media },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "amenities",
            |m: &Space| { &m.amenities },
            |m: &mut Space| { &mut m.amenities },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "spaces",
            |m: &Space| { &m.spaces },
            |m: &mut Space| { &mut m.spaces },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "attributes",
            |m: &Space| { &m.attributes },
            |m: &mut Space| { &mut m.attributes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Space>(
            "Space",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Space {
    const NAME: &'static str = "Space";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                26 => {
                    self.description = is.read_string()?;
                },
                32 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                40 => {
                    self.sub_type = is.read_enum_or_unknown()?;
                },
                48 => {
                    self.guest_capacity = is.read_int32()?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.size)?;
                },
                64 => {
                    self.level = is.read_int64()?;
                },
                74 => {
                    self.media.push(is.read_message()?);
                },
                82 => {
                    self.amenities.push(is.read_message()?);
                },
                90 => {
                    self.spaces.push(is.read_message()?);
                },
                122 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.attributes.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.description);
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(SpaceType::SPACE_TYPE_UNSPECIFIED) {
            my_size += ::protobuf::rt::int32_size(4, self.type_.value());
        }
        if self.sub_type != ::protobuf::EnumOrUnknown::new(SpaceSubType::SPACE_SUB_TYPE_UNSPECIFIED) {
            my_size += ::protobuf::rt::int32_size(5, self.sub_type.value());
        }
        if self.guest_capacity != 0 {
            my_size += ::protobuf::rt::int32_size(6, self.guest_capacity);
        }
        if let Some(v) = self.size.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.level != 0 {
            my_size += ::protobuf::rt::int64_size(8, self.level);
        }
        for value in &self.media {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.amenities {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.spaces {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for (k, v) in &self.attributes {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.description.is_empty() {
            os.write_string(3, &self.description)?;
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(SpaceType::SPACE_TYPE_UNSPECIFIED) {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        if self.sub_type != ::protobuf::EnumOrUnknown::new(SpaceSubType::SPACE_SUB_TYPE_UNSPECIFIED) {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&self.sub_type))?;
        }
        if self.guest_capacity != 0 {
            os.write_int32(6, self.guest_capacity)?;
        }
        if let Some(v) = self.size.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if self.level != 0 {
            os.write_int64(8, self.level)?;
        }
        for v in &self.media {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        for v in &self.amenities {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        };
        for v in &self.spaces {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        };
        for (k, v) in &self.attributes {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(122)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Space {
        Space::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.name.clear();
        self.description.clear();
        self.type_ = ::protobuf::EnumOrUnknown::new(SpaceType::SPACE_TYPE_UNSPECIFIED);
        self.sub_type = ::protobuf::EnumOrUnknown::new(SpaceSubType::SPACE_SUB_TYPE_UNSPECIFIED);
        self.guest_capacity = 0;
        self.size.clear();
        self.level = 0;
        self.media.clear();
        self.amenities.clear();
        self.spaces.clear();
        self.attributes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Space {
        static instance: ::protobuf::rt::Lazy<Space> = ::protobuf::rt::Lazy::new();
        instance.get(Space::new)
    }
}

impl ::protobuf::MessageFull for Space {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Space").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Space {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Space {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:global.Amenity)
pub struct Amenity {
    // message fields
    // @@protoc_insertion_point(field:global.Amenity.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:global.Amenity.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:global.Amenity.description)
    pub description: ::std::string::String,
    // @@protoc_insertion_point(field:global.Amenity.type)
    pub type_: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:global.Amenity.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Amenity {
    fn default() -> &'a Amenity {
        <Amenity as ::protobuf::Message>::default_instance()
    }
}

impl Amenity {
    pub fn new() -> Amenity {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Amenity| { &m.id },
            |m: &mut Amenity| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &Amenity| { &m.name },
            |m: &mut Amenity| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "description",
            |m: &Amenity| { &m.description },
            |m: &mut Amenity| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &Amenity| { &m.type_ },
            |m: &mut Amenity| { &mut m.type_ },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Amenity>(
            "Amenity",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Amenity {
    const NAME: &'static str = "Amenity";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                26 => {
                    self.description = is.read_string()?;
                },
                34 => {
                    self.type_ = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.description);
        }
        if !self.type_.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.type_);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.description.is_empty() {
            os.write_string(3, &self.description)?;
        }
        if !self.type_.is_empty() {
            os.write_string(4, &self.type_)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Amenity {
        Amenity::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.name.clear();
        self.description.clear();
        self.type_.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Amenity {
        static instance: Amenity = Amenity {
            id: ::std::string::String::new(),
            name: ::std::string::String::new(),
            description: ::std::string::String::new(),
            type_: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Amenity {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Amenity").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Amenity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Amenity {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:global.Size)
pub struct Size {
    // message fields
    // @@protoc_insertion_point(field:global.Size.width)
    pub width: i32,
    // @@protoc_insertion_point(field:global.Size.length)
    pub length: i32,
    // @@protoc_insertion_point(field:global.Size.height)
    pub height: i32,
    // @@protoc_insertion_point(field:global.Size.depth)
    pub depth: i32,
    // special fields
    // @@protoc_insertion_point(special_field:global.Size.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Size {
    fn default() -> &'a Size {
        <Size as ::protobuf::Message>::default_instance()
    }
}

impl Size {
    pub fn new() -> Size {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "width",
            |m: &Size| { &m.width },
            |m: &mut Size| { &mut m.width },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "length",
            |m: &Size| { &m.length },
            |m: &mut Size| { &mut m.length },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "height",
            |m: &Size| { &m.height },
            |m: &mut Size| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "depth",
            |m: &Size| { &m.depth },
            |m: &mut Size| { &mut m.depth },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Size>(
            "Size",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Size {
    const NAME: &'static str = "Size";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.width = is.read_int32()?;
                },
                16 => {
                    self.length = is.read_int32()?;
                },
                24 => {
                    self.height = is.read_int32()?;
                },
                32 => {
                    self.depth = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.width != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.width);
        }
        if self.length != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.length);
        }
        if self.height != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.height);
        }
        if self.depth != 0 {
            my_size += ::protobuf::rt::int32_size(4, self.depth);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.width != 0 {
            os.write_int32(1, self.width)?;
        }
        if self.length != 0 {
            os.write_int32(2, self.length)?;
        }
        if self.height != 0 {
            os.write_int32(3, self.height)?;
        }
        if self.depth != 0 {
            os.write_int32(4, self.depth)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Size {
        Size::new()
    }

    fn clear(&mut self) {
        self.width = 0;
        self.length = 0;
        self.height = 0;
        self.depth = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Size {
        static instance: Size = Size {
            width: 0,
            length: 0,
            height: 0,
            depth: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Size {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Size").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Size {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Size {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:global.ExperienceConfirmationsRequest)
pub struct ExperienceConfirmationsRequest {
    // message fields
    // @@protoc_insertion_point(field:global.ExperienceConfirmationsRequest.journey_id)
    pub journey_id: ::std::string::String,
    // @@protoc_insertion_point(field:global.ExperienceConfirmationsRequest.confirmations)
    pub confirmations: ::std::vec::Vec<Confirmation>,
    // special fields
    // @@protoc_insertion_point(special_field:global.ExperienceConfirmationsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ExperienceConfirmationsRequest {
    fn default() -> &'a ExperienceConfirmationsRequest {
        <ExperienceConfirmationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ExperienceConfirmationsRequest {
    pub fn new() -> ExperienceConfirmationsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "journey_id",
            |m: &ExperienceConfirmationsRequest| { &m.journey_id },
            |m: &mut ExperienceConfirmationsRequest| { &mut m.journey_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "confirmations",
            |m: &ExperienceConfirmationsRequest| { &m.confirmations },
            |m: &mut ExperienceConfirmationsRequest| { &mut m.confirmations },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ExperienceConfirmationsRequest>(
            "ExperienceConfirmationsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ExperienceConfirmationsRequest {
    const NAME: &'static str = "ExperienceConfirmationsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.journey_id = is.read_string()?;
                },
                18 => {
                    self.confirmations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.journey_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.journey_id);
        }
        for value in &self.confirmations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.journey_id.is_empty() {
            os.write_string(1, &self.journey_id)?;
        }
        for v in &self.confirmations {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ExperienceConfirmationsRequest {
        ExperienceConfirmationsRequest::new()
    }

    fn clear(&mut self) {
        self.journey_id.clear();
        self.confirmations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ExperienceConfirmationsRequest {
        static instance: ExperienceConfirmationsRequest = ExperienceConfirmationsRequest {
            journey_id: ::std::string::String::new(),
            confirmations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ExperienceConfirmationsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ExperienceConfirmationsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ExperienceConfirmationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExperienceConfirmationsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:global.ExperienceConfirmationsResponse)
pub struct ExperienceConfirmationsResponse {
    // message fields
    // @@protoc_insertion_point(field:global.ExperienceConfirmationsResponse.journey_id)
    pub journey_id: ::std::string::String,
    // @@protoc_insertion_point(field:global.ExperienceConfirmationsResponse.confirmations)
    pub confirmations: ::std::vec::Vec<Confirmation>,
    // special fields
    // @@protoc_insertion_point(special_field:global.ExperienceConfirmationsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ExperienceConfirmationsResponse {
    fn default() -> &'a ExperienceConfirmationsResponse {
        <ExperienceConfirmationsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ExperienceConfirmationsResponse {
    pub fn new() -> ExperienceConfirmationsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "journey_id",
            |m: &ExperienceConfirmationsResponse| { &m.journey_id },
            |m: &mut ExperienceConfirmationsResponse| { &mut m.journey_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "confirmations",
            |m: &ExperienceConfirmationsResponse| { &m.confirmations },
            |m: &mut ExperienceConfirmationsResponse| { &mut m.confirmations },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ExperienceConfirmationsResponse>(
            "ExperienceConfirmationsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ExperienceConfirmationsResponse {
    const NAME: &'static str = "ExperienceConfirmationsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.journey_id = is.read_string()?;
                },
                18 => {
                    self.confirmations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.journey_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.journey_id);
        }
        for value in &self.confirmations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.journey_id.is_empty() {
            os.write_string(1, &self.journey_id)?;
        }
        for v in &self.confirmations {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ExperienceConfirmationsResponse {
        ExperienceConfirmationsResponse::new()
    }

    fn clear(&mut self) {
        self.journey_id.clear();
        self.confirmations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ExperienceConfirmationsResponse {
        static instance: ExperienceConfirmationsResponse = ExperienceConfirmationsResponse {
            journey_id: ::std::string::String::new(),
            confirmations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ExperienceConfirmationsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ExperienceConfirmationsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ExperienceConfirmationsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExperienceConfirmationsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:global.ConfirmationStatus)
pub enum ConfirmationStatus {
    // @@protoc_insertion_point(enum_value:global.ConfirmationStatus.CONFIRMATION_STATUS_UNSPECIFIED)
    CONFIRMATION_STATUS_UNSPECIFIED = 0,
    // @@protoc_insertion_point(enum_value:global.ConfirmationStatus.CONFIRMATION_STATUS_INITIATED)
    CONFIRMATION_STATUS_INITIATED = 2,
    // @@protoc_insertion_point(enum_value:global.ConfirmationStatus.CONFIRMATION_STATUS_PENDING)
    CONFIRMATION_STATUS_PENDING = 3,
    // @@protoc_insertion_point(enum_value:global.ConfirmationStatus.CONFIRMATION_STATUS_CONFIRMED)
    CONFIRMATION_STATUS_CONFIRMED = 4,
    // @@protoc_insertion_point(enum_value:global.ConfirmationStatus.CONFIRMATION_STATUS_CANCELLED)
    CONFIRMATION_STATUS_CANCELLED = 5,
}

impl ::protobuf::Enum for ConfirmationStatus {
    const NAME: &'static str = "ConfirmationStatus";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ConfirmationStatus> {
        match value {
            0 => ::std::option::Option::Some(ConfirmationStatus::CONFIRMATION_STATUS_UNSPECIFIED),
            2 => ::std::option::Option::Some(ConfirmationStatus::CONFIRMATION_STATUS_INITIATED),
            3 => ::std::option::Option::Some(ConfirmationStatus::CONFIRMATION_STATUS_PENDING),
            4 => ::std::option::Option::Some(ConfirmationStatus::CONFIRMATION_STATUS_CONFIRMED),
            5 => ::std::option::Option::Some(ConfirmationStatus::CONFIRMATION_STATUS_CANCELLED),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ConfirmationStatus] = &[
        ConfirmationStatus::CONFIRMATION_STATUS_UNSPECIFIED,
        ConfirmationStatus::CONFIRMATION_STATUS_INITIATED,
        ConfirmationStatus::CONFIRMATION_STATUS_PENDING,
        ConfirmationStatus::CONFIRMATION_STATUS_CONFIRMED,
        ConfirmationStatus::CONFIRMATION_STATUS_CANCELLED,
    ];
}

impl ::protobuf::EnumFull for ConfirmationStatus {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ConfirmationStatus").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            ConfirmationStatus::CONFIRMATION_STATUS_UNSPECIFIED => 0,
            ConfirmationStatus::CONFIRMATION_STATUS_INITIATED => 1,
            ConfirmationStatus::CONFIRMATION_STATUS_PENDING => 2,
            ConfirmationStatus::CONFIRMATION_STATUS_CONFIRMED => 3,
            ConfirmationStatus::CONFIRMATION_STATUS_CANCELLED => 4,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ConfirmationStatus {
    fn default() -> Self {
        ConfirmationStatus::CONFIRMATION_STATUS_UNSPECIFIED
    }
}

impl ConfirmationStatus {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ConfirmationStatus>("ConfirmationStatus")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:global.Currency)
pub enum Currency {
    // @@protoc_insertion_point(enum_value:global.Currency.CURRENCY_UNSPECIFIED)
    CURRENCY_UNSPECIFIED = 0,
    // @@protoc_insertion_point(enum_value:global.Currency.CURRENCY_USD)
    CURRENCY_USD = 1,
    // @@protoc_insertion_point(enum_value:global.Currency.CURRENCY_EUR)
    CURRENCY_EUR = 2,
    // @@protoc_insertion_point(enum_value:global.Currency.CURRENCY_XCD)
    CURRENCY_XCD = 3,
}

impl ::protobuf::Enum for Currency {
    const NAME: &'static str = "Currency";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Currency> {
        match value {
            0 => ::std::option::Option::Some(Currency::CURRENCY_UNSPECIFIED),
            1 => ::std::option::Option::Some(Currency::CURRENCY_USD),
            2 => ::std::option::Option::Some(Currency::CURRENCY_EUR),
            3 => ::std::option::Option::Some(Currency::CURRENCY_XCD),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [Currency] = &[
        Currency::CURRENCY_UNSPECIFIED,
        Currency::CURRENCY_USD,
        Currency::CURRENCY_EUR,
        Currency::CURRENCY_XCD,
    ];
}

impl ::protobuf::EnumFull for Currency {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("Currency").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for Currency {
    fn default() -> Self {
        Currency::CURRENCY_UNSPECIFIED
    }
}

impl Currency {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Currency>("Currency")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:global.RateFrequency)
pub enum RateFrequency {
    // @@protoc_insertion_point(enum_value:global.RateFrequency.RATE_FREQUENCY_UNSPECIFIED)
    RATE_FREQUENCY_UNSPECIFIED = 0,
    // @@protoc_insertion_point(enum_value:global.RateFrequency.RATE_FREQUENCY_ONCE)
    RATE_FREQUENCY_ONCE = 1,
    // @@protoc_insertion_point(enum_value:global.RateFrequency.RATE_FREQUENCY_DAILY)
    RATE_FREQUENCY_DAILY = 2,
    // @@protoc_insertion_point(enum_value:global.RateFrequency.RATE_FREQUENCY_WEEKLY)
    RATE_FREQUENCY_WEEKLY = 3,
    // @@protoc_insertion_point(enum_value:global.RateFrequency.RATE_FREQUENCY_BIWEEKLY)
    RATE_FREQUENCY_BIWEEKLY = 4,
    // @@protoc_insertion_point(enum_value:global.RateFrequency.RATE_FREQUENCY_MONTHLY)
    RATE_FREQUENCY_MONTHLY = 5,
    // @@protoc_insertion_point(enum_value:global.RateFrequency.RATE_FREQUENCY_QUARTERLY)
    RATE_FREQUENCY_QUARTERLY = 6,
    // @@protoc_insertion_point(enum_value:global.RateFrequency.RATE_FREQUENCY_SEMIANNUALLY)
    RATE_FREQUENCY_SEMIANNUALLY = 7,
    // @@protoc_insertion_point(enum_value:global.RateFrequency.RATE_FREQUENCY_ANNUALLY)
    RATE_FREQUENCY_ANNUALLY = 8,
    // @@protoc_insertion_point(enum_value:global.RateFrequency.RATE_FREQUENCY_CUSTOM)
    RATE_FREQUENCY_CUSTOM = 9,
}

impl ::protobuf::Enum for RateFrequency {
    const NAME: &'static str = "RateFrequency";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RateFrequency> {
        match value {
            0 => ::std::option::Option::Some(RateFrequency::RATE_FREQUENCY_UNSPECIFIED),
            1 => ::std::option::Option::Some(RateFrequency::RATE_FREQUENCY_ONCE),
            2 => ::std::option::Option::Some(RateFrequency::RATE_FREQUENCY_DAILY),
            3 => ::std::option::Option::Some(RateFrequency::RATE_FREQUENCY_WEEKLY),
            4 => ::std::option::Option::Some(RateFrequency::RATE_FREQUENCY_BIWEEKLY),
            5 => ::std::option::Option::Some(RateFrequency::RATE_FREQUENCY_MONTHLY),
            6 => ::std::option::Option::Some(RateFrequency::RATE_FREQUENCY_QUARTERLY),
            7 => ::std::option::Option::Some(RateFrequency::RATE_FREQUENCY_SEMIANNUALLY),
            8 => ::std::option::Option::Some(RateFrequency::RATE_FREQUENCY_ANNUALLY),
            9 => ::std::option::Option::Some(RateFrequency::RATE_FREQUENCY_CUSTOM),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [RateFrequency] = &[
        RateFrequency::RATE_FREQUENCY_UNSPECIFIED,
        RateFrequency::RATE_FREQUENCY_ONCE,
        RateFrequency::RATE_FREQUENCY_DAILY,
        RateFrequency::RATE_FREQUENCY_WEEKLY,
        RateFrequency::RATE_FREQUENCY_BIWEEKLY,
        RateFrequency::RATE_FREQUENCY_MONTHLY,
        RateFrequency::RATE_FREQUENCY_QUARTERLY,
        RateFrequency::RATE_FREQUENCY_SEMIANNUALLY,
        RateFrequency::RATE_FREQUENCY_ANNUALLY,
        RateFrequency::RATE_FREQUENCY_CUSTOM,
    ];
}

impl ::protobuf::EnumFull for RateFrequency {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("RateFrequency").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for RateFrequency {
    fn default() -> Self {
        RateFrequency::RATE_FREQUENCY_UNSPECIFIED
    }
}

impl RateFrequency {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<RateFrequency>("RateFrequency")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:global.RateType)
pub enum RateType {
    // @@protoc_insertion_point(enum_value:global.RateType.RATE_TYPE_UNSPECIFIED)
    RATE_TYPE_UNSPECIFIED = 0,
    // @@protoc_insertion_point(enum_value:global.RateType.RATE_TYPE_EXPERIENCE)
    RATE_TYPE_EXPERIENCE = 1,
    // @@protoc_insertion_point(enum_value:global.RateType.RATE_TYPE_TAX)
    RATE_TYPE_TAX = 2,
    // @@protoc_insertion_point(enum_value:global.RateType.RATE_TYPE_DISCOUNT)
    RATE_TYPE_DISCOUNT = 3,
    // @@protoc_insertion_point(enum_value:global.RateType.RATE_TYPE_EXPERIENCE_FEE)
    RATE_TYPE_EXPERIENCE_FEE = 4,
    // @@protoc_insertion_point(enum_value:global.RateType.RATE_TYPE_DEPOSIT)
    RATE_TYPE_DEPOSIT = 5,
    // @@protoc_insertion_point(enum_value:global.RateType.RATE_TYPE_CREDIT)
    RATE_TYPE_CREDIT = 6,
    // @@protoc_insertion_point(enum_value:global.RateType.RATE_TYPE_ADJUSTMENT)
    RATE_TYPE_ADJUSTMENT = 7,
    // @@protoc_insertion_point(enum_value:global.RateType.RATE_TYPE_OTHER)
    RATE_TYPE_OTHER = 8,
}

impl ::protobuf::Enum for RateType {
    const NAME: &'static str = "RateType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RateType> {
        match value {
            0 => ::std::option::Option::Some(RateType::RATE_TYPE_UNSPECIFIED),
            1 => ::std::option::Option::Some(RateType::RATE_TYPE_EXPERIENCE),
            2 => ::std::option::Option::Some(RateType::RATE_TYPE_TAX),
            3 => ::std::option::Option::Some(RateType::RATE_TYPE_DISCOUNT),
            4 => ::std::option::Option::Some(RateType::RATE_TYPE_EXPERIENCE_FEE),
            5 => ::std::option::Option::Some(RateType::RATE_TYPE_DEPOSIT),
            6 => ::std::option::Option::Some(RateType::RATE_TYPE_CREDIT),
            7 => ::std::option::Option::Some(RateType::RATE_TYPE_ADJUSTMENT),
            8 => ::std::option::Option::Some(RateType::RATE_TYPE_OTHER),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [RateType] = &[
        RateType::RATE_TYPE_UNSPECIFIED,
        RateType::RATE_TYPE_EXPERIENCE,
        RateType::RATE_TYPE_TAX,
        RateType::RATE_TYPE_DISCOUNT,
        RateType::RATE_TYPE_EXPERIENCE_FEE,
        RateType::RATE_TYPE_DEPOSIT,
        RateType::RATE_TYPE_CREDIT,
        RateType::RATE_TYPE_ADJUSTMENT,
        RateType::RATE_TYPE_OTHER,
    ];
}

impl ::protobuf::EnumFull for RateType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("RateType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for RateType {
    fn default() -> Self {
        RateType::RATE_TYPE_UNSPECIFIED
    }
}

impl RateType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<RateType>("RateType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:global.ExperienceType)
pub enum ExperienceType {
    // @@protoc_insertion_point(enum_value:global.ExperienceType.EXPERIENCE_TYPE_UNSPECIFIED)
    EXPERIENCE_TYPE_UNSPECIFIED = 0,
    // @@protoc_insertion_point(enum_value:global.ExperienceType.EXPERIENCE_TYPE_STAY)
    EXPERIENCE_TYPE_STAY = 1,
    // @@protoc_insertion_point(enum_value:global.ExperienceType.EXPERIENCE_TYPE_EATS)
    EXPERIENCE_TYPE_EATS = 2,
    // @@protoc_insertion_point(enum_value:global.ExperienceType.EXPERIENCE_TYPE_ACTIVITY)
    EXPERIENCE_TYPE_ACTIVITY = 3,
    // @@protoc_insertion_point(enum_value:global.ExperienceType.EXPERIENCE_TYPE_EVENT)
    EXPERIENCE_TYPE_EVENT = 4,
    // @@protoc_insertion_point(enum_value:global.ExperienceType.EXPERIENCE_TYPE_CAR_RENTAL)
    EXPERIENCE_TYPE_CAR_RENTAL = 5,
    // @@protoc_insertion_point(enum_value:global.ExperienceType.EXPERIENCE_TYPE_RIDE)
    EXPERIENCE_TYPE_RIDE = 6,
    // @@protoc_insertion_point(enum_value:global.ExperienceType.EXPERIENCE_TYPE_FLIGHT)
    EXPERIENCE_TYPE_FLIGHT = 7,
    // @@protoc_insertion_point(enum_value:global.ExperienceType.EXPERIENCE_TYPE_SERVICE)
    EXPERIENCE_TYPE_SERVICE = 8,
}

impl ::protobuf::Enum for ExperienceType {
    const NAME: &'static str = "ExperienceType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ExperienceType> {
        match value {
            0 => ::std::option::Option::Some(ExperienceType::EXPERIENCE_TYPE_UNSPECIFIED),
            1 => ::std::option::Option::Some(ExperienceType::EXPERIENCE_TYPE_STAY),
            2 => ::std::option::Option::Some(ExperienceType::EXPERIENCE_TYPE_EATS),
            3 => ::std::option::Option::Some(ExperienceType::EXPERIENCE_TYPE_ACTIVITY),
            4 => ::std::option::Option::Some(ExperienceType::EXPERIENCE_TYPE_EVENT),
            5 => ::std::option::Option::Some(ExperienceType::EXPERIENCE_TYPE_CAR_RENTAL),
            6 => ::std::option::Option::Some(ExperienceType::EXPERIENCE_TYPE_RIDE),
            7 => ::std::option::Option::Some(ExperienceType::EXPERIENCE_TYPE_FLIGHT),
            8 => ::std::option::Option::Some(ExperienceType::EXPERIENCE_TYPE_SERVICE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ExperienceType] = &[
        ExperienceType::EXPERIENCE_TYPE_UNSPECIFIED,
        ExperienceType::EXPERIENCE_TYPE_STAY,
        ExperienceType::EXPERIENCE_TYPE_EATS,
        ExperienceType::EXPERIENCE_TYPE_ACTIVITY,
        ExperienceType::EXPERIENCE_TYPE_EVENT,
        ExperienceType::EXPERIENCE_TYPE_CAR_RENTAL,
        ExperienceType::EXPERIENCE_TYPE_RIDE,
        ExperienceType::EXPERIENCE_TYPE_FLIGHT,
        ExperienceType::EXPERIENCE_TYPE_SERVICE,
    ];
}

impl ::protobuf::EnumFull for ExperienceType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ExperienceType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ExperienceType {
    fn default() -> Self {
        ExperienceType::EXPERIENCE_TYPE_UNSPECIFIED
    }
}

impl ExperienceType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ExperienceType>("ExperienceType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:global.LocationType)
pub enum LocationType {
    // @@protoc_insertion_point(enum_value:global.LocationType.LOCATION_TYPE_UNSPECIFIED)
    LOCATION_TYPE_UNSPECIFIED = 0,
    // @@protoc_insertion_point(enum_value:global.LocationType.LOCATION_TYPE_BASE)
    LOCATION_TYPE_BASE = 1,
    // @@protoc_insertion_point(enum_value:global.LocationType.LOCATION_TYPE_IN_TRANSIT)
    LOCATION_TYPE_IN_TRANSIT = 2,
    // @@protoc_insertion_point(enum_value:global.LocationType.LOCATION_TYPE_IN_WAY_POINT)
    LOCATION_TYPE_IN_WAY_POINT = 3,
    // @@protoc_insertion_point(enum_value:global.LocationType.LOCATION_TYPE_DESTINATION)
    LOCATION_TYPE_DESTINATION = 4,
    // @@protoc_insertion_point(enum_value:global.LocationType.LOCATION_TYPE_PICKUP)
    LOCATION_TYPE_PICKUP = 5,
    // @@protoc_insertion_point(enum_value:global.LocationType.LOCATION_TYPE_DROPOFF)
    LOCATION_TYPE_DROPOFF = 6,
    // @@protoc_insertion_point(enum_value:global.LocationType.LOCATION_TYPE_OTHER)
    LOCATION_TYPE_OTHER = 7,
}

impl ::protobuf::Enum for LocationType {
    const NAME: &'static str = "LocationType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<LocationType> {
        match value {
            0 => ::std::option::Option::Some(LocationType::LOCATION_TYPE_UNSPECIFIED),
            1 => ::std::option::Option::Some(LocationType::LOCATION_TYPE_BASE),
            2 => ::std::option::Option::Some(LocationType::LOCATION_TYPE_IN_TRANSIT),
            3 => ::std::option::Option::Some(LocationType::LOCATION_TYPE_IN_WAY_POINT),
            4 => ::std::option::Option::Some(LocationType::LOCATION_TYPE_DESTINATION),
            5 => ::std::option::Option::Some(LocationType::LOCATION_TYPE_PICKUP),
            6 => ::std::option::Option::Some(LocationType::LOCATION_TYPE_DROPOFF),
            7 => ::std::option::Option::Some(LocationType::LOCATION_TYPE_OTHER),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [LocationType] = &[
        LocationType::LOCATION_TYPE_UNSPECIFIED,
        LocationType::LOCATION_TYPE_BASE,
        LocationType::LOCATION_TYPE_IN_TRANSIT,
        LocationType::LOCATION_TYPE_IN_WAY_POINT,
        LocationType::LOCATION_TYPE_DESTINATION,
        LocationType::LOCATION_TYPE_PICKUP,
        LocationType::LOCATION_TYPE_DROPOFF,
        LocationType::LOCATION_TYPE_OTHER,
    ];
}

impl ::protobuf::EnumFull for LocationType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("LocationType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for LocationType {
    fn default() -> Self {
        LocationType::LOCATION_TYPE_UNSPECIFIED
    }
}

impl LocationType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<LocationType>("LocationType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:global.Order)
pub enum Order {
    // @@protoc_insertion_point(enum_value:global.Order.ORDER_UNSPECIFIED)
    ORDER_UNSPECIFIED = 0,
    // @@protoc_insertion_point(enum_value:global.Order.ORDER_ASC)
    ORDER_ASC = 1,
    // @@protoc_insertion_point(enum_value:global.Order.ORDER_DESC)
    ORDER_DESC = 2,
}

impl ::protobuf::Enum for Order {
    const NAME: &'static str = "Order";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Order> {
        match value {
            0 => ::std::option::Option::Some(Order::ORDER_UNSPECIFIED),
            1 => ::std::option::Option::Some(Order::ORDER_ASC),
            2 => ::std::option::Option::Some(Order::ORDER_DESC),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [Order] = &[
        Order::ORDER_UNSPECIFIED,
        Order::ORDER_ASC,
        Order::ORDER_DESC,
    ];
}

impl ::protobuf::EnumFull for Order {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("Order").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for Order {
    fn default() -> Self {
        Order::ORDER_UNSPECIFIED
    }
}

impl Order {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Order>("Order")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:global.CreatorType)
pub enum CreatorType {
    // @@protoc_insertion_point(enum_value:global.CreatorType.CREATOR_TYPE_UNSPECIFIED)
    CREATOR_TYPE_UNSPECIFIED = 0,
    // @@protoc_insertion_point(enum_value:global.CreatorType.CREATOR_TYPE_GUEST)
    CREATOR_TYPE_GUEST = 1,
    // @@protoc_insertion_point(enum_value:global.CreatorType.CREATOR_TYPE_PARTNER)
    CREATOR_TYPE_PARTNER = 2,
    // @@protoc_insertion_point(enum_value:global.CreatorType.CREATOR_TYPE_CONCIERGE)
    CREATOR_TYPE_CONCIERGE = 3,
}

impl ::protobuf::Enum for CreatorType {
    const NAME: &'static str = "CreatorType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CreatorType> {
        match value {
            0 => ::std::option::Option::Some(CreatorType::CREATOR_TYPE_UNSPECIFIED),
            1 => ::std::option::Option::Some(CreatorType::CREATOR_TYPE_GUEST),
            2 => ::std::option::Option::Some(CreatorType::CREATOR_TYPE_PARTNER),
            3 => ::std::option::Option::Some(CreatorType::CREATOR_TYPE_CONCIERGE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [CreatorType] = &[
        CreatorType::CREATOR_TYPE_UNSPECIFIED,
        CreatorType::CREATOR_TYPE_GUEST,
        CreatorType::CREATOR_TYPE_PARTNER,
        CreatorType::CREATOR_TYPE_CONCIERGE,
    ];
}

impl ::protobuf::EnumFull for CreatorType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("CreatorType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for CreatorType {
    fn default() -> Self {
        CreatorType::CREATOR_TYPE_UNSPECIFIED
    }
}

impl CreatorType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<CreatorType>("CreatorType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:global.EntityType)
pub enum EntityType {
    // @@protoc_insertion_point(enum_value:global.EntityType.ENTITY_TYPE_UNSPECIFIED)
    ENTITY_TYPE_UNSPECIFIED = 0,
    // @@protoc_insertion_point(enum_value:global.EntityType.ENTITY_TYPE_GUEST)
    ENTITY_TYPE_GUEST = 1,
    // @@protoc_insertion_point(enum_value:global.EntityType.ENTITY_TYPE_PARTNER)
    ENTITY_TYPE_PARTNER = 2,
    // @@protoc_insertion_point(enum_value:global.EntityType.ENTITY_TYPE_EVENT)
    ENTITY_TYPE_EVENT = 3,
    // @@protoc_insertion_point(enum_value:global.EntityType.ENTITY_TYPE_PROJECT)
    ENTITY_TYPE_PROJECT = 4,
    // @@protoc_insertion_point(enum_value:global.EntityType.ENTITY_TYPE_RESOURCE)
    ENTITY_TYPE_RESOURCE = 5,
    // @@protoc_insertion_point(enum_value:global.EntityType.ENTITY_TYPE_NOTIFICATION)
    ENTITY_TYPE_NOTIFICATION = 6,
    // @@protoc_insertion_point(enum_value:global.EntityType.ENTITY_TYPE_JOURNEY)
    ENTITY_TYPE_JOURNEY = 7,
    // @@protoc_insertion_point(enum_value:global.EntityType.ENTITY_TYPE_EXPERIENCE)
    ENTITY_TYPE_EXPERIENCE = 8,
    // @@protoc_insertion_point(enum_value:global.EntityType.ENTITY_TYPE_QUALIFICATION)
    ENTITY_TYPE_QUALIFICATION = 9,
}

impl ::protobuf::Enum for EntityType {
    const NAME: &'static str = "EntityType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EntityType> {
        match value {
            0 => ::std::option::Option::Some(EntityType::ENTITY_TYPE_UNSPECIFIED),
            1 => ::std::option::Option::Some(EntityType::ENTITY_TYPE_GUEST),
            2 => ::std::option::Option::Some(EntityType::ENTITY_TYPE_PARTNER),
            3 => ::std::option::Option::Some(EntityType::ENTITY_TYPE_EVENT),
            4 => ::std::option::Option::Some(EntityType::ENTITY_TYPE_PROJECT),
            5 => ::std::option::Option::Some(EntityType::ENTITY_TYPE_RESOURCE),
            6 => ::std::option::Option::Some(EntityType::ENTITY_TYPE_NOTIFICATION),
            7 => ::std::option::Option::Some(EntityType::ENTITY_TYPE_JOURNEY),
            8 => ::std::option::Option::Some(EntityType::ENTITY_TYPE_EXPERIENCE),
            9 => ::std::option::Option::Some(EntityType::ENTITY_TYPE_QUALIFICATION),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EntityType] = &[
        EntityType::ENTITY_TYPE_UNSPECIFIED,
        EntityType::ENTITY_TYPE_GUEST,
        EntityType::ENTITY_TYPE_PARTNER,
        EntityType::ENTITY_TYPE_EVENT,
        EntityType::ENTITY_TYPE_PROJECT,
        EntityType::ENTITY_TYPE_RESOURCE,
        EntityType::ENTITY_TYPE_NOTIFICATION,
        EntityType::ENTITY_TYPE_JOURNEY,
        EntityType::ENTITY_TYPE_EXPERIENCE,
        EntityType::ENTITY_TYPE_QUALIFICATION,
    ];
}

impl ::protobuf::EnumFull for EntityType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EntityType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EntityType {
    fn default() -> Self {
        EntityType::ENTITY_TYPE_UNSPECIFIED
    }
}

impl EntityType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EntityType>("EntityType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:global.ResourceType)
pub enum ResourceType {
    // @@protoc_insertion_point(enum_value:global.ResourceType.RESOURCE_TYPE_UNSPECIFIED)
    RESOURCE_TYPE_UNSPECIFIED = 0,
    // @@protoc_insertion_point(enum_value:global.ResourceType.RESOURCE_TYPE_PROPERTY)
    RESOURCE_TYPE_PROPERTY = 1,
    // @@protoc_insertion_point(enum_value:global.ResourceType.RESOURCE_TYPE_VESSEL)
    RESOURCE_TYPE_VESSEL = 2,
    // @@protoc_insertion_point(enum_value:global.ResourceType.RESOURCE_TYPE_VEHICLE)
    RESOURCE_TYPE_VEHICLE = 3,
    // @@protoc_insertion_point(enum_value:global.ResourceType.RESOURCE_TYPE_AIRCRAFT)
    RESOURCE_TYPE_AIRCRAFT = 4,
    // @@protoc_insertion_point(enum_value:global.ResourceType.RESOURCE_TYPE_EQUIPMENT)
    RESOURCE_TYPE_EQUIPMENT = 5,
    // @@protoc_insertion_point(enum_value:global.ResourceType.RESOURCE_TYPE_MEMBER)
    RESOURCE_TYPE_MEMBER = 6,
    // @@protoc_insertion_point(enum_value:global.ResourceType.RESOURCE_TYPE_OTHER)
    RESOURCE_TYPE_OTHER = 14,
}

impl ::protobuf::Enum for ResourceType {
    const NAME: &'static str = "ResourceType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ResourceType> {
        match value {
            0 => ::std::option::Option::Some(ResourceType::RESOURCE_TYPE_UNSPECIFIED),
            1 => ::std::option::Option::Some(ResourceType::RESOURCE_TYPE_PROPERTY),
            2 => ::std::option::Option::Some(ResourceType::RESOURCE_TYPE_VESSEL),
            3 => ::std::option::Option::Some(ResourceType::RESOURCE_TYPE_VEHICLE),
            4 => ::std::option::Option::Some(ResourceType::RESOURCE_TYPE_AIRCRAFT),
            5 => ::std::option::Option::Some(ResourceType::RESOURCE_TYPE_EQUIPMENT),
            6 => ::std::option::Option::Some(ResourceType::RESOURCE_TYPE_MEMBER),
            14 => ::std::option::Option::Some(ResourceType::RESOURCE_TYPE_OTHER),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ResourceType] = &[
        ResourceType::RESOURCE_TYPE_UNSPECIFIED,
        ResourceType::RESOURCE_TYPE_PROPERTY,
        ResourceType::RESOURCE_TYPE_VESSEL,
        ResourceType::RESOURCE_TYPE_VEHICLE,
        ResourceType::RESOURCE_TYPE_AIRCRAFT,
        ResourceType::RESOURCE_TYPE_EQUIPMENT,
        ResourceType::RESOURCE_TYPE_MEMBER,
        ResourceType::RESOURCE_TYPE_OTHER,
    ];
}

impl ::protobuf::EnumFull for ResourceType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ResourceType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            ResourceType::RESOURCE_TYPE_UNSPECIFIED => 0,
            ResourceType::RESOURCE_TYPE_PROPERTY => 1,
            ResourceType::RESOURCE_TYPE_VESSEL => 2,
            ResourceType::RESOURCE_TYPE_VEHICLE => 3,
            ResourceType::RESOURCE_TYPE_AIRCRAFT => 4,
            ResourceType::RESOURCE_TYPE_EQUIPMENT => 5,
            ResourceType::RESOURCE_TYPE_MEMBER => 6,
            ResourceType::RESOURCE_TYPE_OTHER => 7,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ResourceType {
    fn default() -> Self {
        ResourceType::RESOURCE_TYPE_UNSPECIFIED
    }
}

impl ResourceType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ResourceType>("ResourceType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:global.Day)
pub enum Day {
    // @@protoc_insertion_point(enum_value:global.Day.DAY_UNSPECIFIED)
    DAY_UNSPECIFIED = 0,
    // @@protoc_insertion_point(enum_value:global.Day.DAY_SUNDAY)
    DAY_SUNDAY = 1,
    // @@protoc_insertion_point(enum_value:global.Day.DAY_MONDAY)
    DAY_MONDAY = 2,
    // @@protoc_insertion_point(enum_value:global.Day.DAY_TUESDAY)
    DAY_TUESDAY = 3,
    // @@protoc_insertion_point(enum_value:global.Day.DAY_WEDNESDAY)
    DAY_WEDNESDAY = 4,
    // @@protoc_insertion_point(enum_value:global.Day.DAY_THURSDAY)
    DAY_THURSDAY = 5,
    // @@protoc_insertion_point(enum_value:global.Day.DAY_FRIDAY)
    DAY_FRIDAY = 6,
    // @@protoc_insertion_point(enum_value:global.Day.DAY_SATURDAY)
    DAY_SATURDAY = 7,
}

impl ::protobuf::Enum for Day {
    const NAME: &'static str = "Day";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Day> {
        match value {
            0 => ::std::option::Option::Some(Day::DAY_UNSPECIFIED),
            1 => ::std::option::Option::Some(Day::DAY_SUNDAY),
            2 => ::std::option::Option::Some(Day::DAY_MONDAY),
            3 => ::std::option::Option::Some(Day::DAY_TUESDAY),
            4 => ::std::option::Option::Some(Day::DAY_WEDNESDAY),
            5 => ::std::option::Option::Some(Day::DAY_THURSDAY),
            6 => ::std::option::Option::Some(Day::DAY_FRIDAY),
            7 => ::std::option::Option::Some(Day::DAY_SATURDAY),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [Day] = &[
        Day::DAY_UNSPECIFIED,
        Day::DAY_SUNDAY,
        Day::DAY_MONDAY,
        Day::DAY_TUESDAY,
        Day::DAY_WEDNESDAY,
        Day::DAY_THURSDAY,
        Day::DAY_FRIDAY,
        Day::DAY_SATURDAY,
    ];
}

impl ::protobuf::EnumFull for Day {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("Day").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for Day {
    fn default() -> Self {
        Day::DAY_UNSPECIFIED
    }
}

impl Day {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Day>("Day")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:global.ContentType)
pub enum ContentType {
    // @@protoc_insertion_point(enum_value:global.ContentType.CONTENT_TYPE_UNSPECIFIED)
    CONTENT_TYPE_UNSPECIFIED = 0,
    // @@protoc_insertion_point(enum_value:global.ContentType.CONTENT_TYPE_IMAGE)
    CONTENT_TYPE_IMAGE = 1,
    // @@protoc_insertion_point(enum_value:global.ContentType.CONTENT_TYPE_VIDEO)
    CONTENT_TYPE_VIDEO = 2,
    // @@protoc_insertion_point(enum_value:global.ContentType.CONTENT_TYPE_AUDIO)
    CONTENT_TYPE_AUDIO = 3,
    // @@protoc_insertion_point(enum_value:global.ContentType.CONTENT_TYPE_DOCUMENT)
    CONTENT_TYPE_DOCUMENT = 4,
}

impl ::protobuf::Enum for ContentType {
    const NAME: &'static str = "ContentType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ContentType> {
        match value {
            0 => ::std::option::Option::Some(ContentType::CONTENT_TYPE_UNSPECIFIED),
            1 => ::std::option::Option::Some(ContentType::CONTENT_TYPE_IMAGE),
            2 => ::std::option::Option::Some(ContentType::CONTENT_TYPE_VIDEO),
            3 => ::std::option::Option::Some(ContentType::CONTENT_TYPE_AUDIO),
            4 => ::std::option::Option::Some(ContentType::CONTENT_TYPE_DOCUMENT),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ContentType] = &[
        ContentType::CONTENT_TYPE_UNSPECIFIED,
        ContentType::CONTENT_TYPE_IMAGE,
        ContentType::CONTENT_TYPE_VIDEO,
        ContentType::CONTENT_TYPE_AUDIO,
        ContentType::CONTENT_TYPE_DOCUMENT,
    ];
}

impl ::protobuf::EnumFull for ContentType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ContentType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ContentType {
    fn default() -> Self {
        ContentType::CONTENT_TYPE_UNSPECIFIED
    }
}

impl ContentType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ContentType>("ContentType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:global.SpaceType)
pub enum SpaceType {
    // @@protoc_insertion_point(enum_value:global.SpaceType.SPACE_TYPE_UNSPECIFIED)
    SPACE_TYPE_UNSPECIFIED = 0,
    // @@protoc_insertion_point(enum_value:global.SpaceType.SPACE_TYPE_BEDROOM)
    SPACE_TYPE_BEDROOM = 1,
    // @@protoc_insertion_point(enum_value:global.SpaceType.SPACE_TYPE_BATHROOM)
    SPACE_TYPE_BATHROOM = 2,
    // @@protoc_insertion_point(enum_value:global.SpaceType.SPACE_TYPE_KITCHEN)
    SPACE_TYPE_KITCHEN = 3,
    // @@protoc_insertion_point(enum_value:global.SpaceType.SPACE_TYPE_LIVING)
    SPACE_TYPE_LIVING = 4,
    // @@protoc_insertion_point(enum_value:global.SpaceType.SPACE_TYPE_POOL)
    SPACE_TYPE_POOL = 5,
    // @@protoc_insertion_point(enum_value:global.SpaceType.SPACE_TYPE_AREA)
    SPACE_TYPE_AREA = 6,
    // @@protoc_insertion_point(enum_value:global.SpaceType.SPACE_TYPE_SEAT)
    SPACE_TYPE_SEAT = 7,
    // @@protoc_insertion_point(enum_value:global.SpaceType.SPACE_TYPE_LOFT)
    SPACE_TYPE_LOFT = 8,
    // @@protoc_insertion_point(enum_value:global.SpaceType.SPACE_TYPE_DECK)
    SPACE_TYPE_DECK = 9,
}

impl ::protobuf::Enum for SpaceType {
    const NAME: &'static str = "SpaceType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SpaceType> {
        match value {
            0 => ::std::option::Option::Some(SpaceType::SPACE_TYPE_UNSPECIFIED),
            1 => ::std::option::Option::Some(SpaceType::SPACE_TYPE_BEDROOM),
            2 => ::std::option::Option::Some(SpaceType::SPACE_TYPE_BATHROOM),
            3 => ::std::option::Option::Some(SpaceType::SPACE_TYPE_KITCHEN),
            4 => ::std::option::Option::Some(SpaceType::SPACE_TYPE_LIVING),
            5 => ::std::option::Option::Some(SpaceType::SPACE_TYPE_POOL),
            6 => ::std::option::Option::Some(SpaceType::SPACE_TYPE_AREA),
            7 => ::std::option::Option::Some(SpaceType::SPACE_TYPE_SEAT),
            8 => ::std::option::Option::Some(SpaceType::SPACE_TYPE_LOFT),
            9 => ::std::option::Option::Some(SpaceType::SPACE_TYPE_DECK),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [SpaceType] = &[
        SpaceType::SPACE_TYPE_UNSPECIFIED,
        SpaceType::SPACE_TYPE_BEDROOM,
        SpaceType::SPACE_TYPE_BATHROOM,
        SpaceType::SPACE_TYPE_KITCHEN,
        SpaceType::SPACE_TYPE_LIVING,
        SpaceType::SPACE_TYPE_POOL,
        SpaceType::SPACE_TYPE_AREA,
        SpaceType::SPACE_TYPE_SEAT,
        SpaceType::SPACE_TYPE_LOFT,
        SpaceType::SPACE_TYPE_DECK,
    ];
}

impl ::protobuf::EnumFull for SpaceType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("SpaceType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for SpaceType {
    fn default() -> Self {
        SpaceType::SPACE_TYPE_UNSPECIFIED
    }
}

impl SpaceType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<SpaceType>("SpaceType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:global.SpaceSubType)
pub enum SpaceSubType {
    // @@protoc_insertion_point(enum_value:global.SpaceSubType.SPACE_SUB_TYPE_UNSPECIFIED)
    SPACE_SUB_TYPE_UNSPECIFIED = 0,
    // @@protoc_insertion_point(enum_value:global.SpaceSubType.SPACE_SUB_TYPE_PARKING)
    SPACE_SUB_TYPE_PARKING = 1,
    // @@protoc_insertion_point(enum_value:global.SpaceSubType.SPACE_SUB_TYPE_ROOM)
    SPACE_SUB_TYPE_ROOM = 2,
    // @@protoc_insertion_point(enum_value:global.SpaceSubType.SPACE_SUB_TYPE_PENTHOUSE)
    SPACE_SUB_TYPE_PENTHOUSE = 3,
    // @@protoc_insertion_point(enum_value:global.SpaceSubType.SPACE_SUB_TYPE_ROOF)
    SPACE_SUB_TYPE_ROOF = 4,
    // @@protoc_insertion_point(enum_value:global.SpaceSubType.SPACE_SUB_TYPE_GROUND)
    SPACE_SUB_TYPE_GROUND = 5,
    // @@protoc_insertion_point(enum_value:global.SpaceSubType.SPACE_SUB_TYPE_BASEMENT)
    SPACE_SUB_TYPE_BASEMENT = 6,
    // @@protoc_insertion_point(enum_value:global.SpaceSubType.SPACE_SUB_TYPE_LOBBY)
    SPACE_SUB_TYPE_LOBBY = 7,
    // @@protoc_insertion_point(enum_value:global.SpaceSubType.SPACE_SUB_TYPE_STORY)
    SPACE_SUB_TYPE_STORY = 8,
}

impl ::protobuf::Enum for SpaceSubType {
    const NAME: &'static str = "SpaceSubType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SpaceSubType> {
        match value {
            0 => ::std::option::Option::Some(SpaceSubType::SPACE_SUB_TYPE_UNSPECIFIED),
            1 => ::std::option::Option::Some(SpaceSubType::SPACE_SUB_TYPE_PARKING),
            2 => ::std::option::Option::Some(SpaceSubType::SPACE_SUB_TYPE_ROOM),
            3 => ::std::option::Option::Some(SpaceSubType::SPACE_SUB_TYPE_PENTHOUSE),
            4 => ::std::option::Option::Some(SpaceSubType::SPACE_SUB_TYPE_ROOF),
            5 => ::std::option::Option::Some(SpaceSubType::SPACE_SUB_TYPE_GROUND),
            6 => ::std::option::Option::Some(SpaceSubType::SPACE_SUB_TYPE_BASEMENT),
            7 => ::std::option::Option::Some(SpaceSubType::SPACE_SUB_TYPE_LOBBY),
            8 => ::std::option::Option::Some(SpaceSubType::SPACE_SUB_TYPE_STORY),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [SpaceSubType] = &[
        SpaceSubType::SPACE_SUB_TYPE_UNSPECIFIED,
        SpaceSubType::SPACE_SUB_TYPE_PARKING,
        SpaceSubType::SPACE_SUB_TYPE_ROOM,
        SpaceSubType::SPACE_SUB_TYPE_PENTHOUSE,
        SpaceSubType::SPACE_SUB_TYPE_ROOF,
        SpaceSubType::SPACE_SUB_TYPE_GROUND,
        SpaceSubType::SPACE_SUB_TYPE_BASEMENT,
        SpaceSubType::SPACE_SUB_TYPE_LOBBY,
        SpaceSubType::SPACE_SUB_TYPE_STORY,
    ];
}

impl ::protobuf::EnumFull for SpaceSubType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("SpaceSubType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for SpaceSubType {
    fn default() -> Self {
        SpaceSubType::SPACE_SUB_TYPE_UNSPECIFIED
    }
}

impl SpaceSubType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<SpaceSubType>("SpaceSubType")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0cglobal.proto\x12\x06global\"\xcc\x03\n\x08Customer\x12\x0e\n\x02id\
    \x18\x01\x20\x01(\tR\x02id\x12\x1b\n\tuser_name\x18\x02\x20\x01(\tR\x08u\
    serName\x12\x1d\n\nfirst_name\x18\x03\x20\x01(\tR\tfirstName\x12\x1b\n\t\
    last_name\x18\x04\x20\x01(\tR\x08lastName\x12\x14\n\x05email\x18\x05\x20\
    \x01(\tR\x05email\x12\x14\n\x05phone\x18\x06\x20\x01(\tR\x05phone\x12\"\
    \n\rdate_of_birth\x18\x07\x20\x01(\x03R\x0bdateOfBirth\x12\x1d\n\ncreate\
    d_at\x18\x08\x20\x01(\x03R\tcreatedAt\x12\x1d\n\nupdated_at\x18\t\x20\
    \x01(\x03R\tupdatedAt\x12\x1d\n\ndeleted_at\x18\n\x20\x01(\x03R\tdeleted\
    At\x12)\n\x07address\x18\x0b\x20\x01(\x0b2\x0f.global.AddressR\x07addres\
    s\x12*\n\x11profile_image_url\x18\x0c\x20\x01(\tR\x0fprofileImageUrl\x12\
    \x19\n\x08role_ids\x18\x10\x20\x03(\tR\x07roleIds\x12\x1d\n\npolicy_ids\
    \x18\x11\x20\x03(\tR\tpolicyIds\x12\x19\n\x08crew_ids\x18\x12\x20\x03(\t\
    R\x07crewIds\"\xa1\x05\n\nExperience\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\
    \x02id\x12\x1d\n\npartner_id\x18\x02\x20\x01(\tR\tpartnerId\x12\x12\n\
    \x04name\x18\x03\x20\x01(\tR\x04name\x12\x20\n\x0bdescription\x18\x04\
    \x20\x01(\tR\x0bdescription\x12*\n\x04type\x18\x05\x20\x01(\x0e2\x16.glo\
    bal.ExperienceTypeR\x04type\x12%\n\x05media\x18\x06\x20\x03(\x0b2\x0f.gl\
    obal.ContentR\x05media\x12\x1d\n\nstart_date\x18\x07\x20\x01(\x03R\tstar\
    tDate\x12\x19\n\x08end_date\x18\x08\x20\x01(\x03R\x07endDate\x12\x12\n\
    \x04tags\x18\t\x20\x03(\tR\x04tags\x12\"\n\x05rules\x18\n\x20\x03(\x0b2\
    \x0c.global.RuleR\x05rules\x12\"\n\x05rates\x18\x0b\x20\x03(\x0b2\x0c.gl\
    obal.RateR\x05rates\x12+\n\x08features\x18\x0c\x20\x03(\x0b2\x0f.global.\
    FeatureR\x08features\x12%\n\x06spaces\x18\r\x20\x03(\x0b2\r.global.Space\
    R\x06spaces\x124\n\x0bimpressions\x18\x0e\x20\x03(\x0b2\x12.global.Impre\
    ssionR\x0bimpressions\x12+\n\x08comments\x18\x0f\x20\x03(\x0b2\x0f.globa\
    l.CommentR\x08comments\x12.\n\tlocations\x18\x10\x20\x03(\x0b2\x10.globa\
    l.LocationR\tlocations\x12.\n\tcalendars\x18\x11\x20\x03(\x0b2\x10.globa\
    l.CalendarR\tcalendars\x12.\n\tcustomers\x18\x12\x20\x03(\x0b2\x10.globa\
    l.CustomerR\tcustomers\"\xb7\x02\n\x0cConfirmation\x12#\n\rexperience_id\
    \x18\x01\x20\x01(\tR\x0cexperienceId\x12)\n\x10experience_total\x18\x02\
    \x20\x01(\x03R\x0fexperienceTotal\x12$\n\x0eshare_of_total\x18\x03\x20\
    \x01(\x03R\x0cshareOfTotal\x12*\n\x11payment_method_id\x18\x04\x20\x01(\
    \tR\x0fpaymentMethodId\x122\n\x06status\x18\x05\x20\x01(\x0e2\x1a.global\
    .ConfirmationStatusR\x06status\x12#\n\rclient_secret\x18\x06\x20\x01(\tR\
    \x0cclientSecret\x12,\n\x08currency\x18\x07\x20\x01(\x0e2\x10.global.Cur\
    rencyR\x08currency\"\x82\x02\n\x07Comment\x12\x0e\n\x02id\x18\x01\x20\
    \x01(\tR\x02id\x12\x19\n\x08owner_id\x18\x02\x20\x01(\tR\x07ownerId\x12\
    \x1d\n\npartner_id\x18\x03\x20\x01(\tR\tpartnerId\x12\x1b\n\tentity_id\
    \x18\x04\x20\x01(\tR\x08entityId\x12\x1f\n\x0bentity_type\x18\x05\x20\
    \x01(\tR\nentityType\x12\x12\n\x04body\x18\x06\x20\x01(\tR\x04body\x12\
    \x1d\n\ncreated_at\x18\x07\x20\x01(\tR\tcreatedAt\x12\x1d\n\nupdated_at\
    \x18\x08\x20\x01(\tR\tupdatedAt\x12\x1d\n\ndeleted_at\x18\t\x20\x01(\tR\
    \tdeletedAt\"\xc0\x01\n\x07Feature\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\
    \x02id\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\x20\n\x0bdescri\
    ption\x18\x03\x20\x01(\tR\x0bdescription\x12\x12\n\x04type\x18\x04\x20\
    \x01(\tR\x04type\x12\x1d\n\ncreated_at\x18\x05\x20\x01(\tR\tcreatedAt\
    \x12\x1d\n\nupdated_at\x18\x06\x20\x01(\tR\tupdatedAt\x12\x1d\n\ndeleted\
    _at\x18\x07\x20\x01(\tR\tdeletedAt\"\xa4\x04\n\x04Rate\x12\x0e\n\x02id\
    \x18\x01\x20\x01(\tR\x02id\x12\x1d\n\npartner_id\x18\x02\x20\x01(\tR\tpa\
    rtnerId\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12\x20\n\x0bdescr\
    iption\x18\x04\x20\x01(\tR\x0bdescription\x12\x20\n\x0bexperiences\x18\
    \x05\x20\x03(\tR\x0bexperiences\x12-\n\trate_type\x18\x06\x20\x01(\x0e2\
    \x10.global.RateTypeR\x08rateType\x12\x1d\n\nstart_date\x18\x07\x20\x01(\
    \x03R\tstartDate\x12\x19\n\x08end_date\x18\x08\x20\x01(\x03R\x07endDate\
    \x12\x16\n\x06amount\x18\t\x20\x01(\x03R\x06amount\x12,\n\x08currency\
    \x18\n\x20\x01(\x0e2\x10.global.CurrencyR\x08currency\x123\n\tfrequency\
    \x18\x0b\x20\x01(\x0e2\x15.global.RateFrequencyR\tfrequency\x126\n\x08me\
    tadata\x18\x0c\x20\x03(\x0b2\x1a.global.Rate.MetadataEntryR\x08metadata\
    \x12\x1d\n\ncreated_at\x18\r\x20\x01(\x03R\tcreatedAt\x12\x1d\n\nupdated\
    _at\x18\x0e\x20\x01(\x03R\tupdatedAt\x1a;\n\rMetadataEntry\x12\x10\n\x03\
    key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\
    \x05value:\x028\x01\"\x19\n\x07TaxRate\x12\x0e\n\x02id\x18\x01\x20\x01(\
    \tR\x02id\"\xef\x02\n\x0fTelematicUpdate\x12\x0e\n\x02id\x18\x01\x20\x01\
    (\tR\x02id\x12\x12\n\x04type\x18\x02\x20\x01(\tR\x04type\x12\x20\n\x0bde\
    scription\x18\x03\x20\x01(\tR\x0bdescription\x12\x1c\n\ttimestamp\x18\
    \x04\x20\x01(\x03R\ttimestamp\x12,\n\x08location\x18\x05\x20\x01(\x0b2\
    \x10.global.LocationR\x08location\x12$\n\x0eprev_update_id\x18\x06\x20\
    \x01(\tR\x0cprevUpdateId\x12$\n\x0enext_update_id\x18\x07\x20\x01(\tR\
    \x0cnextUpdateId\x12A\n\x08metadata\x18\x0f\x20\x03(\x0b2%.global.Telema\
    ticUpdate.MetadataEntryR\x08metadata\x1a;\n\rMetadataEntry\x12\x10\n\x03\
    key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\
    \x05value:\x028\x01\"\xc4\x01\n\x08Location\x12\x0e\n\x02id\x18\x01\x20\
    \x01(\tR\x02id\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\x20\n\
    \x0bdescription\x18\x03\x20\x01(\tR\x0bdescription\x12)\n\x07address\x18\
    \x04\x20\x01(\x0b2\x0f.global.AddressR\x07address\x12\x1d\n\x03geo\x18\
    \x05\x20\x01(\x0b2\x0b.global.GeoR\x03geo\x12(\n\x04type\x18\x06\x20\x01\
    (\x0e2\x14.global.LocationTypeR\x04type\"\xa7\x01\n\x03Geo\x12\x1a\n\x08\
    latitude\x18\x01\x20\x01(\x02R\x08latitude\x12\x1c\n\tlongitude\x18\x02\
    \x20\x01(\x02R\tlongitude\x12\x1a\n\x08altitude\x18\x03\x20\x01(\x02R\
    \x08altitude\x12\x14\n\x05speed\x18\x04\x20\x01(\x02R\x05speed\x12\x18\n\
    \x07heading\x18\x05\x20\x01(\x02R\x07heading\x12\x1a\n\x08accuracy\x18\
    \x06\x20\x01(\x02R\x08accuracy\"\x92\x01\n\x07Address\x12\x16\n\x06stree\
    t\x18\x01\x20\x01(\tR\x06street\x12\x19\n\x08street_2\x18\x02\x20\x01(\t\
    R\x07street2\x12\x12\n\x04city\x18\x03\x20\x01(\tR\x04city\x12\x14\n\x05\
    state\x18\x04\x20\x01(\tR\x05state\x12\x18\n\x07country\x18\x05\x20\x01(\
    \tR\x07country\x12\x10\n\x03zip\x18\x06\x20\x01(\tR\x03zip\"\x81\x01\n\
    \x05Query\x12\"\n\x05terms\x18\x01\x20\x03(\x0b2\x0c.global.TermR\x05ter\
    ms\x12\x12\n\x04page\x18\x02\x20\x01(\x05R\x04page\x12\x1b\n\tpage_size\
    \x18\x03\x20\x01(\x05R\x08pageSize\x12#\n\x05order\x18\x04\x20\x01(\x0e2\
    \r.global.OrderR\x05order\".\n\x04Term\x12\x10\n\x03key\x18\x01\x20\x01(\
    \tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value\"\xa7\x02\n\
    \x06Rating\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x19\n\x08guest_\
    id\x18\x02\x20\x01(\tR\x07guestId\x12\x1d\n\npartner_id\x18\x03\x20\x01(\
    \tR\tpartnerId\x12\x1d\n\nproject_id\x18\x04\x20\x01(\tR\tprojectId\x12\
    \x14\n\x05score\x18\x05\x20\x01(\x05R\x05score\x12\x18\n\x07comment\x18\
    \x06\x20\x01(\tR\x07comment\x12\x1d\n\ncreated_at\x18\x07\x20\x01(\tR\tc\
    reatedAt\x12\x1d\n\nupdated_at\x18\x08\x20\x01(\tR\tupdatedAt\x12\x1d\n\
    \ndeleted_at\x18\t\x20\x01(\tR\tdeletedAt\x12\x18\n\x06sample\x18\n\x20\
    \x01(\tH\0R\x06sampleB\r\n\x0brating_type\"`\n\nImpression\x12\x0e\n\x02\
    id\x18\x01\x20\x01(\tR\x02id\x12\x1a\n\x08duration\x18\x02\x20\x01(\x03R\
    \x08duration\x12&\n\x06source\x18\x03\x20\x01(\x0b2\x0e.global.SourceR\
    \x06source\"\x18\n\x06Source\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\"\
    \x95\x02\n\x08Calendar\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x19\
    \n\x08owner_id\x18\x02\x20\x01(\tR\x07ownerId\x12\x1f\n\x0bresource_id\
    \x18\x03\x20\x01(\tR\nresourceId\x12\x12\n\x04name\x18\x04\x20\x01(\tR\
    \x04name\x12\x20\n\x0bdescription\x18\x05\x20\x01(\tR\x0bdescription\x12\
    \x1d\n\ncreated_at\x18\x06\x20\x01(\x03R\tcreatedAt\x12\x1d\n\nupdated_a\
    t\x18\x07\x20\x01(\x03R\tupdatedAt\x12\"\n\x05rules\x18\x08\x20\x03(\x0b\
    2\x0c.global.RuleR\x05rules\x12%\n\x06events\x18\t\x20\x03(\x0b2\r.globa\
    l.EventR\x06events\"\x99\x01\n\x05Event\x12\x0e\n\x02id\x18\x01\x20\x01(\
    \tR\x02id\x12;\n\x10primary_calendar\x18\x02\x20\x01(\x0b2\x10.global.Ca\
    lendarR\x0fprimaryCalendar\x12C\n\x14associated_calendars\x18\x03\x20\
    \x03(\x0b2\x10.global.CalendarR\x13associatedCalendars\"\xe6\x01\n\x04No\
    te\x12\x19\n\x08guest_id\x18\x01\x20\x01(\tR\x07guestId\x12\x1d\n\npartn\
    er_id\x18\x02\x20\x01(\tR\tpartnerId\x12\x1d\n\nproject_id\x18\x03\x20\
    \x01(\tR\tprojectId\x12\x14\n\x05title\x18\x04\x20\x01(\tR\x05title\x12\
    \x12\n\x04body\x18\x05\x20\x01(\tR\x04body\x12\x1d\n\ncreated_at\x18\x06\
    \x20\x01(\tR\tcreatedAt\x12\x1d\n\nupdated_at\x18\x07\x20\x01(\tR\tupdat\
    edAt\x12\x1d\n\ndeleted_at\x18\x08\x20\x01(\tR\tdeletedAt\"S\n\x05Error\
    \x12\x12\n\x04code\x18\x01\x20\x01(\tR\x04code\x12\x18\n\x07message\x18\
    \x02\x20\x01(\tR\x07message\x12\x1c\n\ttimestamp\x18\x03\x20\x01(\x03R\t\
    timestamp\"\xde\x01\n\x04Rule\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\
    \x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\x20\n\x0bdescription\
    \x18\x03\x20\x01(\tR\x0bdescription\x12\x1d\n\nstart_time\x18\x04\x20\
    \x01(\x03R\tstartTime\x12\x19\n\x08end_time\x18\x05\x20\x01(\x03R\x07end\
    Time\x12,\n\tprincipal\x18\x06\x20\x01(\x0b2\x0e.global.EntityR\tprincip\
    al\x12(\n\x07options\x18\x07\x20\x03(\x0b2\x0e.global.OptionR\x07options\
    \"\x82\x01\n\x06Option\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\
    \x20\n\x0bdescription\x18\x02\x20\x01(\tR\x0bdescription\x12\x1a\n\x08re\
    quired\x18\x03\x20\x01(\x08R\x08required\x12&\n\x06entity\x18\x04\x20\
    \x01(\x0b2\x0e.global.EntityR\x06entity\"\x88\x01\n\x06Caveat\x12\x0e\n\
    \x02id\x18\x01\x20\x01(\tR\x02id\x12\x12\n\x04name\x18\x02\x20\x01(\tR\
    \x04name\x12\x20\n\x0bdescription\x18\x03\x20\x01(\tR\x0bdescription\x12\
    \x1d\n\nstart_time\x18\x04\x20\x01(\x03R\tstartTime\x12\x19\n\x08end_tim\
    e\x18\x05\x20\x01(\x03R\x07endTime\"\x96\x02\n\x06Entity\x12\x0e\n\x02id\
    \x18\x01\x20\x01(\tR\x02id\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\
    \x12\x20\n\x0bdescription\x18\x03\x20\x01(\tR\x0bdescription\x12\x1a\n\
    \x08required\x18\x04\x20\x01(\x08R\x08required\x12&\n\x04type\x18\x05\
    \x20\x01(\x0e2\x12.global.EntityTypeR\x04type\x12\x12\n\x04role\x18\x06\
    \x20\x01(\tR\x04role\x12\x1d\n\nstart_time\x18\x07\x20\x01(\x03R\tstartT\
    ime\x12\x19\n\x08end_time\x18\x08\x20\x01(\x03R\x07endTime\x124\n\x0bper\
    missions\x18\t\x20\x03(\x0b2\x12.global.PermissionR\x0bpermissions\"\xa2\
    \x01\n\nPermission\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x12\n\
    \x04name\x18\x02\x20\x01(\tR\x04name\x12\x20\n\x0bdescription\x18\x03\
    \x20\x01(\tR\x0bdescription\x12\x14\n\x05allow\x18\x04\x20\x01(\x08R\x05\
    allow\x12\x1d\n\nstart_time\x18\x05\x20\x01(\x03R\tstartTime\x12\x19\n\
    \x08end_time\x18\x06\x20\x01(\x03R\x07endTime\"\xa6\x04\n\x07Content\x12\
    \x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x12\n\x04name\x18\x02\x20\x01\
    (\tR\x04name\x12\x20\n\x0bdescription\x18\x03\x20\x01(\tR\x0bdescription\
    \x12\x10\n\x03url\x18\x04\x20\x01(\tR\x03url\x12\x1b\n\tmime_type\x18\
    \x05\x20\x01(\tR\x08mimeType\x12\x12\n\x04size\x18\x06\x20\x01(\x03R\x04\
    size\x12\x12\n\x04data\x18\x07\x20\x01(\x0cR\x04data\x12\x1d\n\ncreator_\
    id\x18\x08\x20\x01(\tR\tcreatorId\x126\n\x0ccreator_type\x18\t\x20\x01(\
    \x0e2\x13.global.CreatorTypeR\x0bcreatorType\x12\x1d\n\ncreated_at\x18\n\
    \x20\x01(\x03R\tcreatedAt\x124\n\x0bimpressions\x18\x0b\x20\x03(\x0b2\
    \x12.global.ImpressionR\x0bimpressions\x126\n\x0ccontent_type\x18\x0c\
    \x20\x01(\x0e2\x13.global.ContentTypeR\x0bcontentType\x129\n\x08metadata\
    \x18\r\x20\x03(\x0b2\x1d.global.Content.MetadataEntryR\x08metadata\x12\"\
    \n\x0cassociations\x18\x0e\x20\x03(\tR\x0cassociations\x1a;\n\rMetadataE\
    ntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\
    \x02\x20\x01(\tR\x05value:\x028\x01\"j\n\rContentPacket\x122\n\x15curren\
    t_packets_total\x18\x01\x20\x01(\x03R\x13currentPacketsTotal\x12%\n\x05m\
    edia\x18\x02\x20\x01(\x0b2\x0f.global.ContentR\x05media\"\xff\x03\n\x05S\
    pace\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x12\n\x04name\x18\x02\
    \x20\x01(\tR\x04name\x12\x20\n\x0bdescription\x18\x03\x20\x01(\tR\x0bdes\
    cription\x12%\n\x04type\x18\x04\x20\x01(\x0e2\x11.global.SpaceTypeR\x04t\
    ype\x12/\n\x08sub_type\x18\x05\x20\x01(\x0e2\x14.global.SpaceSubTypeR\
    \x07subType\x12%\n\x0eguest_capacity\x18\x06\x20\x01(\x05R\rguestCapacit\
    y\x12\x20\n\x04size\x18\x07\x20\x01(\x0b2\x0c.global.SizeR\x04size\x12\
    \x14\n\x05level\x18\x08\x20\x01(\x03R\x05level\x12%\n\x05media\x18\t\x20\
    \x03(\x0b2\x0f.global.ContentR\x05media\x12-\n\tamenities\x18\n\x20\x03(\
    \x0b2\x0f.global.AmenityR\tamenities\x12%\n\x06spaces\x18\x0b\x20\x03(\
    \x0b2\r.global.SpaceR\x06spaces\x12=\n\nattributes\x18\x0f\x20\x03(\x0b2\
    \x1d.global.Space.AttributesEntryR\nattributes\x1a=\n\x0fAttributesEntry\
    \x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\
    \x20\x01(\tR\x05value:\x028\x01\"c\n\x07Amenity\x12\x0e\n\x02id\x18\x01\
    \x20\x01(\tR\x02id\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\x20\
    \n\x0bdescription\x18\x03\x20\x01(\tR\x0bdescription\x12\x12\n\x04type\
    \x18\x04\x20\x01(\tR\x04type\"b\n\x04Size\x12\x14\n\x05width\x18\x01\x20\
    \x01(\x05R\x05width\x12\x16\n\x06length\x18\x02\x20\x01(\x05R\x06length\
    \x12\x16\n\x06height\x18\x03\x20\x01(\x05R\x06height\x12\x14\n\x05depth\
    \x18\x04\x20\x01(\x05R\x05depth\"{\n\x1eExperienceConfirmationsRequest\
    \x12\x1d\n\njourney_id\x18\x01\x20\x01(\tR\tjourneyId\x12:\n\rconfirmati\
    ons\x18\x02\x20\x03(\x0b2\x14.global.ConfirmationR\rconfirmations\"|\n\
    \x1fExperienceConfirmationsResponse\x12\x1d\n\njourney_id\x18\x01\x20\
    \x01(\tR\tjourneyId\x12:\n\rconfirmations\x18\x02\x20\x03(\x0b2\x14.glob\
    al.ConfirmationR\rconfirmations*\xc3\x01\n\x12ConfirmationStatus\x12#\n\
    \x1fCONFIRMATION_STATUS_UNSPECIFIED\x10\0\x12!\n\x1dCONFIRMATION_STATUS_\
    INITIATED\x10\x02\x12\x1f\n\x1bCONFIRMATION_STATUS_PENDING\x10\x03\x12!\
    \n\x1dCONFIRMATION_STATUS_CONFIRMED\x10\x04\x12!\n\x1dCONFIRMATION_STATU\
    S_CANCELLED\x10\x05*Z\n\x08Currency\x12\x18\n\x14CURRENCY_UNSPECIFIED\
    \x10\0\x12\x10\n\x0cCURRENCY_USD\x10\x01\x12\x10\n\x0cCURRENCY_EUR\x10\
    \x02\x12\x10\n\x0cCURRENCY_XCD\x10\x03*\xad\x02\n\rRateFrequency\x12\x1e\
    \n\x1aRATE_FREQUENCY_UNSPECIFIED\x10\0\x12\x17\n\x13RATE_FREQUENCY_ONCE\
    \x10\x01\x12\x18\n\x14RATE_FREQUENCY_DAILY\x10\x02\x12\x19\n\x15RATE_FRE\
    QUENCY_WEEKLY\x10\x03\x12\x1b\n\x17RATE_FREQUENCY_BIWEEKLY\x10\x04\x12\
    \x1a\n\x16RATE_FREQUENCY_MONTHLY\x10\x05\x12\x1c\n\x18RATE_FREQUENCY_QUA\
    RTERLY\x10\x06\x12\x1f\n\x1bRATE_FREQUENCY_SEMIANNUALLY\x10\x07\x12\x1b\
    \n\x17RATE_FREQUENCY_ANNUALLY\x10\x08\x12\x19\n\x15RATE_FREQUENCY_CUSTOM\
    \x10\t*\xe4\x01\n\x08RateType\x12\x19\n\x15RATE_TYPE_UNSPECIFIED\x10\0\
    \x12\x18\n\x14RATE_TYPE_EXPERIENCE\x10\x01\x12\x11\n\rRATE_TYPE_TAX\x10\
    \x02\x12\x16\n\x12RATE_TYPE_DISCOUNT\x10\x03\x12\x1c\n\x18RATE_TYPE_EXPE\
    RIENCE_FEE\x10\x04\x12\x15\n\x11RATE_TYPE_DEPOSIT\x10\x05\x12\x14\n\x10R\
    ATE_TYPE_CREDIT\x10\x06\x12\x18\n\x14RATE_TYPE_ADJUSTMENT\x10\x07\x12\
    \x13\n\x0fRATE_TYPE_OTHER\x10\x08*\x91\x02\n\x0eExperienceType\x12\x1f\n\
    \x1bEXPERIENCE_TYPE_UNSPECIFIED\x10\0\x12\x18\n\x14EXPERIENCE_TYPE_STAY\
    \x10\x01\x12\x18\n\x14EXPERIENCE_TYPE_EATS\x10\x02\x12\x1c\n\x18EXPERIEN\
    CE_TYPE_ACTIVITY\x10\x03\x12\x19\n\x15EXPERIENCE_TYPE_EVENT\x10\x04\x12\
    \x1e\n\x1aEXPERIENCE_TYPE_CAR_RENTAL\x10\x05\x12\x18\n\x14EXPERIENCE_TYP\
    E_RIDE\x10\x06\x12\x1a\n\x16EXPERIENCE_TYPE_FLIGHT\x10\x07\x12\x1b\n\x17\
    EXPERIENCE_TYPE_SERVICE\x10\x08*\xf0\x01\n\x0cLocationType\x12\x1d\n\x19\
    LOCATION_TYPE_UNSPECIFIED\x10\0\x12\x16\n\x12LOCATION_TYPE_BASE\x10\x01\
    \x12\x1c\n\x18LOCATION_TYPE_IN_TRANSIT\x10\x02\x12\x1e\n\x1aLOCATION_TYP\
    E_IN_WAY_POINT\x10\x03\x12\x1d\n\x19LOCATION_TYPE_DESTINATION\x10\x04\
    \x12\x18\n\x14LOCATION_TYPE_PICKUP\x10\x05\x12\x19\n\x15LOCATION_TYPE_DR\
    OPOFF\x10\x06\x12\x17\n\x13LOCATION_TYPE_OTHER\x10\x07*=\n\x05Order\x12\
    \x15\n\x11ORDER_UNSPECIFIED\x10\0\x12\r\n\tORDER_ASC\x10\x01\x12\x0e\n\n\
    ORDER_DESC\x10\x02*y\n\x0bCreatorType\x12\x1c\n\x18CREATOR_TYPE_UNSPECIF\
    IED\x10\0\x12\x16\n\x12CREATOR_TYPE_GUEST\x10\x01\x12\x18\n\x14CREATOR_T\
    YPE_PARTNER\x10\x02\x12\x1a\n\x16CREATOR_TYPE_CONCIERGE\x10\x03*\x95\x02\
    \n\nEntityType\x12\x1b\n\x17ENTITY_TYPE_UNSPECIFIED\x10\0\x12\x15\n\x11E\
    NTITY_TYPE_GUEST\x10\x01\x12\x17\n\x13ENTITY_TYPE_PARTNER\x10\x02\x12\
    \x15\n\x11ENTITY_TYPE_EVENT\x10\x03\x12\x17\n\x13ENTITY_TYPE_PROJECT\x10\
    \x04\x12\x18\n\x14ENTITY_TYPE_RESOURCE\x10\x05\x12\x1c\n\x18ENTITY_TYPE_\
    NOTIFICATION\x10\x06\x12\x17\n\x13ENTITY_TYPE_JOURNEY\x10\x07\x12\x1a\n\
    \x16ENTITY_TYPE_EXPERIENCE\x10\x08\x12\x1d\n\x19ENTITY_TYPE_QUALIFICATIO\
    N\x10\t*\xea\x01\n\x0cResourceType\x12\x1d\n\x19RESOURCE_TYPE_UNSPECIFIE\
    D\x10\0\x12\x1a\n\x16RESOURCE_TYPE_PROPERTY\x10\x01\x12\x18\n\x14RESOURC\
    E_TYPE_VESSEL\x10\x02\x12\x19\n\x15RESOURCE_TYPE_VEHICLE\x10\x03\x12\x1a\
    \n\x16RESOURCE_TYPE_AIRCRAFT\x10\x04\x12\x1b\n\x17RESOURCE_TYPE_EQUIPMEN\
    T\x10\x05\x12\x18\n\x14RESOURCE_TYPE_MEMBER\x10\x06\x12\x17\n\x13RESOURC\
    E_TYPE_OTHER\x10\x0e*\x92\x01\n\x03Day\x12\x13\n\x0fDAY_UNSPECIFIED\x10\
    \0\x12\x0e\n\nDAY_SUNDAY\x10\x01\x12\x0e\n\nDAY_MONDAY\x10\x02\x12\x0f\n\
    \x0bDAY_TUESDAY\x10\x03\x12\x11\n\rDAY_WEDNESDAY\x10\x04\x12\x10\n\x0cDA\
    Y_THURSDAY\x10\x05\x12\x0e\n\nDAY_FRIDAY\x10\x06\x12\x10\n\x0cDAY_SATURD\
    AY\x10\x07*\x8e\x01\n\x0bContentType\x12\x1c\n\x18CONTENT_TYPE_UNSPECIFI\
    ED\x10\0\x12\x16\n\x12CONTENT_TYPE_IMAGE\x10\x01\x12\x16\n\x12CONTENT_TY\
    PE_VIDEO\x10\x02\x12\x16\n\x12CONTENT_TYPE_AUDIO\x10\x03\x12\x19\n\x15CO\
    NTENT_TYPE_DOCUMENT\x10\x04*\xf0\x01\n\tSpaceType\x12\x1a\n\x16SPACE_TYP\
    E_UNSPECIFIED\x10\0\x12\x16\n\x12SPACE_TYPE_BEDROOM\x10\x01\x12\x17\n\
    \x13SPACE_TYPE_BATHROOM\x10\x02\x12\x16\n\x12SPACE_TYPE_KITCHEN\x10\x03\
    \x12\x15\n\x11SPACE_TYPE_LIVING\x10\x04\x12\x13\n\x0fSPACE_TYPE_POOL\x10\
    \x05\x12\x13\n\x0fSPACE_TYPE_AREA\x10\x06\x12\x13\n\x0fSPACE_TYPE_SEAT\
    \x10\x07\x12\x13\n\x0fSPACE_TYPE_LOFT\x10\x08\x12\x13\n\x0fSPACE_TYPE_DE\
    CK\x10\t*\x86\x02\n\x0cSpaceSubType\x12\x1e\n\x1aSPACE_SUB_TYPE_UNSPECIF\
    IED\x10\0\x12\x1a\n\x16SPACE_SUB_TYPE_PARKING\x10\x01\x12\x17\n\x13SPACE\
    _SUB_TYPE_ROOM\x10\x02\x12\x1c\n\x18SPACE_SUB_TYPE_PENTHOUSE\x10\x03\x12\
    \x17\n\x13SPACE_SUB_TYPE_ROOF\x10\x04\x12\x19\n\x15SPACE_SUB_TYPE_GROUND\
    \x10\x05\x12\x1b\n\x17SPACE_SUB_TYPE_BASEMENT\x10\x06\x12\x18\n\x14SPACE\
    _SUB_TYPE_LOBBY\x10\x07\x12\x18\n\x14SPACE_SUB_TYPE_STORY\x10\x08B.Z,git\
    hub.com/tonychill/ifitu/apis/pb/go/globalJ\xc9\xac\x01\n\x07\x12\x05\0\0\
    \xbe\x04\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\x12\x03\x01\
    \0\x0f\n\x08\n\x01\x08\x12\x03\x02\0C\n\t\n\x02\x08\x0b\x12\x03\x02\0C\n\
    \xdc\x02\n\x02\x04\0\x12\x04\x0b\0!\x012\xcf\x02\x20A\x20dynamic\x20abst\
    raction\x20of\x20one\x20or\x20more\x20options\x20that\x20a\x20resource\
    \x20may\x20provide.\n\x20For\x20example,\x20a\x20yacht\x20charter\x20may\
    \x20be\x20offered\x20as\x20a\x20single\n\x20\x20experience\x20but\x20it\
    \x20may\x20have\x20multiple\x20options\x20such\x20as\x20a\x20day\x20char\
    ter,\x20a\x20week\n\x20\x20charter,\x20a\x20month\x20charter,\x20etc.\n\
    \x20TODO:\x20an\x20experience\x20is\x20an\x20entity.\x20how\x20should\
    \x20we\x20handle\x20the\x20definition\x20and\n\x20placement\x20of\x20it?\
    \x20\n\n\n\n\x03\x04\0\x01\x12\x03\x0b\x08\x10\n\x0b\n\x04\x04\0\x02\0\
    \x12\x03\x0c\x02\x10\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03\x0c\x02\x08\n\
    \x0c\n\x05\x04\0\x02\0\x01\x12\x03\x0c\t\x0b\n\x0c\n\x05\x04\0\x02\0\x03\
    \x12\x03\x0c\x0e\x0f\n\x0b\n\x04\x04\0\x02\x01\x12\x03\r\x02\x17\n\x0c\n\
    \x05\x04\0\x02\x01\x05\x12\x03\r\x02\x08\n\x0c\n\x05\x04\0\x02\x01\x01\
    \x12\x03\r\t\x12\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03\r\x15\x16\n\x0b\n\
    \x04\x04\0\x02\x02\x12\x03\x0e\x02\x18\n\x0c\n\x05\x04\0\x02\x02\x05\x12\
    \x03\x0e\x02\x08\n\x0c\n\x05\x04\0\x02\x02\x01\x12\x03\x0e\t\x13\n\x0c\n\
    \x05\x04\0\x02\x02\x03\x12\x03\x0e\x16\x17\n\x0b\n\x04\x04\0\x02\x03\x12\
    \x03\x0f\x02\x17\n\x0c\n\x05\x04\0\x02\x03\x05\x12\x03\x0f\x02\x08\n\x0c\
    \n\x05\x04\0\x02\x03\x01\x12\x03\x0f\t\x12\n\x0c\n\x05\x04\0\x02\x03\x03\
    \x12\x03\x0f\x15\x16\n\x0b\n\x04\x04\0\x02\x04\x12\x03\x10\x02\x13\n\x0c\
    \n\x05\x04\0\x02\x04\x05\x12\x03\x10\x02\x08\n\x0c\n\x05\x04\0\x02\x04\
    \x01\x12\x03\x10\t\x0e\n\x0c\n\x05\x04\0\x02\x04\x03\x12\x03\x10\x11\x12\
    \n\x0b\n\x04\x04\0\x02\x05\x12\x03\x11\x02\x13\n\x0c\n\x05\x04\0\x02\x05\
    \x05\x12\x03\x11\x02\x08\n\x0c\n\x05\x04\0\x02\x05\x01\x12\x03\x11\t\x0e\
    \n\x0c\n\x05\x04\0\x02\x05\x03\x12\x03\x11\x11\x12\n\x0b\n\x04\x04\0\x02\
    \x06\x12\x03\x12\x02\x1a\n\x0c\n\x05\x04\0\x02\x06\x05\x12\x03\x12\x02\
    \x07\n\x0c\n\x05\x04\0\x02\x06\x01\x12\x03\x12\x08\x15\n\x0c\n\x05\x04\0\
    \x02\x06\x03\x12\x03\x12\x18\x19\n\x0b\n\x04\x04\0\x02\x07\x12\x03\x13\
    \x02\x17\n\x0c\n\x05\x04\0\x02\x07\x05\x12\x03\x13\x02\x07\n\x0c\n\x05\
    \x04\0\x02\x07\x01\x12\x03\x13\x08\x12\n\x0c\n\x05\x04\0\x02\x07\x03\x12\
    \x03\x13\x15\x16\n\x0b\n\x04\x04\0\x02\x08\x12\x03\x14\x02\x17\n\x0c\n\
    \x05\x04\0\x02\x08\x05\x12\x03\x14\x02\x07\n\x0c\n\x05\x04\0\x02\x08\x01\
    \x12\x03\x14\x08\x12\n\x0c\n\x05\x04\0\x02\x08\x03\x12\x03\x14\x15\x16\n\
    \x0b\n\x04\x04\0\x02\t\x12\x03\x15\x02\x18\n\x0c\n\x05\x04\0\x02\t\x05\
    \x12\x03\x15\x02\x07\n\x0c\n\x05\x04\0\x02\t\x01\x12\x03\x15\x08\x12\n\
    \x0c\n\x05\x04\0\x02\t\x03\x12\x03\x15\x15\x17\n0\n\x04\x04\0\x02\n\x12\
    \x03\x16\x02\x1e\"#\x20guests\x20can\x20update\x20their\x20addresses\n\n\
    \x0c\n\x05\x04\0\x02\n\x06\x12\x03\x16\x02\x10\n\x0c\n\x05\x04\0\x02\n\
    \x01\x12\x03\x16\x11\x18\n\x0c\n\x05\x04\0\x02\n\x03\x12\x03\x16\x1b\x1d\
    \n\x0b\n\x04\x04\0\x02\x0b\x12\x03\x17\x02\x20\n\x0c\n\x05\x04\0\x02\x0b\
    \x05\x12\x03\x17\x02\x08\n\x0c\n\x05\x04\0\x02\x0b\x01\x12\x03\x17\t\x1a\
    \n\x0c\n\x05\x04\0\x02\x0b\x03\x12\x03\x17\x1d\x1f\n\xbe\x01\n\x04\x04\0\
    \x02\x0c\x12\x03\x1d\x02\x20\x1a\xb0\x01\x20add\x20alergies\x20as\x20top\
    \x20line\x20item\n\x20repeated\x20Preference\x20preferences\x20=\x2013;\
    \n\x20Note\x20above\x20the\x20persona\x20property.\n\x20Persona\x20perso\
    na\x20=\x2014;\x20//\x20Part\x20fo\x20the\x20truth\x20engine\n\x20string\
    \x20gender\x20=\x2015;\n\n\x0c\n\x05\x04\0\x02\x0c\x04\x12\x03\x1d\x02\n\
    \n\x0c\n\x05\x04\0\x02\x0c\x05\x12\x03\x1d\x0b\x11\n\x0c\n\x05\x04\0\x02\
    \x0c\x01\x12\x03\x1d\x12\x1a\n\x0c\n\x05\x04\0\x02\x0c\x03\x12\x03\x1d\
    \x1d\x1f\n\x0b\n\x04\x04\0\x02\r\x12\x03\x1e\x02\"\n\x0c\n\x05\x04\0\x02\
    \r\x04\x12\x03\x1e\x02\n\n\x0c\n\x05\x04\0\x02\r\x05\x12\x03\x1e\x0b\x11\
    \n\x0c\n\x05\x04\0\x02\r\x01\x12\x03\x1e\x12\x1c\n\x0c\n\x05\x04\0\x02\r\
    \x03\x12\x03\x1e\x1f!\n#\n\x04\x04\0\x02\x0e\x12\x03\x1f\x02\x20\"\x16\
    \x20TODO:\x20add\x20permssions\n\n\x0c\n\x05\x04\0\x02\x0e\x04\x12\x03\
    \x1f\x02\n\n\x0c\n\x05\x04\0\x02\x0e\x05\x12\x03\x1f\x0b\x11\n\x0c\n\x05\
    \x04\0\x02\x0e\x01\x12\x03\x1f\x12\x1a\n\x0c\n\x05\x04\0\x02\x0e\x03\x12\
    \x03\x1f\x1d\x1f\n\n\n\x02\x04\x01\x12\x04$\07\x01\n\n\n\x03\x04\x01\x01\
    \x12\x03$\x08\x12\n\x0b\n\x04\x04\x01\x02\0\x12\x03%\x02\x10\n\x0c\n\x05\
    \x04\x01\x02\0\x05\x12\x03%\x02\x08\n\x0c\n\x05\x04\x01\x02\0\x01\x12\
    \x03%\t\x0b\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03%\x0e\x0f\n\x0b\n\x04\
    \x04\x01\x02\x01\x12\x03&\x02\x18\n\x0c\n\x05\x04\x01\x02\x01\x05\x12\
    \x03&\x02\x08\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\x03&\t\x13\n\x0c\n\x05\
    \x04\x01\x02\x01\x03\x12\x03&\x16\x17\n\x0b\n\x04\x04\x01\x02\x02\x12\
    \x03'\x02\x12\n\x0c\n\x05\x04\x01\x02\x02\x05\x12\x03'\x02\x08\n\x0c\n\
    \x05\x04\x01\x02\x02\x01\x12\x03'\t\r\n\x0c\n\x05\x04\x01\x02\x02\x03\
    \x12\x03'\x10\x11\n\x0b\n\x04\x04\x01\x02\x03\x12\x03(\x02\x19\n\x0c\n\
    \x05\x04\x01\x02\x03\x05\x12\x03(\x02\x08\n\x0c\n\x05\x04\x01\x02\x03\
    \x01\x12\x03(\t\x14\n\x0c\n\x05\x04\x01\x02\x03\x03\x12\x03(\x17\x18\n\
    \x0b\n\x04\x04\x01\x02\x04\x12\x03)\x02\x1a\n\x0c\n\x05\x04\x01\x02\x04\
    \x06\x12\x03)\x02\x10\n\x0c\n\x05\x04\x01\x02\x04\x01\x12\x03)\x11\x15\n\
    \x0c\n\x05\x04\x01\x02\x04\x03\x12\x03)\x18\x19\n\x0b\n\x04\x04\x01\x02\
    \x05\x12\x03*\x02\x1d\n\x0c\n\x05\x04\x01\x02\x05\x04\x12\x03*\x02\n\n\
    \x0c\n\x05\x04\x01\x02\x05\x06\x12\x03*\x0b\x12\n\x0c\n\x05\x04\x01\x02\
    \x05\x01\x12\x03*\x13\x18\n\x0c\n\x05\x04\x01\x02\x05\x03\x12\x03*\x1b\
    \x1c\n\x0b\n\x04\x04\x01\x02\x06\x12\x03+\x02\x17\n\x0c\n\x05\x04\x01\
    \x02\x06\x05\x12\x03+\x02\x07\n\x0c\n\x05\x04\x01\x02\x06\x01\x12\x03+\
    \x08\x12\n\x0c\n\x05\x04\x01\x02\x06\x03\x12\x03+\x15\x16\n\x0b\n\x04\
    \x04\x01\x02\x07\x12\x03,\x02\x15\n\x0c\n\x05\x04\x01\x02\x07\x05\x12\
    \x03,\x02\x07\n\x0c\n\x05\x04\x01\x02\x07\x01\x12\x03,\x08\x10\n\x0c\n\
    \x05\x04\x01\x02\x07\x03\x12\x03,\x13\x14\n\x0b\n\x04\x04\x01\x02\x08\
    \x12\x03-\x02\x1b\n\x0c\n\x05\x04\x01\x02\x08\x04\x12\x03-\x02\n\n\x0c\n\
    \x05\x04\x01\x02\x08\x05\x12\x03-\x0b\x11\n\x0c\n\x05\x04\x01\x02\x08\
    \x01\x12\x03-\x12\x16\n\x0c\n\x05\x04\x01\x02\x08\x03\x12\x03-\x19\x1a\n\
    \x0b\n\x04\x04\x01\x02\t\x12\x03.\x02\x1b\n\x0c\n\x05\x04\x01\x02\t\x04\
    \x12\x03.\x02\n\n\x0c\n\x05\x04\x01\x02\t\x06\x12\x03.\x0b\x0f\n\x0c\n\
    \x05\x04\x01\x02\t\x01\x12\x03.\x10\x15\n\x0c\n\x05\x04\x01\x02\t\x03\
    \x12\x03.\x18\x1a\n\x0b\n\x04\x04\x01\x02\n\x12\x03/\x02\x1b\n\x0c\n\x05\
    \x04\x01\x02\n\x04\x12\x03/\x02\n\n\x0c\n\x05\x04\x01\x02\n\x06\x12\x03/\
    \x0b\x0f\n\x0c\n\x05\x04\x01\x02\n\x01\x12\x03/\x10\x15\n\x0c\n\x05\x04\
    \x01\x02\n\x03\x12\x03/\x18\x1a\n\x0b\n\x04\x04\x01\x02\x0b\x12\x030\x02\
    !\n\x0c\n\x05\x04\x01\x02\x0b\x04\x12\x030\x02\n\n\x0c\n\x05\x04\x01\x02\
    \x0b\x06\x12\x030\x0b\x12\n\x0c\n\x05\x04\x01\x02\x0b\x01\x12\x030\x13\
    \x1b\n\x0c\n\x05\x04\x01\x02\x0b\x03\x12\x030\x1e\x20\n\x0b\n\x04\x04\
    \x01\x02\x0c\x12\x031\x02\x1d\n\x0c\n\x05\x04\x01\x02\x0c\x04\x12\x031\
    \x02\n\n\x0c\n\x05\x04\x01\x02\x0c\x06\x12\x031\x0b\x10\n\x0c\n\x05\x04\
    \x01\x02\x0c\x01\x12\x031\x11\x17\n\x0c\n\x05\x04\x01\x02\x0c\x03\x12\
    \x031\x1a\x1c\n\x0b\n\x04\x04\x01\x02\r\x12\x032\x02'\n\x0c\n\x05\x04\
    \x01\x02\r\x04\x12\x032\x02\n\n\x0c\n\x05\x04\x01\x02\r\x06\x12\x032\x0b\
    \x15\n\x0c\n\x05\x04\x01\x02\r\x01\x12\x032\x16!\n\x0c\n\x05\x04\x01\x02\
    \r\x03\x12\x032$&\n\x0b\n\x04\x04\x01\x02\x0e\x12\x033\x02!\n\x0c\n\x05\
    \x04\x01\x02\x0e\x04\x12\x033\x02\n\n\x0c\n\x05\x04\x01\x02\x0e\x06\x12\
    \x033\x0b\x12\n\x0c\n\x05\x04\x01\x02\x0e\x01\x12\x033\x13\x1b\n\x0c\n\
    \x05\x04\x01\x02\x0e\x03\x12\x033\x1e\x20\n\x0b\n\x04\x04\x01\x02\x0f\
    \x12\x034\x02#\n\x0c\n\x05\x04\x01\x02\x0f\x04\x12\x034\x02\n\n\x0c\n\
    \x05\x04\x01\x02\x0f\x06\x12\x034\x0b\x13\n\x0c\n\x05\x04\x01\x02\x0f\
    \x01\x12\x034\x14\x1d\n\x0c\n\x05\x04\x01\x02\x0f\x03\x12\x034\x20\"\n\
    \x0b\n\x04\x04\x01\x02\x10\x12\x035\x02#\n\x0c\n\x05\x04\x01\x02\x10\x04\
    \x12\x035\x02\n\n\x0c\n\x05\x04\x01\x02\x10\x06\x12\x035\x0b\x13\n\x0c\n\
    \x05\x04\x01\x02\x10\x01\x12\x035\x14\x1d\n\x0c\n\x05\x04\x01\x02\x10\
    \x03\x12\x035\x20\"\n\x0b\n\x04\x04\x01\x02\x11\x12\x036\x02#\n\x0c\n\
    \x05\x04\x01\x02\x11\x04\x12\x036\x02\n\n\x0c\n\x05\x04\x01\x02\x11\x06\
    \x12\x036\x0b\x13\n\x0c\n\x05\x04\x01\x02\x11\x01\x12\x036\x14\x1d\n\x0c\
    \n\x05\x04\x01\x02\x11\x03\x12\x036\x20\"\n\n\n\x02\x04\x02\x12\x049\0A\
    \x01\n\n\n\x03\x04\x02\x01\x12\x039\x08\x14\n\x0b\n\x04\x04\x02\x02\0\
    \x12\x03:\x02\x1b\n\x0c\n\x05\x04\x02\x02\0\x05\x12\x03:\x02\x08\n\x0c\n\
    \x05\x04\x02\x02\0\x01\x12\x03:\t\x16\n\x0c\n\x05\x04\x02\x02\0\x03\x12\
    \x03:\x19\x1a\n\x0b\n\x04\x04\x02\x02\x01\x12\x03;\x02\x1d\n\x0c\n\x05\
    \x04\x02\x02\x01\x05\x12\x03;\x02\x07\n\x0c\n\x05\x04\x02\x02\x01\x01\
    \x12\x03;\x08\x18\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03;\x1b\x1c\n\x0b\
    \n\x04\x04\x02\x02\x02\x12\x03<\x02\x1b\n\x0c\n\x05\x04\x02\x02\x02\x05\
    \x12\x03<\x02\x07\n\x0c\n\x05\x04\x02\x02\x02\x01\x12\x03<\x08\x16\n\x0c\
    \n\x05\x04\x02\x02\x02\x03\x12\x03<\x19\x1a\n\x0b\n\x04\x04\x02\x02\x03\
    \x12\x03=\x02\x1f\n\x0c\n\x05\x04\x02\x02\x03\x05\x12\x03=\x02\x08\n\x0c\
    \n\x05\x04\x02\x02\x03\x01\x12\x03=\t\x1a\n\x0c\n\x05\x04\x02\x02\x03\
    \x03\x12\x03=\x1d\x1e\n\x0b\n\x04\x04\x02\x02\x04\x12\x03>\x02\x20\n\x0c\
    \n\x05\x04\x02\x02\x04\x06\x12\x03>\x02\x14\n\x0c\n\x05\x04\x02\x02\x04\
    \x01\x12\x03>\x15\x1b\n\x0c\n\x05\x04\x02\x02\x04\x03\x12\x03>\x1e\x1f\n\
    \x0b\n\x04\x04\x02\x02\x05\x12\x03?\x02\x1b\n\x0c\n\x05\x04\x02\x02\x05\
    \x05\x12\x03?\x02\x08\n\x0c\n\x05\x04\x02\x02\x05\x01\x12\x03?\t\x16\n\
    \x0c\n\x05\x04\x02\x02\x05\x03\x12\x03?\x19\x1a\n\x0b\n\x04\x04\x02\x02\
    \x06\x12\x03@\x02\x18\n\x0c\n\x05\x04\x02\x02\x06\x06\x12\x03@\x02\n\n\
    \x0c\n\x05\x04\x02\x02\x06\x01\x12\x03@\x0b\x13\n\x0c\n\x05\x04\x02\x02\
    \x06\x03\x12\x03@\x16\x17\n\n\n\x02\x05\0\x12\x04C\0I\x01\n\n\n\x03\x05\
    \0\x01\x12\x03C\x05\x17\n\x0b\n\x04\x05\0\x02\0\x12\x03D\x02&\n\x0c\n\
    \x05\x05\0\x02\0\x01\x12\x03D\x02!\n\x0c\n\x05\x05\0\x02\0\x02\x12\x03D$\
    %\n\x0b\n\x04\x05\0\x02\x01\x12\x03E\x02$\n\x0c\n\x05\x05\0\x02\x01\x01\
    \x12\x03E\x02\x1f\n\x0c\n\x05\x05\0\x02\x01\x02\x12\x03E\"#\n\x0b\n\x04\
    \x05\0\x02\x02\x12\x03F\x02\"\n\x0c\n\x05\x05\0\x02\x02\x01\x12\x03F\x02\
    \x1d\n\x0c\n\x05\x05\0\x02\x02\x02\x12\x03F\x20!\n\x0b\n\x04\x05\0\x02\
    \x03\x12\x03G\x02$\n\x0c\n\x05\x05\0\x02\x03\x01\x12\x03G\x02\x1f\n\x0c\
    \n\x05\x05\0\x02\x03\x02\x12\x03G\"#\n\x0b\n\x04\x05\0\x02\x04\x12\x03H\
    \x02$\n\x0c\n\x05\x05\0\x02\x04\x01\x12\x03H\x02\x1f\n\x0c\n\x05\x05\0\
    \x02\x04\x02\x12\x03H\"#\n\n\n\x02\x04\x03\x12\x04J\0T\x01\n\n\n\x03\x04\
    \x03\x01\x12\x03J\x08\x0f\n\x0b\n\x04\x04\x03\x02\0\x12\x03K\x02\x10\n\
    \x0c\n\x05\x04\x03\x02\0\x05\x12\x03K\x02\x08\n\x0c\n\x05\x04\x03\x02\0\
    \x01\x12\x03K\t\x0b\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x03K\x0e\x0f\n\x0b\
    \n\x04\x04\x03\x02\x01\x12\x03L\x02\x16\n\x0c\n\x05\x04\x03\x02\x01\x05\
    \x12\x03L\x02\x08\n\x0c\n\x05\x04\x03\x02\x01\x01\x12\x03L\t\x11\n\x0c\n\
    \x05\x04\x03\x02\x01\x03\x12\x03L\x14\x15\n\x0b\n\x04\x04\x03\x02\x02\
    \x12\x03M\x02\x18\n\x0c\n\x05\x04\x03\x02\x02\x05\x12\x03M\x02\x08\n\x0c\
    \n\x05\x04\x03\x02\x02\x01\x12\x03M\t\x13\n\x0c\n\x05\x04\x03\x02\x02\
    \x03\x12\x03M\x16\x17\n\x0b\n\x04\x04\x03\x02\x03\x12\x03N\x02\x17\n\x0c\
    \n\x05\x04\x03\x02\x03\x05\x12\x03N\x02\x08\n\x0c\n\x05\x04\x03\x02\x03\
    \x01\x12\x03N\t\x12\n\x0c\n\x05\x04\x03\x02\x03\x03\x12\x03N\x15\x16\n\
    \x0b\n\x04\x04\x03\x02\x04\x12\x03O\x02\x19\n\x0c\n\x05\x04\x03\x02\x04\
    \x05\x12\x03O\x02\x08\n\x0c\n\x05\x04\x03\x02\x04\x01\x12\x03O\t\x14\n\
    \x0c\n\x05\x04\x03\x02\x04\x03\x12\x03O\x17\x18\n\x0b\n\x04\x04\x03\x02\
    \x05\x12\x03P\x02\x12\n\x0c\n\x05\x04\x03\x02\x05\x05\x12\x03P\x02\x08\n\
    \x0c\n\x05\x04\x03\x02\x05\x01\x12\x03P\t\r\n\x0c\n\x05\x04\x03\x02\x05\
    \x03\x12\x03P\x10\x11\n\x0b\n\x04\x04\x03\x02\x06\x12\x03Q\x02\x18\n\x0c\
    \n\x05\x04\x03\x02\x06\x05\x12\x03Q\x02\x08\n\x0c\n\x05\x04\x03\x02\x06\
    \x01\x12\x03Q\t\x13\n\x0c\n\x05\x04\x03\x02\x06\x03\x12\x03Q\x16\x17\n\
    \x0b\n\x04\x04\x03\x02\x07\x12\x03R\x02\x18\n\x0c\n\x05\x04\x03\x02\x07\
    \x05\x12\x03R\x02\x08\n\x0c\n\x05\x04\x03\x02\x07\x01\x12\x03R\t\x13\n\
    \x0c\n\x05\x04\x03\x02\x07\x03\x12\x03R\x16\x17\n\x0b\n\x04\x04\x03\x02\
    \x08\x12\x03S\x02\x18\n\x0c\n\x05\x04\x03\x02\x08\x05\x12\x03S\x02\x08\n\
    \x0c\n\x05\x04\x03\x02\x08\x01\x12\x03S\t\x13\n\x0c\n\x05\x04\x03\x02\
    \x08\x03\x12\x03S\x16\x17\n\n\n\x02\x04\x04\x12\x04V\0^\x01\n\n\n\x03\
    \x04\x04\x01\x12\x03V\x08\x0f\n\x0b\n\x04\x04\x04\x02\0\x12\x03W\x02\x10\
    \n\x0c\n\x05\x04\x04\x02\0\x05\x12\x03W\x02\x08\n\x0c\n\x05\x04\x04\x02\
    \0\x01\x12\x03W\t\x0b\n\x0c\n\x05\x04\x04\x02\0\x03\x12\x03W\x0e\x0f\n\
    \x0b\n\x04\x04\x04\x02\x01\x12\x03X\x02\x12\n\x0c\n\x05\x04\x04\x02\x01\
    \x05\x12\x03X\x02\x08\n\x0c\n\x05\x04\x04\x02\x01\x01\x12\x03X\t\r\n\x0c\
    \n\x05\x04\x04\x02\x01\x03\x12\x03X\x10\x11\n\x0b\n\x04\x04\x04\x02\x02\
    \x12\x03Y\x02\x19\n\x0c\n\x05\x04\x04\x02\x02\x05\x12\x03Y\x02\x08\n\x0c\
    \n\x05\x04\x04\x02\x02\x01\x12\x03Y\t\x14\n\x0c\n\x05\x04\x04\x02\x02\
    \x03\x12\x03Y\x17\x18\n&\n\x04\x04\x04\x02\x03\x12\x03Z\x02\x12\"\x19\
    \x20service,\x20location,\x20etc,\n\n\x0c\n\x05\x04\x04\x02\x03\x05\x12\
    \x03Z\x02\x08\n\x0c\n\x05\x04\x04\x02\x03\x01\x12\x03Z\t\r\n\x0c\n\x05\
    \x04\x04\x02\x03\x03\x12\x03Z\x10\x11\n\x0b\n\x04\x04\x04\x02\x04\x12\
    \x03[\x02\x18\n\x0c\n\x05\x04\x04\x02\x04\x05\x12\x03[\x02\x08\n\x0c\n\
    \x05\x04\x04\x02\x04\x01\x12\x03[\t\x13\n\x0c\n\x05\x04\x04\x02\x04\x03\
    \x12\x03[\x16\x17\n\x0b\n\x04\x04\x04\x02\x05\x12\x03\\\x02\x18\n\x0c\n\
    \x05\x04\x04\x02\x05\x05\x12\x03\\\x02\x08\n\x0c\n\x05\x04\x04\x02\x05\
    \x01\x12\x03\\\t\x13\n\x0c\n\x05\x04\x04\x02\x05\x03\x12\x03\\\x16\x17\n\
    \x0b\n\x04\x04\x04\x02\x06\x12\x03]\x02\x18\n\x0c\n\x05\x04\x04\x02\x06\
    \x05\x12\x03]\x02\x08\n\x0c\n\x05\x04\x04\x02\x06\x01\x12\x03]\t\x13\n\
    \x0c\n\x05\x04\x04\x02\x06\x03\x12\x03]\x16\x17\n\n\n\x02\x04\x05\x12\
    \x04`\0p\x01\n\n\n\x03\x04\x05\x01\x12\x03`\x08\x0c\n\x0b\n\x04\x04\x05\
    \x02\0\x12\x03a\x02\x10\n\x0c\n\x05\x04\x05\x02\0\x05\x12\x03a\x02\x08\n\
    \x0c\n\x05\x04\x05\x02\0\x01\x12\x03a\t\x0b\n\x0c\n\x05\x04\x05\x02\0\
    \x03\x12\x03a\x0e\x0f\n\x0b\n\x04\x04\x05\x02\x01\x12\x03b\x02\x18\n\x0c\
    \n\x05\x04\x05\x02\x01\x05\x12\x03b\x02\x08\n\x0c\n\x05\x04\x05\x02\x01\
    \x01\x12\x03b\t\x13\n\x0c\n\x05\x04\x05\x02\x01\x03\x12\x03b\x16\x17\n\
    \x0b\n\x04\x04\x05\x02\x02\x12\x03c\x02\x12\n\x0c\n\x05\x04\x05\x02\x02\
    \x05\x12\x03c\x02\x08\n\x0c\n\x05\x04\x05\x02\x02\x01\x12\x03c\t\r\n\x0c\
    \n\x05\x04\x05\x02\x02\x03\x12\x03c\x10\x11\n\x0b\n\x04\x04\x05\x02\x03\
    \x12\x03d\x02\x19\n\x0c\n\x05\x04\x05\x02\x03\x05\x12\x03d\x02\x08\n\x0c\
    \n\x05\x04\x05\x02\x03\x01\x12\x03d\t\x14\n\x0c\n\x05\x04\x05\x02\x03\
    \x03\x12\x03d\x17\x18\n\x15\n\x04\x04\x05\x02\x04\x12\x03e\x02\"\"\x08ty\
    pe:id\n\n\x0c\n\x05\x04\x05\x02\x04\x04\x12\x03e\x02\n\n\x0c\n\x05\x04\
    \x05\x02\x04\x05\x12\x03e\x0b\x11\n\x0c\n\x05\x04\x05\x02\x04\x01\x12\
    \x03e\x12\x1d\n\x0c\n\x05\x04\x05\x02\x04\x03\x12\x03e\x20!\n\x0b\n\x04\
    \x04\x05\x02\x05\x12\x03f\x02\x19\n\x0c\n\x05\x04\x05\x02\x05\x06\x12\
    \x03f\x02\n\n\x0c\n\x05\x04\x05\x02\x05\x01\x12\x03f\x0b\x14\n\x0c\n\x05\
    \x04\x05\x02\x05\x03\x12\x03f\x17\x18\n\x0b\n\x04\x04\x05\x02\x06\x12\
    \x03g\x02\x17\n\x0c\n\x05\x04\x05\x02\x06\x05\x12\x03g\x02\x07\n\x0c\n\
    \x05\x04\x05\x02\x06\x01\x12\x03g\x08\x12\n\x0c\n\x05\x04\x05\x02\x06\
    \x03\x12\x03g\x15\x16\n\x0b\n\x04\x04\x05\x02\x07\x12\x03h\x02\x15\n\x0c\
    \n\x05\x04\x05\x02\x07\x05\x12\x03h\x02\x07\n\x0c\n\x05\x04\x05\x02\x07\
    \x01\x12\x03h\x08\x10\n\x0c\n\x05\x04\x05\x02\x07\x03\x12\x03h\x13\x14\n\
    \x1f\n\x04\x04\x05\x02\x08\x12\x03i\x02\x13\"\x12\x20allways\x20in\x20ce\
    nts\n\n\x0c\n\x05\x04\x05\x02\x08\x05\x12\x03i\x02\x07\n\x0c\n\x05\x04\
    \x05\x02\x08\x01\x12\x03i\x08\x0e\n\x0c\n\x05\x04\x05\x02\x08\x03\x12\
    \x03i\x11\x12\n\x0b\n\x04\x04\x05\x02\t\x12\x03j\x02\x19\n\x0c\n\x05\x04\
    \x05\x02\t\x06\x12\x03j\x02\n\n\x0c\n\x05\x04\x05\x02\t\x01\x12\x03j\x0b\
    \x13\n\x0c\n\x05\x04\x05\x02\t\x03\x12\x03j\x16\x18\n@\n\x04\x04\x05\x02\
    \n\x12\x03l\x02\x1f\x1a3\x20TODO:\x20add\x20number\x20of\x20guests,\x20n\
    umber\x20of\x20hours,\x20etc.\n\n\x0c\n\x05\x04\x05\x02\n\x06\x12\x03l\
    \x02\x0f\n\x0c\n\x05\x04\x05\x02\n\x01\x12\x03l\x10\x19\n\x0c\n\x05\x04\
    \x05\x02\n\x03\x12\x03l\x1c\x1e\n\x0b\n\x04\x04\x05\x02\x0b\x12\x03m\x02\
    $\n\x0c\n\x05\x04\x05\x02\x0b\x06\x12\x03m\x02\x15\n\x0c\n\x05\x04\x05\
    \x02\x0b\x01\x12\x03m\x16\x1e\n\x0c\n\x05\x04\x05\x02\x0b\x03\x12\x03m!#\
    \n\x0b\n\x04\x04\x05\x02\x0c\x12\x03n\x02\x18\n\x0c\n\x05\x04\x05\x02\
    \x0c\x05\x12\x03n\x02\x07\n\x0c\n\x05\x04\x05\x02\x0c\x01\x12\x03n\x08\
    \x12\n\x0c\n\x05\x04\x05\x02\x0c\x03\x12\x03n\x15\x17\n\x0b\n\x04\x04\
    \x05\x02\r\x12\x03o\x02\x18\n\x0c\n\x05\x04\x05\x02\r\x05\x12\x03o\x02\
    \x07\n\x0c\n\x05\x04\x05\x02\r\x01\x12\x03o\x08\x12\n\x0c\n\x05\x04\x05\
    \x02\r\x03\x12\x03o\x15\x17\n\x0b\n\x02\x05\x01\x12\x05r\0\x87\x01\x01\n\
    \n\n\x03\x05\x01\x01\x12\x03r\x05\r\n\x0b\n\x04\x05\x01\x02\0\x12\x03s\
    \x02\x1b\n\x0c\n\x05\x05\x01\x02\0\x01\x12\x03s\x02\x16\n\x0c\n\x05\x05\
    \x01\x02\0\x02\x12\x03s\x19\x1a\n\x0b\n\x04\x05\x01\x02\x01\x12\x03t\x02\
    \x13\n\x0c\n\x05\x05\x01\x02\x01\x01\x12\x03t\x02\x0e\n\x0c\n\x05\x05\
    \x01\x02\x01\x02\x12\x03t\x11\x12\n\x0b\n\x04\x05\x01\x02\x02\x12\x03u\
    \x02\x13\n\x0c\n\x05\x05\x01\x02\x02\x01\x12\x03u\x02\x0e\n\x0c\n\x05\
    \x05\x01\x02\x02\x02\x12\x03u\x11\x12\n\xc7\x02\n\x04\x05\x01\x02\x03\
    \x12\x03v\x02\x13\"\xb9\x02\x20CURRENCY_GBP\x20=\x203;\n\x20CURRENCY_AUD\
    \x20=\x204;\n\x20CURRENCY_CAD\x20=\x205;\n\x20CURRENCY_CHF\x20=\x206;\n\
    \x20CURRENCY_CNY\x20=\x207;\n\x20CURRENCY_DKK\x20=\x208;\n\x20CURRENCY_H\
    KD\x20=\x209;\n\x20CURRENCY_INR\x20=\x2010;\n\x20CURRENCY_JPY\x20=\x2011\
    ;\n\x20CURRENCY_MXN\x20=\x2012;\n\x20CURRENCY_NOK\x20=\x2013;\n\x20CURRE\
    NCY_NZD\x20=\x2014;\n\x20CURRENCY_PLN\x20=\x2015;\n\x20CURRENCY_SEK\x20=\
    \x2016;\n\x20CURRENCY_SGD\x20=\x2017;\n\x20CURRENCY_ZAR\x20=\x2018;\n\n\
    \x0c\n\x05\x05\x01\x02\x03\x01\x12\x03v\x02\x0e\n\x0c\n\x05\x05\x01\x02\
    \x03\x02\x12\x03v\x11\x12\n\x0c\n\x02\x05\x02\x12\x06\x89\x01\0\x95\x01\
    \x01\n\x0b\n\x03\x05\x02\x01\x12\x04\x89\x01\x05\x12\n\x0c\n\x04\x05\x02\
    \x02\0\x12\x04\x8a\x01\x02!\n\r\n\x05\x05\x02\x02\0\x01\x12\x04\x8a\x01\
    \x02\x1c\n\r\n\x05\x05\x02\x02\0\x02\x12\x04\x8a\x01\x1f\x20\n\x0c\n\x04\
    \x05\x02\x02\x01\x12\x04\x8b\x01\x02\x1a\n\r\n\x05\x05\x02\x02\x01\x01\
    \x12\x04\x8b\x01\x02\x15\n\r\n\x05\x05\x02\x02\x01\x02\x12\x04\x8b\x01\
    \x18\x19\n\x0c\n\x04\x05\x02\x02\x02\x12\x04\x8c\x01\x02\x1b\n\r\n\x05\
    \x05\x02\x02\x02\x01\x12\x04\x8c\x01\x02\x16\n\r\n\x05\x05\x02\x02\x02\
    \x02\x12\x04\x8c\x01\x19\x1a\n\x0c\n\x04\x05\x02\x02\x03\x12\x04\x8d\x01\
    \x02\x1c\n\r\n\x05\x05\x02\x02\x03\x01\x12\x04\x8d\x01\x02\x17\n\r\n\x05\
    \x05\x02\x02\x03\x02\x12\x04\x8d\x01\x1a\x1b\n\x0c\n\x04\x05\x02\x02\x04\
    \x12\x04\x8e\x01\x02\x1e\n\r\n\x05\x05\x02\x02\x04\x01\x12\x04\x8e\x01\
    \x02\x19\n\r\n\x05\x05\x02\x02\x04\x02\x12\x04\x8e\x01\x1c\x1d\n\x0c\n\
    \x04\x05\x02\x02\x05\x12\x04\x8f\x01\x02\x1d\n\r\n\x05\x05\x02\x02\x05\
    \x01\x12\x04\x8f\x01\x02\x18\n\r\n\x05\x05\x02\x02\x05\x02\x12\x04\x8f\
    \x01\x1b\x1c\n\x0c\n\x04\x05\x02\x02\x06\x12\x04\x90\x01\x02\x1f\n\r\n\
    \x05\x05\x02\x02\x06\x01\x12\x04\x90\x01\x02\x1a\n\r\n\x05\x05\x02\x02\
    \x06\x02\x12\x04\x90\x01\x1d\x1e\n\x0c\n\x04\x05\x02\x02\x07\x12\x04\x91\
    \x01\x02\"\n\r\n\x05\x05\x02\x02\x07\x01\x12\x04\x91\x01\x02\x1d\n\r\n\
    \x05\x05\x02\x02\x07\x02\x12\x04\x91\x01\x20!\n\x0c\n\x04\x05\x02\x02\
    \x08\x12\x04\x92\x01\x02\x1e\n\r\n\x05\x05\x02\x02\x08\x01\x12\x04\x92\
    \x01\x02\x19\n\r\n\x05\x05\x02\x02\x08\x02\x12\x04\x92\x01\x1c\x1d\n\x0c\
    \n\x04\x05\x02\x02\t\x12\x04\x93\x01\x02\x1c\n\r\n\x05\x05\x02\x02\t\x01\
    \x12\x04\x93\x01\x02\x17\n\r\n\x05\x05\x02\x02\t\x02\x12\x04\x93\x01\x1a\
    \x1b\n\x0c\n\x02\x05\x03\x12\x06\x96\x01\0\xa0\x01\x01\n\x0b\n\x03\x05\
    \x03\x01\x12\x04\x96\x01\x05\r\n\x0c\n\x04\x05\x03\x02\0\x12\x04\x97\x01\
    \x02\x1c\n\r\n\x05\x05\x03\x02\0\x01\x12\x04\x97\x01\x02\x17\n\r\n\x05\
    \x05\x03\x02\0\x02\x12\x04\x97\x01\x1a\x1b\n\x0c\n\x04\x05\x03\x02\x01\
    \x12\x04\x98\x01\x02\x1b\n\r\n\x05\x05\x03\x02\x01\x01\x12\x04\x98\x01\
    \x02\x16\n\r\n\x05\x05\x03\x02\x01\x02\x12\x04\x98\x01\x19\x1a\n\x0c\n\
    \x04\x05\x03\x02\x02\x12\x04\x99\x01\x02\x14\n\r\n\x05\x05\x03\x02\x02\
    \x01\x12\x04\x99\x01\x02\x0f\n\r\n\x05\x05\x03\x02\x02\x02\x12\x04\x99\
    \x01\x12\x13\n\x0c\n\x04\x05\x03\x02\x03\x12\x04\x9a\x01\x02\x19\n\r\n\
    \x05\x05\x03\x02\x03\x01\x12\x04\x9a\x01\x02\x14\n\r\n\x05\x05\x03\x02\
    \x03\x02\x12\x04\x9a\x01\x17\x18\n\x0c\n\x04\x05\x03\x02\x04\x12\x04\x9b\
    \x01\x02\x1f\n\r\n\x05\x05\x03\x02\x04\x01\x12\x04\x9b\x01\x02\x1a\n\r\n\
    \x05\x05\x03\x02\x04\x02\x12\x04\x9b\x01\x1d\x1e\n\x0c\n\x04\x05\x03\x02\
    \x05\x12\x04\x9c\x01\x02\x18\n\r\n\x05\x05\x03\x02\x05\x01\x12\x04\x9c\
    \x01\x02\x13\n\r\n\x05\x05\x03\x02\x05\x02\x12\x04\x9c\x01\x16\x17\n\x0c\
    \n\x04\x05\x03\x02\x06\x12\x04\x9d\x01\x02\x17\n\r\n\x05\x05\x03\x02\x06\
    \x01\x12\x04\x9d\x01\x02\x12\n\r\n\x05\x05\x03\x02\x06\x02\x12\x04\x9d\
    \x01\x15\x16\n\x0c\n\x04\x05\x03\x02\x07\x12\x04\x9e\x01\x02\x1b\n\r\n\
    \x05\x05\x03\x02\x07\x01\x12\x04\x9e\x01\x02\x16\n\r\n\x05\x05\x03\x02\
    \x07\x02\x12\x04\x9e\x01\x19\x1a\n\x0c\n\x04\x05\x03\x02\x08\x12\x04\x9f\
    \x01\x02\x16\n\r\n\x05\x05\x03\x02\x08\x01\x12\x04\x9f\x01\x02\x11\n\r\n\
    \x05\x05\x03\x02\x08\x02\x12\x04\x9f\x01\x14\x15\n\x0c\n\x02\x04\x06\x12\
    \x06\xa2\x01\0\xa5\x01\x01\n\x0b\n\x03\x04\x06\x01\x12\x04\xa2\x01\x08\
    \x0f\n;\n\x04\x04\x06\x02\0\x12\x04\xa3\x01\x02\x10\"-\x20tax\x20props..\
    .\x20[country,\x20rate,\x20created_at...]\n\n\r\n\x05\x04\x06\x02\0\x05\
    \x12\x04\xa3\x01\x02\x08\n\r\n\x05\x04\x06\x02\0\x01\x12\x04\xa3\x01\t\
    \x0b\n\r\n\x05\x04\x06\x02\0\x03\x12\x04\xa3\x01\x0e\x0f\n\x0c\n\x02\x05\
    \x04\x12\x06\xa7\x01\0\xb5\x01\x01\n\x0b\n\x03\x05\x04\x01\x12\x04\xa7\
    \x01\x05\x13\n\x0c\n\x04\x05\x04\x02\0\x12\x04\xa8\x01\x02\"\n\r\n\x05\
    \x05\x04\x02\0\x01\x12\x04\xa8\x01\x02\x1d\n\r\n\x05\x05\x04\x02\0\x02\
    \x12\x04\xa8\x01\x20!\n\x0c\n\x04\x05\x04\x02\x01\x12\x04\xa9\x01\x02\
    \x1b\n\r\n\x05\x05\x04\x02\x01\x01\x12\x04\xa9\x01\x02\x16\n\r\n\x05\x05\
    \x04\x02\x01\x02\x12\x04\xa9\x01\x19\x1a\n\x0c\n\x04\x05\x04\x02\x02\x12\
    \x04\xaa\x01\x02\x1b\n\r\n\x05\x05\x04\x02\x02\x01\x12\x04\xaa\x01\x02\
    \x16\n\r\n\x05\x05\x04\x02\x02\x02\x12\x04\xaa\x01\x19\x1a\n\x0c\n\x04\
    \x05\x04\x02\x03\x12\x04\xab\x01\x02\x1f\n\r\n\x05\x05\x04\x02\x03\x01\
    \x12\x04\xab\x01\x02\x1a\n\r\n\x05\x05\x04\x02\x03\x02\x12\x04\xab\x01\
    \x1d\x1e\n.\n\x04\x05\x04\x02\x04\x12\x04\xad\x01\x02\x1c\x1a\x20\x20EXP\
    ERIENCE_TYPE_EXCURSION\x20=\x203;\n\n\r\n\x05\x05\x04\x02\x04\x01\x12\
    \x04\xad\x01\x02\x17\n\r\n\x05\x05\x04\x02\x04\x02\x12\x04\xad\x01\x1a\
    \x1b\n\x0c\n\x04\x05\x04\x02\x05\x12\x04\xae\x01\x02!\n\r\n\x05\x05\x04\
    \x02\x05\x01\x12\x04\xae\x01\x02\x1c\n\r\n\x05\x05\x04\x02\x05\x02\x12\
    \x04\xae\x01\x1f\x20\n^\n\x04\x05\x04\x02\x06\x12\x04\xb1\x01\x02\x1b\
    \x1aP\x20TODO:\x20are\x20flights\x20and\x20rides\x20the\x20same\x20thing\
    ?\x20Don't\x20think\x20\n\x20people\x20feel\x20that\x20way\n\n\r\n\x05\
    \x05\x04\x02\x06\x01\x12\x04\xb1\x01\x02\x16\n\r\n\x05\x05\x04\x02\x06\
    \x02\x12\x04\xb1\x01\x19\x1a\n\x0c\n\x04\x05\x04\x02\x07\x12\x04\xb2\x01\
    \x02\x1d\n\r\n\x05\x05\x04\x02\x07\x01\x12\x04\xb2\x01\x02\x18\n\r\n\x05\
    \x05\x04\x02\x07\x02\x12\x04\xb2\x01\x1b\x1c\n-\n\x04\x05\x04\x02\x08\
    \x12\x04\xb3\x01\x02\x1e\"\x1f\x20EXPERIENCE_TYPE_YACHT_CHARTER\n\n\r\n\
    \x05\x05\x04\x02\x08\x01\x12\x04\xb3\x01\x02\x19\n\r\n\x05\x05\x04\x02\
    \x08\x02\x12\x04\xb3\x01\x1c\x1d\n\x0c\n\x02\x04\x07\x12\x06\xb7\x01\0\
    \xc0\x01\x01\n\x0b\n\x03\x04\x07\x01\x12\x04\xb7\x01\x08\x17\n\x0c\n\x04\
    \x04\x07\x02\0\x12\x04\xb8\x01\x02\x10\n\r\n\x05\x04\x07\x02\0\x05\x12\
    \x04\xb8\x01\x02\x08\n\r\n\x05\x04\x07\x02\0\x01\x12\x04\xb8\x01\t\x0b\n\
    \r\n\x05\x04\x07\x02\0\x03\x12\x04\xb8\x01\x0e\x0f\n\x0c\n\x04\x04\x07\
    \x02\x01\x12\x04\xb9\x01\x02\x12\n\r\n\x05\x04\x07\x02\x01\x05\x12\x04\
    \xb9\x01\x02\x08\n\r\n\x05\x04\x07\x02\x01\x01\x12\x04\xb9\x01\t\r\n\r\n\
    \x05\x04\x07\x02\x01\x03\x12\x04\xb9\x01\x10\x11\n\x0c\n\x04\x04\x07\x02\
    \x02\x12\x04\xba\x01\x02\x19\n\r\n\x05\x04\x07\x02\x02\x05\x12\x04\xba\
    \x01\x02\x08\n\r\n\x05\x04\x07\x02\x02\x01\x12\x04\xba\x01\t\x14\n\r\n\
    \x05\x04\x07\x02\x02\x03\x12\x04\xba\x01\x17\x18\n\x0c\n\x04\x04\x07\x02\
    \x03\x12\x04\xbb\x01\x02\x16\n\r\n\x05\x04\x07\x02\x03\x05\x12\x04\xbb\
    \x01\x02\x07\n\r\n\x05\x04\x07\x02\x03\x01\x12\x04\xbb\x01\x08\x11\n\r\n\
    \x05\x04\x07\x02\x03\x03\x12\x04\xbb\x01\x14\x15\n\x0c\n\x04\x04\x07\x02\
    \x04\x12\x04\xbc\x01\x02\x18\n\r\n\x05\x04\x07\x02\x04\x06\x12\x04\xbc\
    \x01\x02\n\n\r\n\x05\x04\x07\x02\x04\x01\x12\x04\xbc\x01\x0b\x13\n\r\n\
    \x05\x04\x07\x02\x04\x03\x12\x04\xbc\x01\x16\x17\n\x0c\n\x04\x04\x07\x02\
    \x05\x12\x04\xbd\x01\x02\x1c\n\r\n\x05\x04\x07\x02\x05\x05\x12\x04\xbd\
    \x01\x02\x08\n\r\n\x05\x04\x07\x02\x05\x01\x12\x04\xbd\x01\t\x17\n\r\n\
    \x05\x04\x07\x02\x05\x03\x12\x04\xbd\x01\x1a\x1b\n\x0c\n\x04\x04\x07\x02\
    \x06\x12\x04\xbe\x01\x02\x1c\n\r\n\x05\x04\x07\x02\x06\x05\x12\x04\xbe\
    \x01\x02\x08\n\r\n\x05\x04\x07\x02\x06\x01\x12\x04\xbe\x01\t\x17\n\r\n\
    \x05\x04\x07\x02\x06\x03\x12\x04\xbe\x01\x1a\x1b\n\x0c\n\x04\x04\x07\x02\
    \x07\x12\x04\xbf\x01\x02$\n\r\n\x05\x04\x07\x02\x07\x06\x12\x04\xbf\x01\
    \x02\x15\n\r\n\x05\x04\x07\x02\x07\x01\x12\x04\xbf\x01\x16\x1e\n\r\n\x05\
    \x04\x07\x02\x07\x03\x12\x04\xbf\x01!#\n\x0c\n\x02\x04\x08\x12\x06\xc2\
    \x01\0\xcc\x01\x01\n\x0b\n\x03\x04\x08\x01\x12\x04\xc2\x01\x08\x10\n\x0c\
    \n\x04\x04\x08\x02\0\x12\x04\xc3\x01\x02\x10\n\r\n\x05\x04\x08\x02\0\x05\
    \x12\x04\xc3\x01\x02\x08\n\r\n\x05\x04\x08\x02\0\x01\x12\x04\xc3\x01\t\
    \x0b\n\r\n\x05\x04\x08\x02\0\x03\x12\x04\xc3\x01\x0e\x0f\n\x0c\n\x04\x04\
    \x08\x02\x01\x12\x04\xc4\x01\x02\x12\n\r\n\x05\x04\x08\x02\x01\x05\x12\
    \x04\xc4\x01\x02\x08\n\r\n\x05\x04\x08\x02\x01\x01\x12\x04\xc4\x01\t\r\n\
    \r\n\x05\x04\x08\x02\x01\x03\x12\x04\xc4\x01\x10\x11\n\x0c\n\x04\x04\x08\
    \x02\x02\x12\x04\xc5\x01\x02\x19\n\r\n\x05\x04\x08\x02\x02\x05\x12\x04\
    \xc5\x01\x02\x08\n\r\n\x05\x04\x08\x02\x02\x01\x12\x04\xc5\x01\t\x14\n\r\
    \n\x05\x04\x08\x02\x02\x03\x12\x04\xc5\x01\x17\x18\n\x0c\n\x04\x04\x08\
    \x02\x03\x12\x04\xc6\x01\x02\x16\n\r\n\x05\x04\x08\x02\x03\x06\x12\x04\
    \xc6\x01\x02\t\n\r\n\x05\x04\x08\x02\x03\x01\x12\x04\xc6\x01\n\x11\n\r\n\
    \x05\x04\x08\x02\x03\x03\x12\x04\xc6\x01\x14\x15\n\x0c\n\x04\x04\x08\x02\
    \x04\x12\x04\xc7\x01\x02\x0e\n\r\n\x05\x04\x08\x02\x04\x06\x12\x04\xc7\
    \x01\x02\x05\n\r\n\x05\x04\x08\x02\x04\x01\x12\x04\xc7\x01\x06\t\n\r\n\
    \x05\x04\x08\x02\x04\x03\x12\x04\xc7\x01\x0c\r\n2\n\x04\x04\x08\x02\x05\
    \x12\x04\xc8\x01\x02\x18\"$\x20TODO:\x20add\x20prev\x20&&\x20next\x20bea\
    rfing??\x20\n\n\r\n\x05\x04\x08\x02\x05\x06\x12\x04\xc8\x01\x02\x0e\n\r\
    \n\x05\x04\x08\x02\x05\x01\x12\x04\xc8\x01\x0f\x13\n\r\n\x05\x04\x08\x02\
    \x05\x03\x12\x04\xc8\x01\x16\x17\n\x0c\n\x02\x05\x05\x12\x06\xce\x01\0\
    \xd7\x01\x01\n\x0b\n\x03\x05\x05\x01\x12\x04\xce\x01\x05\x11\n\x0c\n\x04\
    \x05\x05\x02\0\x12\x04\xcf\x01\x02\x20\n\r\n\x05\x05\x05\x02\0\x01\x12\
    \x04\xcf\x01\x02\x1b\n\r\n\x05\x05\x05\x02\0\x02\x12\x04\xcf\x01\x1e\x1f\
    \n\x0c\n\x04\x05\x05\x02\x01\x12\x04\xd0\x01\x02\x19\n\r\n\x05\x05\x05\
    \x02\x01\x01\x12\x04\xd0\x01\x02\x14\n\r\n\x05\x05\x05\x02\x01\x02\x12\
    \x04\xd0\x01\x17\x18\n\x0c\n\x04\x05\x05\x02\x02\x12\x04\xd1\x01\x02\x1f\
    \n\r\n\x05\x05\x05\x02\x02\x01\x12\x04\xd1\x01\x02\x1a\n\r\n\x05\x05\x05\
    \x02\x02\x02\x12\x04\xd1\x01\x1d\x1e\n\x0c\n\x04\x05\x05\x02\x03\x12\x04\
    \xd2\x01\x02!\n\r\n\x05\x05\x05\x02\x03\x01\x12\x04\xd2\x01\x02\x1c\n\r\
    \n\x05\x05\x05\x02\x03\x02\x12\x04\xd2\x01\x1f\x20\n\x0c\n\x04\x05\x05\
    \x02\x04\x12\x04\xd3\x01\x02\x20\n\r\n\x05\x05\x05\x02\x04\x01\x12\x04\
    \xd3\x01\x02\x1b\n\r\n\x05\x05\x05\x02\x04\x02\x12\x04\xd3\x01\x1e\x1f\n\
    \x0c\n\x04\x05\x05\x02\x05\x12\x04\xd4\x01\x02\x1b\n\r\n\x05\x05\x05\x02\
    \x05\x01\x12\x04\xd4\x01\x02\x16\n\r\n\x05\x05\x05\x02\x05\x02\x12\x04\
    \xd4\x01\x19\x1a\n\x0c\n\x04\x05\x05\x02\x06\x12\x04\xd5\x01\x02\x1c\n\r\
    \n\x05\x05\x05\x02\x06\x01\x12\x04\xd5\x01\x02\x17\n\r\n\x05\x05\x05\x02\
    \x06\x02\x12\x04\xd5\x01\x1a\x1b\n\x0c\n\x04\x05\x05\x02\x07\x12\x04\xd6\
    \x01\x02\x1a\n\r\n\x05\x05\x05\x02\x07\x01\x12\x04\xd6\x01\x02\x15\n\r\n\
    \x05\x05\x05\x02\x07\x02\x12\x04\xd6\x01\x18\x19\n\x0c\n\x02\x04\t\x12\
    \x06\xd8\x01\0\xdf\x01\x01\n\x0b\n\x03\x04\t\x01\x12\x04\xd8\x01\x08\x0b\
    \n\x0c\n\x04\x04\t\x02\0\x12\x04\xd9\x01\x02\x15\n\r\n\x05\x04\t\x02\0\
    \x05\x12\x04\xd9\x01\x02\x07\n\r\n\x05\x04\t\x02\0\x01\x12\x04\xd9\x01\
    \x08\x10\n\r\n\x05\x04\t\x02\0\x03\x12\x04\xd9\x01\x13\x14\n\x0c\n\x04\
    \x04\t\x02\x01\x12\x04\xda\x01\x02\x16\n\r\n\x05\x04\t\x02\x01\x05\x12\
    \x04\xda\x01\x02\x07\n\r\n\x05\x04\t\x02\x01\x01\x12\x04\xda\x01\x08\x11\
    \n\r\n\x05\x04\t\x02\x01\x03\x12\x04\xda\x01\x14\x15\n\x0c\n\x04\x04\t\
    \x02\x02\x12\x04\xdb\x01\x02\x15\n\r\n\x05\x04\t\x02\x02\x05\x12\x04\xdb\
    \x01\x02\x07\n\r\n\x05\x04\t\x02\x02\x01\x12\x04\xdb\x01\x08\x10\n\r\n\
    \x05\x04\t\x02\x02\x03\x12\x04\xdb\x01\x13\x14\n\x0c\n\x04\x04\t\x02\x03\
    \x12\x04\xdc\x01\x02\x12\n\r\n\x05\x04\t\x02\x03\x05\x12\x04\xdc\x01\x02\
    \x07\n\r\n\x05\x04\t\x02\x03\x01\x12\x04\xdc\x01\x08\r\n\r\n\x05\x04\t\
    \x02\x03\x03\x12\x04\xdc\x01\x10\x11\n\x0c\n\x04\x04\t\x02\x04\x12\x04\
    \xdd\x01\x02\x14\n\r\n\x05\x04\t\x02\x04\x05\x12\x04\xdd\x01\x02\x07\n\r\
    \n\x05\x04\t\x02\x04\x01\x12\x04\xdd\x01\x08\x0f\n\r\n\x05\x04\t\x02\x04\
    \x03\x12\x04\xdd\x01\x12\x13\n\x0c\n\x04\x04\t\x02\x05\x12\x04\xde\x01\
    \x02\x15\n\r\n\x05\x04\t\x02\x05\x05\x12\x04\xde\x01\x02\x07\n\r\n\x05\
    \x04\t\x02\x05\x01\x12\x04\xde\x01\x08\x10\n\r\n\x05\x04\t\x02\x05\x03\
    \x12\x04\xde\x01\x13\x14\n\x0c\n\x02\x04\n\x12\x06\xe1\x01\0\xe8\x01\x01\
    \n\x0b\n\x03\x04\n\x01\x12\x04\xe1\x01\x08\x0f\n\x0c\n\x04\x04\n\x02\0\
    \x12\x04\xe2\x01\x02\x14\n\r\n\x05\x04\n\x02\0\x05\x12\x04\xe2\x01\x02\
    \x08\n\r\n\x05\x04\n\x02\0\x01\x12\x04\xe2\x01\t\x0f\n\r\n\x05\x04\n\x02\
    \0\x03\x12\x04\xe2\x01\x12\x13\n\x0c\n\x04\x04\n\x02\x01\x12\x04\xe3\x01\
    \x02\x16\n\r\n\x05\x04\n\x02\x01\x05\x12\x04\xe3\x01\x02\x08\n\r\n\x05\
    \x04\n\x02\x01\x01\x12\x04\xe3\x01\t\x11\n\r\n\x05\x04\n\x02\x01\x03\x12\
    \x04\xe3\x01\x14\x15\n\x0c\n\x04\x04\n\x02\x02\x12\x04\xe4\x01\x02\x12\n\
    \r\n\x05\x04\n\x02\x02\x05\x12\x04\xe4\x01\x02\x08\n\r\n\x05\x04\n\x02\
    \x02\x01\x12\x04\xe4\x01\t\r\n\r\n\x05\x04\n\x02\x02\x03\x12\x04\xe4\x01\
    \x10\x11\n\x0c\n\x04\x04\n\x02\x03\x12\x04\xe5\x01\x02\x13\n\r\n\x05\x04\
    \n\x02\x03\x05\x12\x04\xe5\x01\x02\x08\n\r\n\x05\x04\n\x02\x03\x01\x12\
    \x04\xe5\x01\t\x0e\n\r\n\x05\x04\n\x02\x03\x03\x12\x04\xe5\x01\x11\x12\n\
    \x0c\n\x04\x04\n\x02\x04\x12\x04\xe6\x01\x02\x15\n\r\n\x05\x04\n\x02\x04\
    \x05\x12\x04\xe6\x01\x02\x08\n\r\n\x05\x04\n\x02\x04\x01\x12\x04\xe6\x01\
    \t\x10\n\r\n\x05\x04\n\x02\x04\x03\x12\x04\xe6\x01\x13\x14\n\x0c\n\x04\
    \x04\n\x02\x05\x12\x04\xe7\x01\x02\x11\n\r\n\x05\x04\n\x02\x05\x05\x12\
    \x04\xe7\x01\x02\x08\n\r\n\x05\x04\n\x02\x05\x01\x12\x04\xe7\x01\t\x0c\n\
    \r\n\x05\x04\n\x02\x05\x03\x12\x04\xe7\x01\x0f\x10\ns\n\x02\x04\x0b\x12\
    \x06\xec\x01\0\xf1\x01\x01\x1ae\x20Meant\x20to\x20be\x20super\x20flexibl\
    e\x20to\x20allow\x20for\x20any\x20type\x20of\x20query\n\x20still\x20with\
    \x20some\x20level\x20of\x20static\x20typing.\x20\n\n\x0b\n\x03\x04\x0b\
    \x01\x12\x04\xec\x01\x08\r\n\x0c\n\x04\x04\x0b\x02\0\x12\x04\xed\x01\x02\
    \x1a\n\r\n\x05\x04\x0b\x02\0\x04\x12\x04\xed\x01\x02\n\n\r\n\x05\x04\x0b\
    \x02\0\x06\x12\x04\xed\x01\x0b\x0f\n\r\n\x05\x04\x0b\x02\0\x01\x12\x04\
    \xed\x01\x10\x15\n\r\n\x05\x04\x0b\x02\0\x03\x12\x04\xed\x01\x18\x19\n\
    \x0c\n\x04\x04\x0b\x02\x01\x12\x04\xee\x01\x02\x11\n\r\n\x05\x04\x0b\x02\
    \x01\x05\x12\x04\xee\x01\x02\x07\n\r\n\x05\x04\x0b\x02\x01\x01\x12\x04\
    \xee\x01\x08\x0c\n\r\n\x05\x04\x0b\x02\x01\x03\x12\x04\xee\x01\x0f\x10\n\
    \x0c\n\x04\x04\x0b\x02\x02\x12\x04\xef\x01\x02\x16\n\r\n\x05\x04\x0b\x02\
    \x02\x05\x12\x04\xef\x01\x02\x07\n\r\n\x05\x04\x0b\x02\x02\x01\x12\x04\
    \xef\x01\x08\x11\n\r\n\x05\x04\x0b\x02\x02\x03\x12\x04\xef\x01\x14\x15\n\
    \x0c\n\x04\x04\x0b\x02\x03\x12\x04\xf0\x01\x02\x12\n\r\n\x05\x04\x0b\x02\
    \x03\x06\x12\x04\xf0\x01\x02\x07\n\r\n\x05\x04\x0b\x02\x03\x01\x12\x04\
    \xf0\x01\x08\r\n\r\n\x05\x04\x0b\x02\x03\x03\x12\x04\xf0\x01\x10\x11\n\
    \x0c\n\x02\x04\x0c\x12\x06\xf3\x01\0\xf9\x01\x01\n\x0b\n\x03\x04\x0c\x01\
    \x12\x04\xf3\x01\x08\x0c\n\x87\x01\n\x04\x04\x0c\x02\0\x12\x04\xf6\x01\
    \x02\x11\x1ay\x20TODO:\x20make\x20type\x20an\x20enum:\x20[string,\x20int\
    ,\x20float,\x20bool,\x20\n\x20date,\x20time,\x20datetime,\x20geo,\x20add\
    ress,\x20phone,\x20email,\x20url,\x20uuid,\x20id]\\\n\n\r\n\x05\x04\x0c\
    \x02\0\x05\x12\x04\xf6\x01\x02\x08\n\r\n\x05\x04\x0c\x02\0\x01\x12\x04\
    \xf6\x01\t\x0c\n\r\n\x05\x04\x0c\x02\0\x03\x12\x04\xf6\x01\x0f\x10\n!\n\
    \x04\x04\x0c\x02\x01\x12\x04\xf7\x01\x02\x13\"\x13\x20int64\x20weight\
    \x20=\x204;\n\n\r\n\x05\x04\x0c\x02\x01\x05\x12\x04\xf7\x01\x02\x08\n\r\
    \n\x05\x04\x0c\x02\x01\x01\x12\x04\xf7\x01\t\x0e\n\r\n\x05\x04\x0c\x02\
    \x01\x03\x12\x04\xf7\x01\x11\x12\n\x0c\n\x02\x05\x06\x12\x06\xfb\x01\0\
    \xff\x01\x01\n\x0b\n\x03\x05\x06\x01\x12\x04\xfb\x01\x05\n\n\x0c\n\x04\
    \x05\x06\x02\0\x12\x04\xfc\x01\x02\x18\n\r\n\x05\x05\x06\x02\0\x01\x12\
    \x04\xfc\x01\x02\x13\n\r\n\x05\x05\x06\x02\0\x02\x12\x04\xfc\x01\x16\x17\
    \n\x0c\n\x04\x05\x06\x02\x01\x12\x04\xfd\x01\x02\x10\n\r\n\x05\x05\x06\
    \x02\x01\x01\x12\x04\xfd\x01\x02\x0b\n\r\n\x05\x05\x06\x02\x01\x02\x12\
    \x04\xfd\x01\x0e\x0f\n\x0c\n\x04\x05\x06\x02\x02\x12\x04\xfe\x01\x02\x11\
    \n\r\n\x05\x05\x06\x02\x02\x01\x12\x04\xfe\x01\x02\x0c\n\r\n\x05\x05\x06\
    \x02\x02\x02\x12\x04\xfe\x01\x0f\x10\n\x0c\n\x02\x04\r\x12\x06\x81\x02\0\
    \x90\x02\x01\n\x0b\n\x03\x04\r\x01\x12\x04\x81\x02\x08\x0e\n\x0c\n\x04\
    \x04\r\x02\0\x12\x04\x82\x02\x02\x10\n\r\n\x05\x04\r\x02\0\x05\x12\x04\
    \x82\x02\x02\x08\n\r\n\x05\x04\r\x02\0\x01\x12\x04\x82\x02\t\x0b\n\r\n\
    \x05\x04\r\x02\0\x03\x12\x04\x82\x02\x0e\x0f\n\x0c\n\x04\x04\r\x02\x01\
    \x12\x04\x83\x02\x02\x16\n\r\n\x05\x04\r\x02\x01\x05\x12\x04\x83\x02\x02\
    \x08\n\r\n\x05\x04\r\x02\x01\x01\x12\x04\x83\x02\t\x11\n\r\n\x05\x04\r\
    \x02\x01\x03\x12\x04\x83\x02\x14\x15\n\x0c\n\x04\x04\r\x02\x02\x12\x04\
    \x84\x02\x02\x18\n\r\n\x05\x04\r\x02\x02\x05\x12\x04\x84\x02\x02\x08\n\r\
    \n\x05\x04\r\x02\x02\x01\x12\x04\x84\x02\t\x13\n\r\n\x05\x04\r\x02\x02\
    \x03\x12\x04\x84\x02\x16\x17\n\x0c\n\x04\x04\r\x02\x03\x12\x04\x85\x02\
    \x02\x18\n\r\n\x05\x04\r\x02\x03\x05\x12\x04\x85\x02\x02\x08\n\r\n\x05\
    \x04\r\x02\x03\x01\x12\x04\x85\x02\t\x13\n\r\n\x05\x04\r\x02\x03\x03\x12\
    \x04\x85\x02\x16\x17\n\x0c\n\x04\x04\r\x02\x04\x12\x04\x86\x02\x02\x12\n\
    \r\n\x05\x04\r\x02\x04\x05\x12\x04\x86\x02\x02\x07\n\r\n\x05\x04\r\x02\
    \x04\x01\x12\x04\x86\x02\x08\r\n\r\n\x05\x04\r\x02\x04\x03\x12\x04\x86\
    \x02\x10\x11\n\x0c\n\x04\x04\r\x02\x05\x12\x04\x87\x02\x02\x15\n\r\n\x05\
    \x04\r\x02\x05\x05\x12\x04\x87\x02\x02\x08\n\r\n\x05\x04\r\x02\x05\x01\
    \x12\x04\x87\x02\t\x10\n\r\n\x05\x04\r\x02\x05\x03\x12\x04\x87\x02\x13\
    \x14\n\x0c\n\x04\x04\r\x02\x06\x12\x04\x88\x02\x02\x18\n\r\n\x05\x04\r\
    \x02\x06\x05\x12\x04\x88\x02\x02\x08\n\r\n\x05\x04\r\x02\x06\x01\x12\x04\
    \x88\x02\t\x13\n\r\n\x05\x04\r\x02\x06\x03\x12\x04\x88\x02\x16\x17\n\x0c\
    \n\x04\x04\r\x02\x07\x12\x04\x89\x02\x02\x18\n\r\n\x05\x04\r\x02\x07\x05\
    \x12\x04\x89\x02\x02\x08\n\r\n\x05\x04\r\x02\x07\x01\x12\x04\x89\x02\t\
    \x13\n\r\n\x05\x04\r\x02\x07\x03\x12\x04\x89\x02\x16\x17\n\x0c\n\x04\x04\
    \r\x02\x08\x12\x04\x8a\x02\x02\x18\n\r\n\x05\x04\r\x02\x08\x05\x12\x04\
    \x8a\x02\x02\x08\n\r\n\x05\x04\r\x02\x08\x01\x12\x04\x8a\x02\t\x13\n\r\n\
    \x05\x04\r\x02\x08\x03\x12\x04\x8a\x02\x16\x17\n\x0e\n\x04\x04\r\x08\0\
    \x12\x06\x8b\x02\x02\x8f\x02\x03\n\r\n\x05\x04\r\x08\0\x01\x12\x04\x8b\
    \x02\x08\x13\nL\n\x04\x04\r\x02\t\x12\x04\x8c\x02\x04\x17\">\x20HotelRat\
    ing\x20hotel_rating\x20=\x2010;\n\x20RoomRating\x20room_rating\x20=\x201\
    1;\n\n\r\n\x05\x04\r\x02\t\x05\x12\x04\x8c\x02\x04\n\n\r\n\x05\x04\r\x02\
    \t\x01\x12\x04\x8c\x02\x0b\x11\n\r\n\x05\x04\r\x02\t\x03\x12\x04\x8c\x02\
    \x14\x16\n*\n\x02\x05\x07\x12\x06\x92\x02\0\x97\x02\x01\"\x1c\x20TODO:\
    \x20update\x20to\x20EntityType\n\n\x0b\n\x03\x05\x07\x01\x12\x04\x92\x02\
    \x05\x10\n\x0c\n\x04\x05\x07\x02\0\x12\x04\x93\x02\x02\x1f\n\r\n\x05\x05\
    \x07\x02\0\x01\x12\x04\x93\x02\x02\x1a\n\r\n\x05\x05\x07\x02\0\x02\x12\
    \x04\x93\x02\x1d\x1e\n\x0c\n\x04\x05\x07\x02\x01\x12\x04\x94\x02\x02\x19\
    \n\r\n\x05\x05\x07\x02\x01\x01\x12\x04\x94\x02\x02\x14\n\r\n\x05\x05\x07\
    \x02\x01\x02\x12\x04\x94\x02\x17\x18\n\x0c\n\x04\x05\x07\x02\x02\x12\x04\
    \x95\x02\x02\x1b\n\r\n\x05\x05\x07\x02\x02\x01\x12\x04\x95\x02\x02\x16\n\
    \r\n\x05\x05\x07\x02\x02\x02\x12\x04\x95\x02\x19\x1a\n\x0c\n\x04\x05\x07\
    \x02\x03\x12\x04\x96\x02\x02\x1d\n\r\n\x05\x05\x07\x02\x03\x01\x12\x04\
    \x96\x02\x02\x18\n\r\n\x05\x05\x07\x02\x03\x02\x12\x04\x96\x02\x1b\x1c\n\
    3\n\x02\x04\x0e\x12\x06\x99\x02\0\x9d\x02\x01\x1a%\x20TODO:\x20look\x20i\
    n\x20to\x20analytics\x20tracking\n\n\x0b\n\x03\x04\x0e\x01\x12\x04\x99\
    \x02\x08\x12\n\x0c\n\x04\x04\x0e\x02\0\x12\x04\x9a\x02\x02\x10\n\r\n\x05\
    \x04\x0e\x02\0\x05\x12\x04\x9a\x02\x02\x08\n\r\n\x05\x04\x0e\x02\0\x01\
    \x12\x04\x9a\x02\t\x0b\n\r\n\x05\x04\x0e\x02\0\x03\x12\x04\x9a\x02\x0e\
    \x0f\n\x0c\n\x04\x04\x0e\x02\x01\x12\x04\x9b\x02\x02\x15\n\r\n\x05\x04\
    \x0e\x02\x01\x05\x12\x04\x9b\x02\x02\x07\n\r\n\x05\x04\x0e\x02\x01\x01\
    \x12\x04\x9b\x02\x08\x10\n\r\n\x05\x04\x0e\x02\x01\x03\x12\x04\x9b\x02\
    \x13\x14\nF\n\x04\x04\x0e\x02\x02\x12\x04\x9c\x02\x02\x14\"8\x20TODO:\
    \x20or\x20are\x20guests\x20the\x20only\x20sources\x20for\x20impressions?\
    \x20\n\n\r\n\x05\x04\x0e\x02\x02\x06\x12\x04\x9c\x02\x02\x08\n\r\n\x05\
    \x04\x0e\x02\x02\x01\x12\x04\x9c\x02\t\x0f\n\r\n\x05\x04\x0e\x02\x02\x03\
    \x12\x04\x9c\x02\x12\x13\n\x0c\n\x02\x04\x0f\x12\x06\x9f\x02\0\xa5\x02\
    \x01\n\x0b\n\x03\x04\x0f\x01\x12\x04\x9f\x02\x08\x0e\n9\n\x04\x04\x0f\
    \x02\0\x12\x04\xa0\x02\x02\x10\"+\x20oneof\x20type\x20{\n\x20\x20\x20\
    \x20\x20users.Guest\x20guest\x20=\x203;\x20\n\n\r\n\x05\x04\x0f\x02\0\
    \x05\x12\x04\xa0\x02\x02\x08\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\xa0\x02\
    \t\x0b\n\r\n\x05\x04\x0f\x02\0\x03\x12\x04\xa0\x02\x0e\x0f\n\x8c\x03\n\
    \x02\x04\x10\x12\x06\xb1\x02\0\xc6\x02\x01\x1a\xa1\x02\x20A\x20calendar\
    \x20is\x20a\x20collection\x20of\x20related\x20events,\x20as\x20well\x20a\
    s\x20additional\x20\nmetadata\x20that\x20defines\x20it.\x20Each\x20\x20\
    \ncalendar\x20is\x20identified\x20by\x20an\x20ID\x20which\x20is\x20an\
    \x20email\x20address.\x20Calendars\x20\ncan\x20have\x20multiple\x20owner\
    s.\x20When\x20a\x20reservation\x20is\x20created\x20a\x20calendar\x20is\
    \x20\ncreated\x20as\x20well\x20and\x20tied\x20to\x20the\x20reservation.\
    \x202Z\x20enum\x20Relationship\x20{\n\x20\x20\x20RELATIONSHIP_UNSPECIFIE\
    D\x20=\x200;\n\x20\x20\x20RELATIONSHIP_EMPLOYEE_OF\x20=\x201;\n\x20}\n\n\
    \x0b\n\x03\x04\x10\x01\x12\x04\xb1\x02\x08\x10\n\x0c\n\x04\x04\x10\x02\0\
    \x12\x04\xb2\x02\x02\x10\n\r\n\x05\x04\x10\x02\0\x05\x12\x04\xb2\x02\x02\
    \x08\n\r\n\x05\x04\x10\x02\0\x01\x12\x04\xb2\x02\t\x0b\n\r\n\x05\x04\x10\
    \x02\0\x03\x12\x04\xb2\x02\x0e\x0f\n\x0c\n\x04\x04\x10\x02\x01\x12\x04\
    \xb3\x02\x02\x16\n\r\n\x05\x04\x10\x02\x01\x05\x12\x04\xb3\x02\x02\x08\n\
    \r\n\x05\x04\x10\x02\x01\x01\x12\x04\xb3\x02\t\x11\n\r\n\x05\x04\x10\x02\
    \x01\x03\x12\x04\xb3\x02\x14\x15\n\x0c\n\x04\x04\x10\x02\x02\x12\x04\xb4\
    \x02\x02\x19\n\r\n\x05\x04\x10\x02\x02\x05\x12\x04\xb4\x02\x02\x08\n\r\n\
    \x05\x04\x10\x02\x02\x01\x12\x04\xb4\x02\t\x14\n\r\n\x05\x04\x10\x02\x02\
    \x03\x12\x04\xb4\x02\x17\x18\n\x0c\n\x04\x04\x10\x02\x03\x12\x04\xb5\x02\
    \x02\x12\n\r\n\x05\x04\x10\x02\x03\x05\x12\x04\xb5\x02\x02\x08\n\r\n\x05\
    \x04\x10\x02\x03\x01\x12\x04\xb5\x02\t\r\n\r\n\x05\x04\x10\x02\x03\x03\
    \x12\x04\xb5\x02\x10\x11\n\x0c\n\x04\x04\x10\x02\x04\x12\x04\xb6\x02\x02\
    \x19\n\r\n\x05\x04\x10\x02\x04\x05\x12\x04\xb6\x02\x02\x08\n\r\n\x05\x04\
    \x10\x02\x04\x01\x12\x04\xb6\x02\t\x14\n\r\n\x05\x04\x10\x02\x04\x03\x12\
    \x04\xb6\x02\x17\x18\n\x0c\n\x04\x04\x10\x02\x05\x12\x04\xb7\x02\x02\x17\
    \n\r\n\x05\x04\x10\x02\x05\x05\x12\x04\xb7\x02\x02\x07\n\r\n\x05\x04\x10\
    \x02\x05\x01\x12\x04\xb7\x02\x08\x12\n\r\n\x05\x04\x10\x02\x05\x03\x12\
    \x04\xb7\x02\x15\x16\n\x0c\n\x04\x04\x10\x02\x06\x12\x04\xb8\x02\x02\x17\
    \n\r\n\x05\x04\x10\x02\x06\x05\x12\x04\xb8\x02\x02\x07\n\r\n\x05\x04\x10\
    \x02\x06\x01\x12\x04\xb8\x02\x08\x12\n\r\n\x05\x04\x10\x02\x06\x03\x12\
    \x04\xb8\x02\x15\x16\n\x0c\n\x04\x04\x10\x02\x07\x12\x04\xb9\x02\x02!\n\
    \r\n\x05\x04\x10\x02\x07\x04\x12\x04\xb9\x02\x02\n\n\r\n\x05\x04\x10\x02\
    \x07\x06\x12\x04\xb9\x02\x0b\x16\n\r\n\x05\x04\x10\x02\x07\x01\x12\x04\
    \xb9\x02\x17\x1c\n\r\n\x05\x04\x10\x02\x07\x03\x12\x04\xb9\x02\x1f\x20\n\
    \xa8\x01\n\x04\x04\x10\x02\x08\x12\x04\xba\x02\x02\x1c\"\x99\x01\nowner_\
    id\nrepeated\x20Guests\x20owners\x20=\x20x;\x20\nreservation_id\x20\nrul\
    es\nrepeated\x20Event\x20events\nDays/Slots\nrepeated\x20Guest\x20viewer\
    s\nstring\x20time_zone\nstring\x20description\n\n\r\n\x05\x04\x10\x02\
    \x08\x04\x12\x04\xba\x02\x02\n\n\r\n\x05\x04\x10\x02\x08\x06\x12\x04\xba\
    \x02\x0b\x10\n\r\n\x05\x04\x10\x02\x08\x01\x12\x04\xba\x02\x11\x17\n\r\n\
    \x05\x04\x10\x02\x08\x03\x12\x04\xba\x02\x1a\x1b\nT\n\x02\x04\x11\x12\
    \x06\xc9\x02\0\xdd\x02\x01\x1aFAn\x20event\x20is\x20an\x20object\x20asso\
    ciated\x20with\x20a\x20specific\x20date\x20or\x20time\x20range.\x20\n\n\
    \x0b\n\x03\x04\x11\x01\x12\x04\xc9\x02\x08\r\n\x0c\n\x04\x04\x11\x02\0\
    \x12\x04\xca\x02\x02\x10\n\r\n\x05\x04\x11\x02\0\x05\x12\x04\xca\x02\x02\
    \x08\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\xca\x02\t\x0b\n\r\n\x05\x04\x11\
    \x02\0\x03\x12\x04\xca\x02\x0e\x0f\n4\n\x04\x04\x11\x02\x01\x12\x04\xcb\
    \x02\x02\x20\"&\x20The\x20calendar\x20the\x20governs\x20the\x20event.\
    \x20\n\n\r\n\x05\x04\x11\x02\x01\x06\x12\x04\xcb\x02\x02\n\n\r\n\x05\x04\
    \x11\x02\x01\x01\x12\x04\xcb\x02\x0b\x1b\n\r\n\x05\x04\x11\x02\x01\x03\
    \x12\x04\xcb\x02\x1e\x1f\n\xcc\x02\n\x04\x04\x11\x02\x02\x12\x04\xcd\x02\
    \x02-\x1aK\x20Calendars\x20where\x20the\x20event\x20would\x20show\x20i.e\
    .\x20calendars\x20of\x20attending\x20guests.\x20\n\"\xf0\x01\nstart_date\
    \nend_date\n....\nstring\x20description\x20\nStatus\x20status\nrepeated\
    \x20Reminder\x20reminders\x20\nrepeated\x20Attatchment\x20attachments\ni\
    nt64\x20start_time\x20=\x20x;\x20\nint64\x20end_time\x20=\x20x;\x20\nLoc\
    ation\x20location\x20=\x20x;\x20\nGuest\x20organizer\x20=\x20x;\nrepeate\
    d\x20Guest\x20guests\x20=\x20x;\x20\n\n\n\r\n\x05\x04\x11\x02\x02\x04\
    \x12\x04\xcd\x02\x02\n\n\r\n\x05\x04\x11\x02\x02\x06\x12\x04\xcd\x02\x0b\
    \x13\n\r\n\x05\x04\x11\x02\x02\x01\x12\x04\xcd\x02\x14(\n\r\n\x05\x04\
    \x11\x02\x02\x03\x12\x04\xcd\x02+,\n\x0c\n\x02\x04\x12\x12\x06\xdf\x02\0\
    \xea\x02\x01\n\x0b\n\x03\x04\x12\x01\x12\x04\xdf\x02\x08\x0c\n\x0c\n\x04\
    \x04\x12\x02\0\x12\x04\xe0\x02\x02\x16\n\r\n\x05\x04\x12\x02\0\x05\x12\
    \x04\xe0\x02\x02\x08\n\r\n\x05\x04\x12\x02\0\x01\x12\x04\xe0\x02\t\x11\n\
    \r\n\x05\x04\x12\x02\0\x03\x12\x04\xe0\x02\x14\x15\n\x0c\n\x04\x04\x12\
    \x02\x01\x12\x04\xe1\x02\x02\x18\n\r\n\x05\x04\x12\x02\x01\x05\x12\x04\
    \xe1\x02\x02\x08\n\r\n\x05\x04\x12\x02\x01\x01\x12\x04\xe1\x02\t\x13\n\r\
    \n\x05\x04\x12\x02\x01\x03\x12\x04\xe1\x02\x16\x17\n\x0c\n\x04\x04\x12\
    \x02\x02\x12\x04\xe2\x02\x02\x18\n\r\n\x05\x04\x12\x02\x02\x05\x12\x04\
    \xe2\x02\x02\x08\n\r\n\x05\x04\x12\x02\x02\x01\x12\x04\xe2\x02\t\x13\n\r\
    \n\x05\x04\x12\x02\x02\x03\x12\x04\xe2\x02\x16\x17\n\x0c\n\x04\x04\x12\
    \x02\x03\x12\x04\xe3\x02\x02\x13\n\r\n\x05\x04\x12\x02\x03\x05\x12\x04\
    \xe3\x02\x02\x08\n\r\n\x05\x04\x12\x02\x03\x01\x12\x04\xe3\x02\t\x0e\n\r\
    \n\x05\x04\x12\x02\x03\x03\x12\x04\xe3\x02\x11\x12\n\x0c\n\x04\x04\x12\
    \x02\x04\x12\x04\xe4\x02\x02\x12\n\r\n\x05\x04\x12\x02\x04\x05\x12\x04\
    \xe4\x02\x02\x08\n\r\n\x05\x04\x12\x02\x04\x01\x12\x04\xe4\x02\t\r\n\r\n\
    \x05\x04\x12\x02\x04\x03\x12\x04\xe4\x02\x10\x11\n\x0c\n\x04\x04\x12\x02\
    \x05\x12\x04\xe5\x02\x02\x18\n\r\n\x05\x04\x12\x02\x05\x05\x12\x04\xe5\
    \x02\x02\x08\n\r\n\x05\x04\x12\x02\x05\x01\x12\x04\xe5\x02\t\x13\n\r\n\
    \x05\x04\x12\x02\x05\x03\x12\x04\xe5\x02\x16\x17\n\x0c\n\x04\x04\x12\x02\
    \x06\x12\x04\xe6\x02\x02\x18\n\r\n\x05\x04\x12\x02\x06\x05\x12\x04\xe6\
    \x02\x02\x08\n\r\n\x05\x04\x12\x02\x06\x01\x12\x04\xe6\x02\t\x13\n\r\n\
    \x05\x04\x12\x02\x06\x03\x12\x04\xe6\x02\x16\x17\n-\n\x04\x04\x12\x02\
    \x07\x12\x04\xe7\x02\x02\x18\"\x1f\x20TODO:\x20implement\x20private\x20n\
    otes\n\n\r\n\x05\x04\x12\x02\x07\x05\x12\x04\xe7\x02\x02\x08\n\r\n\x05\
    \x04\x12\x02\x07\x01\x12\x04\xe7\x02\t\x13\n\r\n\x05\x04\x12\x02\x07\x03\
    \x12\x04\xe7\x02\x16\x17\n\x0c\n\x02\x04\x13\x12\x06\xec\x02\0\xf0\x02\
    \x01\n\x0b\n\x03\x04\x13\x01\x12\x04\xec\x02\x08\r\n\x0c\n\x04\x04\x13\
    \x02\0\x12\x04\xed\x02\x02\x12\n\r\n\x05\x04\x13\x02\0\x05\x12\x04\xed\
    \x02\x02\x08\n\r\n\x05\x04\x13\x02\0\x01\x12\x04\xed\x02\t\r\n\r\n\x05\
    \x04\x13\x02\0\x03\x12\x04\xed\x02\x10\x11\n\x0c\n\x04\x04\x13\x02\x01\
    \x12\x04\xee\x02\x02\x15\n\r\n\x05\x04\x13\x02\x01\x05\x12\x04\xee\x02\
    \x02\x08\n\r\n\x05\x04\x13\x02\x01\x01\x12\x04\xee\x02\t\x10\n\r\n\x05\
    \x04\x13\x02\x01\x03\x12\x04\xee\x02\x13\x14\n\x0c\n\x04\x04\x13\x02\x02\
    \x12\x04\xef\x02\x02\x16\n\r\n\x05\x04\x13\x02\x02\x05\x12\x04\xef\x02\
    \x02\x07\n\r\n\x05\x04\x13\x02\x02\x01\x12\x04\xef\x02\x08\x11\n\r\n\x05\
    \x04\x13\x02\x02\x03\x12\x04\xef\x02\x14\x15\n\x0c\n\x02\x04\x14\x12\x06\
    \xf2\x02\0\xfb\x02\x01\n\x0b\n\x03\x04\x14\x01\x12\x04\xf2\x02\x08\x0c\n\
    \x0c\n\x04\x04\x14\x02\0\x12\x04\xf3\x02\x02\x10\n\r\n\x05\x04\x14\x02\0\
    \x05\x12\x04\xf3\x02\x02\x08\n\r\n\x05\x04\x14\x02\0\x01\x12\x04\xf3\x02\
    \t\x0b\n\r\n\x05\x04\x14\x02\0\x03\x12\x04\xf3\x02\x0e\x0f\n\x1e\n\x04\
    \x04\x14\x02\x01\x12\x04\xf4\x02\x02\x12\"\x10\x20boats\x20required\n\n\
    \r\n\x05\x04\x14\x02\x01\x05\x12\x04\xf4\x02\x02\x08\n\r\n\x05\x04\x14\
    \x02\x01\x01\x12\x04\xf4\x02\t\r\n\r\n\x05\x04\x14\x02\x01\x03\x12\x04\
    \xf4\x02\x10\x11\n.\n\x04\x04\x14\x02\x02\x12\x04\xf5\x02\x02\x19\"\x20\
    \x20describes\x20what\x20the\x20rule\x20is\x20for\n\n\r\n\x05\x04\x14\
    \x02\x02\x05\x12\x04\xf5\x02\x02\x08\n\r\n\x05\x04\x14\x02\x02\x01\x12\
    \x04\xf5\x02\t\x14\n\r\n\x05\x04\x14\x02\x02\x03\x12\x04\xf5\x02\x17\x18\
    \n'\n\x04\x04\x14\x02\x03\x12\x04\xf6\x02\x02\x17\"\x19\x20always\x20in\
    \x20milliseconds\x20\n\n\r\n\x05\x04\x14\x02\x03\x05\x12\x04\xf6\x02\x02\
    \x07\n\r\n\x05\x04\x14\x02\x03\x01\x12\x04\xf6\x02\x08\x12\n\r\n\x05\x04\
    \x14\x02\x03\x03\x12\x04\xf6\x02\x15\x16\n$\n\x04\x04\x14\x02\x04\x12\
    \x04\xf7\x02\x02\x15\"\x16\x20\x20-1\x20means\x20never\x20ends\n\n\r\n\
    \x05\x04\x14\x02\x04\x05\x12\x04\xf7\x02\x02\x07\n\r\n\x05\x04\x14\x02\
    \x04\x01\x12\x04\xf7\x02\x08\x10\n\r\n\x05\x04\x14\x02\x04\x03\x12\x04\
    \xf7\x02\x13\x14\n\x1a\n\x04\x04\x14\x02\x05\x12\x04\xf8\x02\x02\x17\"\
    \x0c\x20applied\x20to\n\n\r\n\x05\x04\x14\x02\x05\x06\x12\x04\xf8\x02\
    \x02\x08\n\r\n\x05\x04\x14\x02\x05\x01\x12\x04\xf8\x02\t\x12\n\r\n\x05\
    \x04\x14\x02\x05\x03\x12\x04\xf8\x02\x15\x16\n\x16\n\x04\x04\x14\x02\x06\
    \x12\x04\xf9\x02\x02\x1e\"\x08\x20type??\n\n\r\n\x05\x04\x14\x02\x06\x04\
    \x12\x04\xf9\x02\x02\n\n\r\n\x05\x04\x14\x02\x06\x06\x12\x04\xf9\x02\x0b\
    \x11\n\r\n\x05\x04\x14\x02\x06\x01\x12\x04\xf9\x02\x12\x19\n\r\n\x05\x04\
    \x14\x02\x06\x03\x12\x04\xf9\x02\x1c\x1d\n.\n\x02\x04\x15\x12\x06\xfd\
    \x02\0\x82\x03\x01\x1a\x20\x20boat\x20entity\x20and\x20captain\x20entity\
    \n\n\x0b\n\x03\x04\x15\x01\x12\x04\xfd\x02\x08\x0e\n\x0c\n\x04\x04\x15\
    \x02\0\x12\x04\xfe\x02\x02\x12\n\r\n\x05\x04\x15\x02\0\x05\x12\x04\xfe\
    \x02\x02\x08\n\r\n\x05\x04\x15\x02\0\x01\x12\x04\xfe\x02\t\r\n\r\n\x05\
    \x04\x15\x02\0\x03\x12\x04\xfe\x02\x10\x11\n\x0c\n\x04\x04\x15\x02\x01\
    \x12\x04\xff\x02\x02\x19\n\r\n\x05\x04\x15\x02\x01\x05\x12\x04\xff\x02\
    \x02\x08\n\r\n\x05\x04\x15\x02\x01\x01\x12\x04\xff\x02\t\x14\n\r\n\x05\
    \x04\x15\x02\x01\x03\x12\x04\xff\x02\x17\x18\n\x0c\n\x04\x04\x15\x02\x02\
    \x12\x04\x80\x03\x02\x14\n\r\n\x05\x04\x15\x02\x02\x05\x12\x04\x80\x03\
    \x02\x06\n\r\n\x05\x04\x15\x02\x02\x01\x12\x04\x80\x03\x07\x0f\n\r\n\x05\
    \x04\x15\x02\x02\x03\x12\x04\x80\x03\x12\x13\n\x0c\n\x04\x04\x15\x02\x03\
    \x12\x04\x81\x03\x02\x14\n\r\n\x05\x04\x15\x02\x03\x06\x12\x04\x81\x03\
    \x02\x08\n\r\n\x05\x04\x15\x02\x03\x01\x12\x04\x81\x03\t\x0f\n\r\n\x05\
    \x04\x15\x02\x03\x03\x12\x04\x81\x03\x12\x13\nF\n\x02\x04\x16\x12\x06\
    \x89\x03\0\x8f\x03\x0128\nexperience\x20reqires\x20a\x20member\x20from\
    \x20captains:1253#members\n\n\x0b\n\x03\x04\x16\x01\x12\x04\x89\x03\x08\
    \x0e\n\x0c\n\x04\x04\x16\x02\0\x12\x04\x8a\x03\x02\x10\n\r\n\x05\x04\x16\
    \x02\0\x05\x12\x04\x8a\x03\x02\x08\n\r\n\x05\x04\x16\x02\0\x01\x12\x04\
    \x8a\x03\t\x0b\n\r\n\x05\x04\x16\x02\0\x03\x12\x04\x8a\x03\x0e\x0f\n\x0c\
    \n\x04\x04\x16\x02\x01\x12\x04\x8b\x03\x02\x12\n\r\n\x05\x04\x16\x02\x01\
    \x05\x12\x04\x8b\x03\x02\x08\n\r\n\x05\x04\x16\x02\x01\x01\x12\x04\x8b\
    \x03\t\r\n\r\n\x05\x04\x16\x02\x01\x03\x12\x04\x8b\x03\x10\x11\n\x0c\n\
    \x04\x04\x16\x02\x02\x12\x04\x8c\x03\x02\x19\n\r\n\x05\x04\x16\x02\x02\
    \x05\x12\x04\x8c\x03\x02\x08\n\r\n\x05\x04\x16\x02\x02\x01\x12\x04\x8c\
    \x03\t\x14\n\r\n\x05\x04\x16\x02\x02\x03\x12\x04\x8c\x03\x17\x18\n\x0c\n\
    \x04\x04\x16\x02\x03\x12\x04\x8d\x03\x02\x17\n\r\n\x05\x04\x16\x02\x03\
    \x05\x12\x04\x8d\x03\x02\x07\n\r\n\x05\x04\x16\x02\x03\x01\x12\x04\x8d\
    \x03\x08\x12\n\r\n\x05\x04\x16\x02\x03\x03\x12\x04\x8d\x03\x15\x16\n\x0c\
    \n\x04\x04\x16\x02\x04\x12\x04\x8e\x03\x02\x15\n\r\n\x05\x04\x16\x02\x04\
    \x05\x12\x04\x8e\x03\x02\x07\n\r\n\x05\x04\x16\x02\x04\x01\x12\x04\x8e\
    \x03\x08\x10\n\r\n\x05\x04\x16\x02\x04\x03\x12\x04\x8e\x03\x13\x14\n\x0c\
    \n\x02\x04\x17\x12\x06\x91\x03\0\x9b\x03\x01\n\x0b\n\x03\x04\x17\x01\x12\
    \x04\x91\x03\x08\x0e\n<\n\x04\x04\x17\x02\0\x12\x04\x92\x03\x02\x10\".\
    \x20Optional\x20when\x20applied\x20to\x20a\x20rule\x20as\x20an\x20option\
    \n\n\r\n\x05\x04\x17\x02\0\x05\x12\x04\x92\x03\x02\x08\n\r\n\x05\x04\x17\
    \x02\0\x01\x12\x04\x92\x03\t\x0b\n\r\n\x05\x04\x17\x02\0\x03\x12\x04\x92\
    \x03\x0e\x0f\n\x0c\n\x04\x04\x17\x02\x01\x12\x04\x93\x03\x02\x12\n\r\n\
    \x05\x04\x17\x02\x01\x05\x12\x04\x93\x03\x02\x08\n\r\n\x05\x04\x17\x02\
    \x01\x01\x12\x04\x93\x03\t\r\n\r\n\x05\x04\x17\x02\x01\x03\x12\x04\x93\
    \x03\x10\x11\n\x0c\n\x04\x04\x17\x02\x02\x12\x04\x94\x03\x02\x19\n\r\n\
    \x05\x04\x17\x02\x02\x05\x12\x04\x94\x03\x02\x08\n\r\n\x05\x04\x17\x02\
    \x02\x01\x12\x04\x94\x03\t\x14\n\r\n\x05\x04\x17\x02\x02\x03\x12\x04\x94\
    \x03\x17\x18\n\x0c\n\x04\x04\x17\x02\x03\x12\x04\x95\x03\x02\x14\n\r\n\
    \x05\x04\x17\x02\x03\x05\x12\x04\x95\x03\x02\x06\n\r\n\x05\x04\x17\x02\
    \x03\x01\x12\x04\x95\x03\x07\x0f\n\r\n\x05\x04\x17\x02\x03\x03\x12\x04\
    \x95\x03\x12\x13\n\x1f\n\x04\x04\x17\x02\x04\x12\x04\x96\x03\x02\x16\"\
    \x11\x20Always\x20required\n\n\r\n\x05\x04\x17\x02\x04\x06\x12\x04\x96\
    \x03\x02\x0c\n\r\n\x05\x04\x17\x02\x04\x01\x12\x04\x96\x03\r\x11\n\r\n\
    \x05\x04\x17\x02\x04\x03\x12\x04\x96\x03\x14\x15\n\x0c\n\x04\x04\x17\x02\
    \x05\x12\x04\x97\x03\x02\x12\n\r\n\x05\x04\x17\x02\x05\x05\x12\x04\x97\
    \x03\x02\x08\n\r\n\x05\x04\x17\x02\x05\x01\x12\x04\x97\x03\t\r\n\r\n\x05\
    \x04\x17\x02\x05\x03\x12\x04\x97\x03\x10\x11\nD\n\x04\x04\x17\x02\x06\
    \x12\x04\x98\x03\x02\x17\"6\x20the\x20epoch\x20time\x20in\x20seconds\x20\
    when\x20the\x20rule\x20should\x20start\n\n\r\n\x05\x04\x17\x02\x06\x05\
    \x12\x04\x98\x03\x02\x07\n\r\n\x05\x04\x17\x02\x06\x01\x12\x04\x98\x03\
    \x08\x12\n\r\n\x05\x04\x17\x02\x06\x03\x12\x04\x98\x03\x15\x16\nB\n\x04\
    \x04\x17\x02\x07\x12\x04\x99\x03\x02\x15\"4\x20the\x20epoch\x20time\x20i\
    n\x20seconds\x20when\x20the\x20rule\x20should\x20end\n\n\r\n\x05\x04\x17\
    \x02\x07\x05\x12\x04\x99\x03\x02\x07\n\r\n\x05\x04\x17\x02\x07\x01\x12\
    \x04\x99\x03\x08\x10\n\r\n\x05\x04\x17\x02\x07\x03\x12\x04\x99\x03\x13\
    \x14\n\x18\n\x04\x04\x17\x02\x08\x12\x04\x9a\x03\x02&\"\n\x20relation\n\
    \n\r\n\x05\x04\x17\x02\x08\x04\x12\x04\x9a\x03\x02\n\n\r\n\x05\x04\x17\
    \x02\x08\x06\x12\x04\x9a\x03\x0b\x15\n\r\n\x05\x04\x17\x02\x08\x01\x12\
    \x04\x9a\x03\x16!\n\r\n\x05\x04\x17\x02\x08\x03\x12\x04\x9a\x03$%\n\x0c\
    \n\x02\x04\x18\x12\x06\x9d\x03\0\xa4\x03\x01\n\x0b\n\x03\x04\x18\x01\x12\
    \x04\x9d\x03\x08\x12\n\x0c\n\x04\x04\x18\x02\0\x12\x04\x9e\x03\x02\x10\n\
    \r\n\x05\x04\x18\x02\0\x05\x12\x04\x9e\x03\x02\x08\n\r\n\x05\x04\x18\x02\
    \0\x01\x12\x04\x9e\x03\t\x0b\n\r\n\x05\x04\x18\x02\0\x03\x12\x04\x9e\x03\
    \x0e\x0f\n\x0c\n\x04\x04\x18\x02\x01\x12\x04\x9f\x03\x02\x12\n\r\n\x05\
    \x04\x18\x02\x01\x05\x12\x04\x9f\x03\x02\x08\n\r\n\x05\x04\x18\x02\x01\
    \x01\x12\x04\x9f\x03\t\r\n\r\n\x05\x04\x18\x02\x01\x03\x12\x04\x9f\x03\
    \x10\x11\n\x0c\n\x04\x04\x18\x02\x02\x12\x04\xa0\x03\x02\x19\n\r\n\x05\
    \x04\x18\x02\x02\x05\x12\x04\xa0\x03\x02\x08\n\r\n\x05\x04\x18\x02\x02\
    \x01\x12\x04\xa0\x03\t\x14\n\r\n\x05\x04\x18\x02\x02\x03\x12\x04\xa0\x03\
    \x17\x18\n\x0c\n\x04\x04\x18\x02\x03\x12\x04\xa1\x03\x02\x11\n\r\n\x05\
    \x04\x18\x02\x03\x05\x12\x04\xa1\x03\x02\x06\n\r\n\x05\x04\x18\x02\x03\
    \x01\x12\x04\xa1\x03\x07\x0c\n\r\n\x05\x04\x18\x02\x03\x03\x12\x04\xa1\
    \x03\x0f\x10\n\x0c\n\x04\x04\x18\x02\x04\x12\x04\xa2\x03\x02\x17\n\r\n\
    \x05\x04\x18\x02\x04\x05\x12\x04\xa2\x03\x02\x07\n\r\n\x05\x04\x18\x02\
    \x04\x01\x12\x04\xa2\x03\x08\x12\n\r\n\x05\x04\x18\x02\x04\x03\x12\x04\
    \xa2\x03\x15\x16\n\x0c\n\x04\x04\x18\x02\x05\x12\x04\xa3\x03\x02\x15\n\r\
    \n\x05\x04\x18\x02\x05\x05\x12\x04\xa3\x03\x02\x07\n\r\n\x05\x04\x18\x02\
    \x05\x01\x12\x04\xa3\x03\x08\x10\n\r\n\x05\x04\x18\x02\x05\x03\x12\x04\
    \xa3\x03\x13\x14\n\x0c\n\x02\x05\x08\x12\x06\xa6\x03\0\xba\x03\x01\n\x0b\
    \n\x03\x05\x08\x01\x12\x04\xa6\x03\x05\x0f\nU\n\x04\x05\x08\x02\0\x12\
    \x04\xa8\x03\x02\x1e\x1aG\x20option,\x20rate,\x20guest,\x20resource,\x20\
    experience,\x20journey,\x20community,\x20etc...\n\n\r\n\x05\x05\x08\x02\
    \0\x01\x12\x04\xa8\x03\x02\x19\n\r\n\x05\x05\x08\x02\0\x02\x12\x04\xa8\
    \x03\x1c\x1d\n\x0c\n\x04\x05\x08\x02\x01\x12\x04\xa9\x03\x02\x18\n\r\n\
    \x05\x05\x08\x02\x01\x01\x12\x04\xa9\x03\x02\x13\n\r\n\x05\x05\x08\x02\
    \x01\x02\x12\x04\xa9\x03\x16\x17\n\x0c\n\x04\x05\x08\x02\x02\x12\x04\xaa\
    \x03\x02\x1a\n\r\n\x05\x05\x08\x02\x02\x01\x12\x04\xaa\x03\x02\x15\n\r\n\
    \x05\x05\x08\x02\x02\x02\x12\x04\xaa\x03\x18\x19\n\x0c\n\x04\x05\x08\x02\
    \x03\x12\x04\xab\x03\x02\x18\n\r\n\x05\x05\x08\x02\x03\x01\x12\x04\xab\
    \x03\x02\x13\n\r\n\x05\x05\x08\x02\x03\x02\x12\x04\xab\x03\x16\x17\n\x0c\
    \n\x04\x05\x08\x02\x04\x12\x04\xac\x03\x02\x1a\n\r\n\x05\x05\x08\x02\x04\
    \x01\x12\x04\xac\x03\x02\x15\n\r\n\x05\x05\x08\x02\x04\x02\x12\x04\xac\
    \x03\x18\x19\n\x0c\n\x04\x05\x08\x02\x05\x12\x04\xad\x03\x02\x1b\n\r\n\
    \x05\x05\x08\x02\x05\x01\x12\x04\xad\x03\x02\x16\n\r\n\x05\x05\x08\x02\
    \x05\x02\x12\x04\xad\x03\x19\x1a\n\x0c\n\x04\x05\x08\x02\x06\x12\x04\xae\
    \x03\x02\x1f\n\r\n\x05\x05\x08\x02\x06\x01\x12\x04\xae\x03\x02\x1a\n\r\n\
    \x05\x05\x08\x02\x06\x02\x12\x04\xae\x03\x1d\x1e\n\x0c\n\x04\x05\x08\x02\
    \x07\x12\x04\xaf\x03\x02\x1a\n\r\n\x05\x05\x08\x02\x07\x01\x12\x04\xaf\
    \x03\x02\x15\n\r\n\x05\x05\x08\x02\x07\x02\x12\x04\xaf\x03\x18\x19\n\x0c\
    \n\x04\x05\x08\x02\x08\x12\x04\xb0\x03\x02\x1d\n\r\n\x05\x05\x08\x02\x08\
    \x01\x12\x04\xb0\x03\x02\x18\n\r\n\x05\x05\x08\x02\x08\x02\x12\x04\xb0\
    \x03\x1b\x1c\n\xd2\x01\n\x04\x05\x08\x02\t\x12\x04\xb1\x03\x02\x20\"\xc3\
    \x01\x20ENTITY_TYPE_APP\x20=\x203;\n\x20ENTITY_TYPE_CREW\x20=\x204;\n\
    \x20ENTITY_TYPE_CIRCLE\x20=\x205;\n\x20ENTITY_TYPE_POLICY\x20=\x206;\n\
    \x20ENTITY_TYPE_ROLE\x20=\x207;\n\x20ENTITY_TYPE_RESOURCE\x20=\x208;\n\
    \x20ENTITY_TYPE_RULE\x20=\x209;\n\x20ENTITY_TYPE_SESSION\x20=\x2010;\n\n\
    \r\n\x05\x05\x08\x02\t\x01\x12\x04\xb1\x03\x02\x1b\n\r\n\x05\x05\x08\x02\
    \t\x02\x12\x04\xb1\x03\x1e\x1f\n\x0c\n\x02\x05\t\x12\x06\xbc\x03\0\xc5\
    \x03\x01\n\x0b\n\x03\x05\t\x01\x12\x04\xbc\x03\x05\x11\n\x0c\n\x04\x05\t\
    \x02\0\x12\x04\xbd\x03\x02\x20\n\r\n\x05\x05\t\x02\0\x01\x12\x04\xbd\x03\
    \x02\x1b\n\r\n\x05\x05\t\x02\0\x02\x12\x04\xbd\x03\x1e\x1f\n(\n\x04\x05\
    \t\x02\x01\x12\x04\xbe\x03\x02\x1d\"\x1a\x20hotel,\x20venue,\x20home,\
    \x20etc.\n\n\r\n\x05\x05\t\x02\x01\x01\x12\x04\xbe\x03\x02\x18\n\r\n\x05\
    \x05\t\x02\x01\x02\x12\x04\xbe\x03\x1b\x1c\n\x0c\n\x04\x05\t\x02\x02\x12\
    \x04\xbf\x03\x02\x1b\n\r\n\x05\x05\t\x02\x02\x01\x12\x04\xbf\x03\x02\x16\
    \n\r\n\x05\x05\t\x02\x02\x02\x12\x04\xbf\x03\x19\x1a\n\x0c\n\x04\x05\t\
    \x02\x03\x12\x04\xc0\x03\x02\x1c\n\r\n\x05\x05\t\x02\x03\x01\x12\x04\xc0\
    \x03\x02\x17\n\r\n\x05\x05\t\x02\x03\x02\x12\x04\xc0\x03\x1a\x1b\n\x0c\n\
    \x04\x05\t\x02\x04\x12\x04\xc1\x03\x02\x1d\n\r\n\x05\x05\t\x02\x04\x01\
    \x12\x04\xc1\x03\x02\x18\n\r\n\x05\x05\t\x02\x04\x02\x12\x04\xc1\x03\x1b\
    \x1c\n\x0c\n\x04\x05\t\x02\x05\x12\x04\xc2\x03\x02\x1e\n\r\n\x05\x05\t\
    \x02\x05\x01\x12\x04\xc2\x03\x02\x19\n\r\n\x05\x05\t\x02\x05\x02\x12\x04\
    \xc2\x03\x1c\x1d\n\x0c\n\x04\x05\t\x02\x06\x12\x04\xc3\x03\x02\x1b\n\r\n\
    \x05\x05\t\x02\x06\x01\x12\x04\xc3\x03\x02\x16\n\r\n\x05\x05\t\x02\x06\
    \x02\x12\x04\xc3\x03\x19\x1a\n\x0c\n\x04\x05\t\x02\x07\x12\x04\xc4\x03\
    \x02\x1b\n\r\n\x05\x05\t\x02\x07\x01\x12\x04\xc4\x03\x02\x15\n\r\n\x05\
    \x05\t\x02\x07\x02\x12\x04\xc4\x03\x18\x1a\n\x0c\n\x02\x05\n\x12\x06\xc7\
    \x03\0\xd0\x03\x01\n\x0b\n\x03\x05\n\x01\x12\x04\xc7\x03\x05\x08\n\x0c\n\
    \x04\x05\n\x02\0\x12\x04\xc8\x03\x02\x16\n\r\n\x05\x05\n\x02\0\x01\x12\
    \x04\xc8\x03\x02\x11\n\r\n\x05\x05\n\x02\0\x02\x12\x04\xc8\x03\x14\x15\n\
    \x0c\n\x04\x05\n\x02\x01\x12\x04\xc9\x03\x02\x11\n\r\n\x05\x05\n\x02\x01\
    \x01\x12\x04\xc9\x03\x02\x0c\n\r\n\x05\x05\n\x02\x01\x02\x12\x04\xc9\x03\
    \x0f\x10\n\x0c\n\x04\x05\n\x02\x02\x12\x04\xca\x03\x02\x11\n\r\n\x05\x05\
    \n\x02\x02\x01\x12\x04\xca\x03\x02\x0c\n\r\n\x05\x05\n\x02\x02\x02\x12\
    \x04\xca\x03\x0f\x10\n\x0c\n\x04\x05\n\x02\x03\x12\x04\xcb\x03\x02\x12\n\
    \r\n\x05\x05\n\x02\x03\x01\x12\x04\xcb\x03\x02\r\n\r\n\x05\x05\n\x02\x03\
    \x02\x12\x04\xcb\x03\x10\x11\n\x0c\n\x04\x05\n\x02\x04\x12\x04\xcc\x03\
    \x02\x14\n\r\n\x05\x05\n\x02\x04\x01\x12\x04\xcc\x03\x02\x0f\n\r\n\x05\
    \x05\n\x02\x04\x02\x12\x04\xcc\x03\x12\x13\n\x0c\n\x04\x05\n\x02\x05\x12\
    \x04\xcd\x03\x02\x13\n\r\n\x05\x05\n\x02\x05\x01\x12\x04\xcd\x03\x02\x0e\
    \n\r\n\x05\x05\n\x02\x05\x02\x12\x04\xcd\x03\x11\x12\n\x0c\n\x04\x05\n\
    \x02\x06\x12\x04\xce\x03\x02\x11\n\r\n\x05\x05\n\x02\x06\x01\x12\x04\xce\
    \x03\x02\x0c\n\r\n\x05\x05\n\x02\x06\x02\x12\x04\xce\x03\x0f\x10\n\x0c\n\
    \x04\x05\n\x02\x07\x12\x04\xcf\x03\x02\x13\n\r\n\x05\x05\n\x02\x07\x01\
    \x12\x04\xcf\x03\x02\x0e\n\r\n\x05\x05\n\x02\x07\x02\x12\x04\xcf\x03\x11\
    \x12\n\x0c\n\x02\x05\x0b\x12\x06\xd4\x03\0\xda\x03\x01\n\x0b\n\x03\x05\
    \x0b\x01\x12\x04\xd4\x03\x05\x10\n\x0c\n\x04\x05\x0b\x02\0\x12\x04\xd5\
    \x03\x02\x1f\n\r\n\x05\x05\x0b\x02\0\x01\x12\x04\xd5\x03\x02\x1a\n\r\n\
    \x05\x05\x0b\x02\0\x02\x12\x04\xd5\x03\x1d\x1e\n\x0c\n\x04\x05\x0b\x02\
    \x01\x12\x04\xd6\x03\x02\x19\n\r\n\x05\x05\x0b\x02\x01\x01\x12\x04\xd6\
    \x03\x02\x14\n\r\n\x05\x05\x0b\x02\x01\x02\x12\x04\xd6\x03\x17\x18\n\x0c\
    \n\x04\x05\x0b\x02\x02\x12\x04\xd7\x03\x02\x19\n\r\n\x05\x05\x0b\x02\x02\
    \x01\x12\x04\xd7\x03\x02\x14\n\r\n\x05\x05\x0b\x02\x02\x02\x12\x04\xd7\
    \x03\x17\x18\n\x0c\n\x04\x05\x0b\x02\x03\x12\x04\xd8\x03\x02\x19\n\r\n\
    \x05\x05\x0b\x02\x03\x01\x12\x04\xd8\x03\x02\x14\n\r\n\x05\x05\x0b\x02\
    \x03\x02\x12\x04\xd8\x03\x17\x18\n\x0c\n\x04\x05\x0b\x02\x04\x12\x04\xd9\
    \x03\x02\x1c\n\r\n\x05\x05\x0b\x02\x04\x01\x12\x04\xd9\x03\x02\x17\n\r\n\
    \x05\x05\x0b\x02\x04\x02\x12\x04\xd9\x03\x1a\x1b\n\x0c\n\x02\x04\x19\x12\
    \x06\xdc\x03\0\xeb\x03\x01\n\x0b\n\x03\x04\x19\x01\x12\x04\xdc\x03\x08\
    \x0f\n\x0c\n\x04\x04\x19\x02\0\x12\x04\xdd\x03\x02\x10\n\r\n\x05\x04\x19\
    \x02\0\x05\x12\x04\xdd\x03\x02\x08\n\r\n\x05\x04\x19\x02\0\x01\x12\x04\
    \xdd\x03\t\x0b\n\r\n\x05\x04\x19\x02\0\x03\x12\x04\xdd\x03\x0e\x0f\n\x0c\
    \n\x04\x04\x19\x02\x01\x12\x04\xde\x03\x02\x12\n\r\n\x05\x04\x19\x02\x01\
    \x05\x12\x04\xde\x03\x02\x08\n\r\n\x05\x04\x19\x02\x01\x01\x12\x04\xde\
    \x03\t\r\n\r\n\x05\x04\x19\x02\x01\x03\x12\x04\xde\x03\x10\x11\n\x0c\n\
    \x04\x04\x19\x02\x02\x12\x04\xdf\x03\x02\x19\n\r\n\x05\x04\x19\x02\x02\
    \x05\x12\x04\xdf\x03\x02\x08\n\r\n\x05\x04\x19\x02\x02\x01\x12\x04\xdf\
    \x03\t\x14\n\r\n\x05\x04\x19\x02\x02\x03\x12\x04\xdf\x03\x17\x18\n\x0c\n\
    \x04\x04\x19\x02\x03\x12\x04\xe0\x03\x02\x11\n\r\n\x05\x04\x19\x02\x03\
    \x05\x12\x04\xe0\x03\x02\x08\n\r\n\x05\x04\x19\x02\x03\x01\x12\x04\xe0\
    \x03\t\x0c\n\r\n\x05\x04\x19\x02\x03\x03\x12\x04\xe0\x03\x0f\x10\n\x0c\n\
    \x04\x04\x19\x02\x04\x12\x04\xe1\x03\x02\x17\n\r\n\x05\x04\x19\x02\x04\
    \x05\x12\x04\xe1\x03\x02\x08\n\r\n\x05\x04\x19\x02\x04\x01\x12\x04\xe1\
    \x03\t\x12\n\r\n\x05\x04\x19\x02\x04\x03\x12\x04\xe1\x03\x15\x16\n\x18\n\
    \x04\x04\x19\x02\x05\x12\x04\xe2\x03\x02\x11\"\n\x20in\x20bytes\n\n\r\n\
    \x05\x04\x19\x02\x05\x05\x12\x04\xe2\x03\x02\x07\n\r\n\x05\x04\x19\x02\
    \x05\x01\x12\x04\xe2\x03\x08\x0c\n\r\n\x05\x04\x19\x02\x05\x03\x12\x04\
    \xe2\x03\x0f\x10\n\x0c\n\x04\x04\x19\x02\x06\x12\x04\xe3\x03\x02\x11\n\r\
    \n\x05\x04\x19\x02\x06\x05\x12\x04\xe3\x03\x02\x07\n\r\n\x05\x04\x19\x02\
    \x06\x01\x12\x04\xe3\x03\x08\x0c\n\r\n\x05\x04\x19\x02\x06\x03\x12\x04\
    \xe3\x03\x0f\x10\n\x0c\n\x04\x04\x19\x02\x07\x12\x04\xe4\x03\x02\x18\n\r\
    \n\x05\x04\x19\x02\x07\x05\x12\x04\xe4\x03\x02\x08\n\r\n\x05\x04\x19\x02\
    \x07\x01\x12\x04\xe4\x03\t\x13\n\r\n\x05\x04\x19\x02\x07\x03\x12\x04\xe4\
    \x03\x16\x17\n\x0c\n\x04\x04\x19\x02\x08\x12\x04\xe5\x03\x02\x1f\n\r\n\
    \x05\x04\x19\x02\x08\x06\x12\x04\xe5\x03\x02\r\n\r\n\x05\x04\x19\x02\x08\
    \x01\x12\x04\xe5\x03\x0e\x1a\n\r\n\x05\x04\x19\x02\x08\x03\x12\x04\xe5\
    \x03\x1d\x1e\n\x0c\n\x04\x04\x19\x02\t\x12\x04\xe6\x03\x02\x18\n\r\n\x05\
    \x04\x19\x02\t\x05\x12\x04\xe6\x03\x02\x07\n\r\n\x05\x04\x19\x02\t\x01\
    \x12\x04\xe6\x03\x08\x12\n\r\n\x05\x04\x19\x02\t\x03\x12\x04\xe6\x03\x15\
    \x17\n\x0c\n\x04\x04\x19\x02\n\x12\x04\xe7\x03\x02'\n\r\n\x05\x04\x19\
    \x02\n\x04\x12\x04\xe7\x03\x02\n\n\r\n\x05\x04\x19\x02\n\x06\x12\x04\xe7\
    \x03\x0b\x15\n\r\n\x05\x04\x19\x02\n\x01\x12\x04\xe7\x03\x16!\n\r\n\x05\
    \x04\x19\x02\n\x03\x12\x04\xe7\x03$&\n\x0c\n\x04\x04\x19\x02\x0b\x12\x04\
    \xe8\x03\x02\x20\n\r\n\x05\x04\x19\x02\x0b\x06\x12\x04\xe8\x03\x02\r\n\r\
    \n\x05\x04\x19\x02\x0b\x01\x12\x04\xe8\x03\x0e\x1a\n\r\n\x05\x04\x19\x02\
    \x0b\x03\x12\x04\xe8\x03\x1d\x1f\n\x0c\n\x04\x04\x19\x02\x0c\x12\x04\xe9\
    \x03\x02$\n\r\n\x05\x04\x19\x02\x0c\x06\x12\x04\xe9\x03\x02\x15\n\r\n\
    \x05\x04\x19\x02\x0c\x01\x12\x04\xe9\x03\x16\x1e\n\r\n\x05\x04\x19\x02\
    \x0c\x03\x12\x04\xe9\x03!#\n\x1d\n\x04\x04\x19\x02\r\x12\x04\xea\x03\x02\
    $\"\x0f\x20TODO:\x20work\x20on\n\n\r\n\x05\x04\x19\x02\r\x04\x12\x04\xea\
    \x03\x02\n\n\r\n\x05\x04\x19\x02\r\x05\x12\x04\xea\x03\x0b\x11\n\r\n\x05\
    \x04\x19\x02\r\x01\x12\x04\xea\x03\x12\x1e\n\r\n\x05\x04\x19\x02\r\x03\
    \x12\x04\xea\x03!#\n'\n\x02\x04\x1a\x12\x06\xef\x03\0\xf3\x03\x01\x1a\
    \x19\x20TODO:\x20do\x20we\x20need\x20this?\x20\n\n\x0b\n\x03\x04\x1a\x01\
    \x12\x04\xef\x03\x08\x15\n\x0c\n\x04\x04\x1a\x02\0\x12\x04\xf0\x03\x02\"\
    \n\r\n\x05\x04\x1a\x02\0\x05\x12\x04\xf0\x03\x02\x07\n\r\n\x05\x04\x1a\
    \x02\0\x01\x12\x04\xf0\x03\x08\x1d\n\r\n\x05\x04\x1a\x02\0\x03\x12\x04\
    \xf0\x03\x20!\n0\n\x04\x04\x1a\x02\x01\x12\x04\xf2\x03\x02\x14\x1a\"\x20\
    int64\x20current_packets_sent\x20=\x201;\x20\n\n\r\n\x05\x04\x1a\x02\x01\
    \x06\x12\x04\xf2\x03\x02\t\n\r\n\x05\x04\x1a\x02\x01\x01\x12\x04\xf2\x03\
    \n\x0f\n\r\n\x05\x04\x1a\x02\x01\x03\x12\x04\xf2\x03\x12\x13\n\x0c\n\x02\
    \x04\x1b\x12\x06\xf5\x03\0\x8a\x04\x01\n\x0b\n\x03\x04\x1b\x01\x12\x04\
    \xf5\x03\x08\r\n\x0c\n\x04\x04\x1b\x02\0\x12\x04\xf6\x03\x02\x10\n\r\n\
    \x05\x04\x1b\x02\0\x05\x12\x04\xf6\x03\x02\x08\n\r\n\x05\x04\x1b\x02\0\
    \x01\x12\x04\xf6\x03\t\x0b\n\r\n\x05\x04\x1b\x02\0\x03\x12\x04\xf6\x03\
    \x0e\x0f\n\x0c\n\x04\x04\x1b\x02\x01\x12\x04\xf7\x03\x02\x12\n\r\n\x05\
    \x04\x1b\x02\x01\x05\x12\x04\xf7\x03\x02\x08\n\r\n\x05\x04\x1b\x02\x01\
    \x01\x12\x04\xf7\x03\t\r\n\r\n\x05\x04\x1b\x02\x01\x03\x12\x04\xf7\x03\
    \x10\x11\n\x0c\n\x04\x04\x1b\x02\x02\x12\x04\xf8\x03\x02\x19\n\r\n\x05\
    \x04\x1b\x02\x02\x05\x12\x04\xf8\x03\x02\x08\n\r\n\x05\x04\x1b\x02\x02\
    \x01\x12\x04\xf8\x03\t\x14\n\r\n\x05\x04\x1b\x02\x02\x03\x12\x04\xf8\x03\
    \x17\x18\n\x0c\n\x04\x04\x1b\x02\x03\x12\x04\xf9\x03\x02\x15\n\r\n\x05\
    \x04\x1b\x02\x03\x06\x12\x04\xf9\x03\x02\x0b\n\r\n\x05\x04\x1b\x02\x03\
    \x01\x12\x04\xf9\x03\x0c\x10\n\r\n\x05\x04\x1b\x02\x03\x03\x12\x04\xf9\
    \x03\x13\x14\n\x0c\n\x04\x04\x1b\x02\x04\x12\x04\xfa\x03\x02\x1c\n\r\n\
    \x05\x04\x1b\x02\x04\x06\x12\x04\xfa\x03\x02\x0e\n\r\n\x05\x04\x1b\x02\
    \x04\x01\x12\x04\xfa\x03\x0f\x17\n\r\n\x05\x04\x1b\x02\x04\x03\x12\x04\
    \xfa\x03\x1a\x1b\n\x0c\n\x04\x04\x1b\x02\x05\x12\x04\xfb\x03\x02\x1b\n\r\
    \n\x05\x04\x1b\x02\x05\x05\x12\x04\xfb\x03\x02\x07\n\r\n\x05\x04\x1b\x02\
    \x05\x01\x12\x04\xfb\x03\x08\x16\n\r\n\x05\x04\x1b\x02\x05\x03\x12\x04\
    \xfb\x03\x19\x1a\n\x0c\n\x04\x04\x1b\x02\x06\x12\x04\xfc\x03\x02\x10\n\r\
    \n\x05\x04\x1b\x02\x06\x06\x12\x04\xfc\x03\x02\x06\n\r\n\x05\x04\x1b\x02\
    \x06\x01\x12\x04\xfc\x03\x07\x0b\n\r\n\x05\x04\x1b\x02\x06\x03\x12\x04\
    \xfc\x03\x0e\x0f\n\x0c\n\x04\x04\x1b\x02\x07\x12\x04\xfd\x03\x02\x12\n\r\
    \n\x05\x04\x1b\x02\x07\x05\x12\x04\xfd\x03\x02\x07\n\r\n\x05\x04\x1b\x02\
    \x07\x01\x12\x04\xfd\x03\x08\r\n\r\n\x05\x04\x1b\x02\x07\x03\x12\x04\xfd\
    \x03\x10\x11\n\x0c\n\x04\x04\x1b\x02\x08\x12\x04\xfe\x03\x02$\n\r\n\x05\
    \x04\x1b\x02\x08\x04\x12\x04\xfe\x03\x02\n\n\r\n\x05\x04\x1b\x02\x08\x06\
    \x12\x04\xfe\x03\x0b\x19\n\r\n\x05\x04\x1b\x02\x08\x01\x12\x04\xfe\x03\
    \x1a\x1f\n\r\n\x05\x04\x1b\x02\x08\x03\x12\x04\xfe\x03\"#\n\x0c\n\x04\
    \x04\x1b\x02\t\x12\x04\xff\x03\x02\"\n\r\n\x05\x04\x1b\x02\t\x04\x12\x04\
    \xff\x03\x02\n\n\r\n\x05\x04\x1b\x02\t\x06\x12\x04\xff\x03\x0b\x12\n\r\n\
    \x05\x04\x1b\x02\t\x01\x12\x04\xff\x03\x13\x1c\n\r\n\x05\x04\x1b\x02\t\
    \x03\x12\x04\xff\x03\x1f!\n\xab\x01\n\x04\x04\x1b\x02\n\x12\x04\x82\x04\
    \x02\x1d\x1aT\x20Some\x20spaces\x20have\x20inner\x20inner\x20spaces\x20s\
    uch\x20as\x20a\x20master\x20bedroom\x20\n\x20having\x20a\x20\x20bathroom\
    .\n\"G*\nstring\x20building_id\x20=\x204;\nstring\x20floor_id\x20=\x205;\
    \x20\nint32\x20floor_level\x20=\x206;\n\n\r\n\x05\x04\x1b\x02\n\x04\x12\
    \x04\x82\x04\x02\n\n\r\n\x05\x04\x1b\x02\n\x06\x12\x04\x82\x04\x0b\x10\n\
    \r\n\x05\x04\x1b\x02\n\x01\x12\x04\x82\x04\x11\x17\n\r\n\x05\x04\x1b\x02\
    \n\x03\x12\x04\x82\x04\x1a\x1c\nI\n\x04\x04\x1b\x02\x0b\x12\x04\x89\x04\
    \x02&\x1a;\x20data\x20is\x20used\x20to\x20store\x20the\x20specific\x20da\
    ta\x20for\x20a\x20space\x20type.\n\n\r\n\x05\x04\x1b\x02\x0b\x06\x12\x04\
    \x89\x04\x02\x15\n\r\n\x05\x04\x1b\x02\x0b\x01\x12\x04\x89\x04\x16\x20\n\
    \r\n\x05\x04\x1b\x02\x0b\x03\x12\x04\x89\x04#%\n\x0c\n\x02\x04\x1c\x12\
    \x06\x8d\x04\0\x92\x04\x01\n\x0b\n\x03\x04\x1c\x01\x12\x04\x8d\x04\x08\
    \x0f\n\x0c\n\x04\x04\x1c\x02\0\x12\x04\x8e\x04\x02\x10\n\r\n\x05\x04\x1c\
    \x02\0\x05\x12\x04\x8e\x04\x02\x08\n\r\n\x05\x04\x1c\x02\0\x01\x12\x04\
    \x8e\x04\t\x0b\n\r\n\x05\x04\x1c\x02\0\x03\x12\x04\x8e\x04\x0e\x0f\n\x0c\
    \n\x04\x04\x1c\x02\x01\x12\x04\x8f\x04\x02\x12\n\r\n\x05\x04\x1c\x02\x01\
    \x05\x12\x04\x8f\x04\x02\x08\n\r\n\x05\x04\x1c\x02\x01\x01\x12\x04\x8f\
    \x04\t\r\n\r\n\x05\x04\x1c\x02\x01\x03\x12\x04\x8f\x04\x10\x11\n\x0c\n\
    \x04\x04\x1c\x02\x02\x12\x04\x90\x04\x02\x19\n\r\n\x05\x04\x1c\x02\x02\
    \x05\x12\x04\x90\x04\x02\x08\n\r\n\x05\x04\x1c\x02\x02\x01\x12\x04\x90\
    \x04\t\x14\n\r\n\x05\x04\x1c\x02\x02\x03\x12\x04\x90\x04\x17\x18\n\x0c\n\
    \x04\x04\x1c\x02\x03\x12\x04\x91\x04\x02\x12\n\r\n\x05\x04\x1c\x02\x03\
    \x05\x12\x04\x91\x04\x02\x08\n\r\n\x05\x04\x1c\x02\x03\x01\x12\x04\x91\
    \x04\t\r\n\r\n\x05\x04\x1c\x02\x03\x03\x12\x04\x91\x04\x10\x11\n\x0c\n\
    \x02\x05\x0c\x12\x06\x95\x04\0\xa0\x04\x01\n\x0b\n\x03\x05\x0c\x01\x12\
    \x04\x95\x04\x05\x0e\n\x0c\n\x04\x05\x0c\x02\0\x12\x04\x96\x04\x02\x1d\n\
    \r\n\x05\x05\x0c\x02\0\x01\x12\x04\x96\x04\x02\x18\n\r\n\x05\x05\x0c\x02\
    \0\x02\x12\x04\x96\x04\x1b\x1c\n\x0c\n\x04\x05\x0c\x02\x01\x12\x04\x97\
    \x04\x02\x19\n\r\n\x05\x05\x0c\x02\x01\x01\x12\x04\x97\x04\x02\x14\n\r\n\
    \x05\x05\x0c\x02\x01\x02\x12\x04\x97\x04\x17\x18\n\x0c\n\x04\x05\x0c\x02\
    \x02\x12\x04\x98\x04\x02\x1a\n\r\n\x05\x05\x0c\x02\x02\x01\x12\x04\x98\
    \x04\x02\x15\n\r\n\x05\x05\x0c\x02\x02\x02\x12\x04\x98\x04\x18\x19\n\x0c\
    \n\x04\x05\x0c\x02\x03\x12\x04\x99\x04\x02\x19\n\r\n\x05\x05\x0c\x02\x03\
    \x01\x12\x04\x99\x04\x02\x14\n\r\n\x05\x05\x0c\x02\x03\x02\x12\x04\x99\
    \x04\x17\x18\n\x0c\n\x04\x05\x0c\x02\x04\x12\x04\x9a\x04\x02\x18\n\r\n\
    \x05\x05\x0c\x02\x04\x01\x12\x04\x9a\x04\x02\x13\n\r\n\x05\x05\x0c\x02\
    \x04\x02\x12\x04\x9a\x04\x16\x17\n\x0c\n\x04\x05\x0c\x02\x05\x12\x04\x9b\
    \x04\x02\x16\n\r\n\x05\x05\x0c\x02\x05\x01\x12\x04\x9b\x04\x02\x11\n\r\n\
    \x05\x05\x0c\x02\x05\x02\x12\x04\x9b\x04\x14\x15\n\x0c\n\x04\x05\x0c\x02\
    \x06\x12\x04\x9c\x04\x02\x16\n\r\n\x05\x05\x0c\x02\x06\x01\x12\x04\x9c\
    \x04\x02\x11\n\r\n\x05\x05\x0c\x02\x06\x02\x12\x04\x9c\x04\x14\x15\n\x0c\
    \n\x04\x05\x0c\x02\x07\x12\x04\x9d\x04\x02\x16\n\r\n\x05\x05\x0c\x02\x07\
    \x01\x12\x04\x9d\x04\x02\x11\n\r\n\x05\x05\x0c\x02\x07\x02\x12\x04\x9d\
    \x04\x14\x15\n\x0c\n\x04\x05\x0c\x02\x08\x12\x04\x9e\x04\x02\x16\n\r\n\
    \x05\x05\x0c\x02\x08\x01\x12\x04\x9e\x04\x02\x11\n\r\n\x05\x05\x0c\x02\
    \x08\x02\x12\x04\x9e\x04\x14\x15\n\x0c\n\x04\x05\x0c\x02\t\x12\x04\x9f\
    \x04\x02\x16\n\r\n\x05\x05\x0c\x02\t\x01\x12\x04\x9f\x04\x02\x11\n\r\n\
    \x05\x05\x0c\x02\t\x02\x12\x04\x9f\x04\x14\x15\n\x0c\n\x02\x05\r\x12\x06\
    \xa3\x04\0\xad\x04\x01\n\x0b\n\x03\x05\r\x01\x12\x04\xa3\x04\x05\x11\n\
    \x0c\n\x04\x05\r\x02\0\x12\x04\xa4\x04\x02!\n\r\n\x05\x05\r\x02\0\x01\
    \x12\x04\xa4\x04\x02\x1c\n\r\n\x05\x05\r\x02\0\x02\x12\x04\xa4\x04\x1f\
    \x20\n\x0c\n\x04\x05\r\x02\x01\x12\x04\xa5\x04\x02\x1d\n\r\n\x05\x05\r\
    \x02\x01\x01\x12\x04\xa5\x04\x02\x18\n\r\n\x05\x05\r\x02\x01\x02\x12\x04\
    \xa5\x04\x1b\x1c\n\x0c\n\x04\x05\r\x02\x02\x12\x04\xa6\x04\x02\x1a\n\r\n\
    \x05\x05\r\x02\x02\x01\x12\x04\xa6\x04\x02\x15\n\r\n\x05\x05\r\x02\x02\
    \x02\x12\x04\xa6\x04\x18\x19\n\x0c\n\x04\x05\r\x02\x03\x12\x04\xa7\x04\
    \x02\x1f\n\r\n\x05\x05\r\x02\x03\x01\x12\x04\xa7\x04\x02\x1a\n\r\n\x05\
    \x05\r\x02\x03\x02\x12\x04\xa7\x04\x1d\x1e\n\x0c\n\x04\x05\r\x02\x04\x12\
    \x04\xa8\x04\x02\x1a\n\r\n\x05\x05\r\x02\x04\x01\x12\x04\xa8\x04\x02\x15\
    \n\r\n\x05\x05\r\x02\x04\x02\x12\x04\xa8\x04\x18\x19\n\x0c\n\x04\x05\r\
    \x02\x05\x12\x04\xa9\x04\x02\x1c\n\r\n\x05\x05\r\x02\x05\x01\x12\x04\xa9\
    \x04\x02\x17\n\r\n\x05\x05\r\x02\x05\x02\x12\x04\xa9\x04\x1a\x1b\n\x0c\n\
    \x04\x05\r\x02\x06\x12\x04\xaa\x04\x02\x1e\n\r\n\x05\x05\r\x02\x06\x01\
    \x12\x04\xaa\x04\x02\x19\n\r\n\x05\x05\r\x02\x06\x02\x12\x04\xaa\x04\x1c\
    \x1d\n\x0c\n\x04\x05\r\x02\x07\x12\x04\xab\x04\x02\x1b\n\r\n\x05\x05\r\
    \x02\x07\x01\x12\x04\xab\x04\x02\x16\n\r\n\x05\x05\r\x02\x07\x02\x12\x04\
    \xab\x04\x19\x1a\n\x0c\n\x04\x05\r\x02\x08\x12\x04\xac\x04\x02\x1b\n\r\n\
    \x05\x05\r\x02\x08\x01\x12\x04\xac\x04\x02\x16\n\r\n\x05\x05\r\x02\x08\
    \x02\x12\x04\xac\x04\x19\x1a\n\x0c\n\x02\x04\x1d\x12\x06\xaf\x04\0\xb4\
    \x04\x01\n\x0b\n\x03\x04\x1d\x01\x12\x04\xaf\x04\x08\x0c\n\x0c\n\x04\x04\
    \x1d\x02\0\x12\x04\xb0\x04\x02\x12\n\r\n\x05\x04\x1d\x02\0\x05\x12\x04\
    \xb0\x04\x02\x07\n\r\n\x05\x04\x1d\x02\0\x01\x12\x04\xb0\x04\x08\r\n\r\n\
    \x05\x04\x1d\x02\0\x03\x12\x04\xb0\x04\x10\x11\n\x0c\n\x04\x04\x1d\x02\
    \x01\x12\x04\xb1\x04\x02\x13\n\r\n\x05\x04\x1d\x02\x01\x05\x12\x04\xb1\
    \x04\x02\x07\n\r\n\x05\x04\x1d\x02\x01\x01\x12\x04\xb1\x04\x08\x0e\n\r\n\
    \x05\x04\x1d\x02\x01\x03\x12\x04\xb1\x04\x11\x12\n\x0c\n\x04\x04\x1d\x02\
    \x02\x12\x04\xb2\x04\x02\x13\n\r\n\x05\x04\x1d\x02\x02\x05\x12\x04\xb2\
    \x04\x02\x07\n\r\n\x05\x04\x1d\x02\x02\x01\x12\x04\xb2\x04\x08\x0e\n\r\n\
    \x05\x04\x1d\x02\x02\x03\x12\x04\xb2\x04\x11\x12\n\x0c\n\x04\x04\x1d\x02\
    \x03\x12\x04\xb3\x04\x02\x12\n\r\n\x05\x04\x1d\x02\x03\x05\x12\x04\xb3\
    \x04\x02\x07\n\r\n\x05\x04\x1d\x02\x03\x01\x12\x04\xb3\x04\x08\r\n\r\n\
    \x05\x04\x1d\x02\x03\x03\x12\x04\xb3\x04\x10\x11\n\x0c\n\x02\x04\x1e\x12\
    \x06\xb6\x04\0\xb9\x04\x01\n\x0b\n\x03\x04\x1e\x01\x12\x04\xb6\x04\x08&\
    \n\x0c\n\x04\x04\x1e\x02\0\x12\x04\xb7\x04\x02\x18\n\r\n\x05\x04\x1e\x02\
    \0\x05\x12\x04\xb7\x04\x02\x08\n\r\n\x05\x04\x1e\x02\0\x01\x12\x04\xb7\
    \x04\t\x13\n\r\n\x05\x04\x1e\x02\0\x03\x12\x04\xb7\x04\x16\x17\n\x0c\n\
    \x04\x04\x1e\x02\x01\x12\x04\xb8\x04\x02*\n\r\n\x05\x04\x1e\x02\x01\x04\
    \x12\x04\xb8\x04\x02\n\n\r\n\x05\x04\x1e\x02\x01\x06\x12\x04\xb8\x04\x0b\
    \x17\n\r\n\x05\x04\x1e\x02\x01\x01\x12\x04\xb8\x04\x18%\n\r\n\x05\x04\
    \x1e\x02\x01\x03\x12\x04\xb8\x04()\n\x0c\n\x02\x04\x1f\x12\x06\xbb\x04\0\
    \xbe\x04\x01\n\x0b\n\x03\x04\x1f\x01\x12\x04\xbb\x04\x08'\n\x0c\n\x04\
    \x04\x1f\x02\0\x12\x04\xbc\x04\x02\x18\n\r\n\x05\x04\x1f\x02\0\x05\x12\
    \x04\xbc\x04\x02\x08\n\r\n\x05\x04\x1f\x02\0\x01\x12\x04\xbc\x04\t\x13\n\
    \r\n\x05\x04\x1f\x02\0\x03\x12\x04\xbc\x04\x16\x17\n\x0c\n\x04\x04\x1f\
    \x02\x01\x12\x04\xbd\x04\x02*\n\r\n\x05\x04\x1f\x02\x01\x04\x12\x04\xbd\
    \x04\x02\n\n\r\n\x05\x04\x1f\x02\x01\x06\x12\x04\xbd\x04\x0b\x17\n\r\n\
    \x05\x04\x1f\x02\x01\x01\x12\x04\xbd\x04\x18%\n\r\n\x05\x04\x1f\x02\x01\
    \x03\x12\x04\xbd\x04()b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(32);
            messages.push(Customer::generated_message_descriptor_data());
            messages.push(Experience::generated_message_descriptor_data());
            messages.push(Confirmation::generated_message_descriptor_data());
            messages.push(Comment::generated_message_descriptor_data());
            messages.push(Feature::generated_message_descriptor_data());
            messages.push(Rate::generated_message_descriptor_data());
            messages.push(TaxRate::generated_message_descriptor_data());
            messages.push(TelematicUpdate::generated_message_descriptor_data());
            messages.push(Location::generated_message_descriptor_data());
            messages.push(Geo::generated_message_descriptor_data());
            messages.push(Address::generated_message_descriptor_data());
            messages.push(Query::generated_message_descriptor_data());
            messages.push(Term::generated_message_descriptor_data());
            messages.push(Rating::generated_message_descriptor_data());
            messages.push(Impression::generated_message_descriptor_data());
            messages.push(Source::generated_message_descriptor_data());
            messages.push(Calendar::generated_message_descriptor_data());
            messages.push(Event::generated_message_descriptor_data());
            messages.push(Note::generated_message_descriptor_data());
            messages.push(Error::generated_message_descriptor_data());
            messages.push(Rule::generated_message_descriptor_data());
            messages.push(Option::generated_message_descriptor_data());
            messages.push(Caveat::generated_message_descriptor_data());
            messages.push(Entity::generated_message_descriptor_data());
            messages.push(Permission::generated_message_descriptor_data());
            messages.push(Content::generated_message_descriptor_data());
            messages.push(ContentPacket::generated_message_descriptor_data());
            messages.push(Space::generated_message_descriptor_data());
            messages.push(Amenity::generated_message_descriptor_data());
            messages.push(Size::generated_message_descriptor_data());
            messages.push(ExperienceConfirmationsRequest::generated_message_descriptor_data());
            messages.push(ExperienceConfirmationsResponse::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(14);
            enums.push(ConfirmationStatus::generated_enum_descriptor_data());
            enums.push(Currency::generated_enum_descriptor_data());
            enums.push(RateFrequency::generated_enum_descriptor_data());
            enums.push(RateType::generated_enum_descriptor_data());
            enums.push(ExperienceType::generated_enum_descriptor_data());
            enums.push(LocationType::generated_enum_descriptor_data());
            enums.push(Order::generated_enum_descriptor_data());
            enums.push(CreatorType::generated_enum_descriptor_data());
            enums.push(EntityType::generated_enum_descriptor_data());
            enums.push(ResourceType::generated_enum_descriptor_data());
            enums.push(Day::generated_enum_descriptor_data());
            enums.push(ContentType::generated_enum_descriptor_data());
            enums.push(SpaceType::generated_enum_descriptor_data());
            enums.push(SpaceSubType::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
